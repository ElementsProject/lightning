#include <bitcoin/block.h>
#include <common/cryptomsg.h>
#include <common/features.h>
#include <common/node_id.h>
#include <common/wireaddr.h>
#include <wire/onion_wire.h>

msgtype,connectd_init,2000
msgdata,connectd_init,chainparams,chainparams,
msgdata,connectd_init,our_features,feature_set,
msgdata,connectd_init,id,node_id,
msgdata,connectd_init,num_wireaddrs,u16,
msgdata,connectd_init,wireaddrs,wireaddr_internal,num_wireaddrs
msgdata,connectd_init,listen_announce,enum addr_listen_announce,num_wireaddrs
msgdata,connectd_init,tor_proxyaddr,?wireaddr,
msgdata,connectd_init,use_tor_proxy_always,bool,
msgdata,connectd_init,dev_allow_localhost,bool,
msgdata,connectd_init,use_dns,bool,
msgdata,connectd_init,tor_password,wirestring,
msgdata,connectd_init,use_v3_autotor,bool,
msgdata,connectd_init,timeout_secs,u32,
msgdata,connectd_init,websocket_helper,wirestring,
msgdata,connectd_init,websocket_port,u16,
msgdata,connectd_init,dev_fast_gossip,bool,
# If this is set, then fd 5 is dev_disconnect_fd.
msgdata,connectd_init,dev_disconnect,bool,

# Connectd->master, here are the addresses I bound, can announce.
msgtype,connectd_init_reply,2100
msgdata,connectd_init_reply,num_bindings,u16,
msgdata,connectd_init_reply,bindings,wireaddr_internal,num_bindings
msgdata,connectd_init_reply,num_announcable,u16,
msgdata,connectd_init_reply,announcable,wireaddr,num_announcable

# Activate the connect daemon, so others can connect.
msgtype,connectd_activate,2025
# Do we listen?
msgdata,connectd_activate,listen,bool,

# Connectd->master, I am ready.
msgtype,connectd_activate_reply,2125

# connectd->master: disconnect this peer please (due to reconnect).
msgtype,connectd_reconnected,2112
msgdata,connectd_reconnected,id,node_id,

# Master -> connectd: connect to a peer.
msgtype,connectd_connect_to_peer,2001
msgdata,connectd_connect_to_peer,id,node_id,
msgdata,connectd_connect_to_peer,seconds_waited,u32,
msgdata,connectd_connect_to_peer,len,u32,
msgdata,connectd_connect_to_peer,addrs,wireaddr,len
msgdata,connectd_connect_to_peer,addrhint,?wireaddr_internal,

# Connectd->master: connect failed.
msgtype,connectd_connect_failed,2020
msgdata,connectd_connect_failed,id,node_id,
msgdata,connectd_connect_failed,failcode,errcode_t,
msgdata,connectd_connect_failed,failreason,wirestring,
msgdata,connectd_connect_failed,seconds_to_delay,u32,
msgdata,connectd_connect_failed,addrhint,?wireaddr_internal,

# Connectd -> master: we got a peer. Plus fd for peer daemon
msgtype,connectd_peer_connected,2002
msgdata,connectd_peer_connected,id,node_id,
msgdata,connectd_peer_connected,addr,wireaddr_internal,
msgdata,connectd_peer_connected,remote_addr,?wireaddr,
msgdata,connectd_peer_connected,incoming,bool,
msgdata,connectd_peer_connected,flen,u16,
msgdata,connectd_peer_connected,features,u8,flen

# master -> connectd: peer has disconnected.
msgtype,connectd_peer_disconnected,2015
msgdata,connectd_peer_disconnected,id,node_id,

# master -> connectd: give message to peer and disconnect. 
msgtype,connectd_peer_final_msg,2003
msgdata,connectd_peer_final_msg,id,node_id,
msgdata,connectd_peer_final_msg,len,u16,
msgdata,connectd_peer_final_msg,msg,u8,len

# master -> connectd: do you have a memleak?
msgtype,connectd_dev_memleak,2033

msgtype,connectd_dev_memleak_reply,2133
msgdata,connectd_dev_memleak_reply,leak,bool,

# Ping/pong test.  Waits for a reply if it expects one.
msgtype,connectd_ping,2030
msgdata,connectd_ping,id,node_id,
msgdata,connectd_ping,num_pong_bytes,u16,
msgdata,connectd_ping,len,u16,

msgtype,connectd_ping_reply,2130
# False if we there was already a ping in progress.
msgdata,connectd_ping_reply,sent,bool,
# 0 == no pong expected, otherwise length of pong.
msgdata,connectd_ping_reply,totlen,u16,

# We tell lightningd we got an onionmsg
msgtype,connectd_got_onionmsg_to_us,2145
msgdata,connectd_got_onionmsg_to_us,obs2,bool,
msgdata,connectd_got_onionmsg_to_us,node_alias,pubkey,
msgdata,connectd_got_onionmsg_to_us,self_id,?secret,
msgdata,connectd_got_onionmsg_to_us,reply_blinding,?pubkey,
msgdata,connectd_got_onionmsg_to_us,reply_first_node,?pubkey,
msgdata,connectd_got_onionmsg_to_us,reply_path_len,u16,
msgdata,connectd_got_onionmsg_to_us,reply_path,onionmsg_path,reply_path_len
msgdata,connectd_got_onionmsg_to_us,rawmsg_len,u16,
msgdata,connectd_got_onionmsg_to_us,rawmsg,u8,rawmsg_len

# Lightningd tells us to send an onion message.
msgtype,connectd_send_onionmsg,2041
msgdata,connectd_send_onionmsg,obs2,bool,
msgdata,connectd_send_onionmsg,id,node_id,
msgdata,connectd_send_onionmsg,onion_len,u16,
msgdata,connectd_send_onionmsg,onion,u8,onion_len
msgdata,connectd_send_onionmsg,blinding,pubkey,

# A custom message that we got from a peer and don't know how to handle, so we
# forward it to the master for further handling.
msgtype,connectd_custommsg_in,2110
msgdata,connectd_custommsg_in,id,node_id,
msgdata,connectd_custommsg_in,msg_len,u16,
msgdata,connectd_custommsg_in,msg,u8,msg_len

# A custom message that the lightningd tells us to send to the peer.
msgtype,connectd_custommsg_out,2011
msgdata,connectd_custommsg_out,id,node_id,
msgdata,connectd_custommsg_out,msg_len,u16,
msgdata,connectd_custommsg_out,msg,u8,msg_len
