/* This file was generated by generate-wire.py */
/* Do not modify this file! Modify the .csv file it was generated from. */
/* Original template can be found at tools/gen/impl_template */

#include <connectd/connectd_gossipd_wiregen.h>
#include <assert.h>
#include <ccan/array_size/array_size.h>
#include <ccan/mem/mem.h>
#include <ccan/tal/str/str.h>
#include <common/utils.h>
#include <stdio.h>

#ifndef SUPERVERBOSE
#define SUPERVERBOSE(...)
#endif


const char *connectd_gossipd_wire_name(int e)
{
	static char invalidbuf[sizeof("INVALID ") + STR_MAX_CHARS(e)];

	switch ((enum connectd_gossipd_wire)e) {
	case WIRE_GOSSIPD_NEW_PEER: return "WIRE_GOSSIPD_NEW_PEER";
	case WIRE_GOSSIPD_NEW_PEER_REPLY: return "WIRE_GOSSIPD_NEW_PEER_REPLY";
	case WIRE_GOSSIPD_GET_ADDRS: return "WIRE_GOSSIPD_GET_ADDRS";
	case WIRE_GOSSIPD_GET_ADDRS_REPLY: return "WIRE_GOSSIPD_GET_ADDRS_REPLY";
	}

	snprintf(invalidbuf, sizeof(invalidbuf), "INVALID %i", e);
	return invalidbuf;
}

bool connectd_gossipd_wire_is_defined(u16 type)
{
	switch ((enum connectd_gossipd_wire)type) {
	case WIRE_GOSSIPD_NEW_PEER:;
	case WIRE_GOSSIPD_NEW_PEER_REPLY:;
	case WIRE_GOSSIPD_GET_ADDRS:;
	case WIRE_GOSSIPD_GET_ADDRS_REPLY:;
	      return true;
	}
	return false;
}





/* WIRE: GOSSIPD_NEW_PEER */
/* Communication between gossipd and connectd. */
u8 *towire_gossipd_new_peer(const tal_t *ctx, const struct node_id *id, bool gossip_queries_feature, bool initial_routing_sync)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIPD_NEW_PEER);
	towire_node_id(&p, id);
	/* Did we negotiate LOCAL_GOSSIP_QUERIES? */
	towire_bool(&p, gossip_queries_feature);
	/* Did they offer LOCAL_INITIAL_ROUTING_SYNC? */
	towire_bool(&p, initial_routing_sync);

	return memcheck(p, tal_count(p));
}
bool fromwire_gossipd_new_peer(const void *p, struct node_id *id, bool *gossip_queries_feature, bool *initial_routing_sync)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIPD_NEW_PEER)
		return false;
 	fromwire_node_id(&cursor, &plen, id);
 	/* Did we negotiate LOCAL_GOSSIP_QUERIES? */
	*gossip_queries_feature = fromwire_bool(&cursor, &plen);
 	/* Did they offer LOCAL_INITIAL_ROUTING_SYNC? */
	*initial_routing_sync = fromwire_bool(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: GOSSIPD_NEW_PEER_REPLY */
/* if success: + gossip fd and gossip_store fd */
u8 *towire_gossipd_new_peer_reply(const tal_t *ctx, bool success, const struct gossip_state *gs)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIPD_NEW_PEER_REPLY);
	towire_bool(&p, success);
	if (!gs)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_gossip_state(&p, gs);
	}

	return memcheck(p, tal_count(p));
}
bool fromwire_gossipd_new_peer_reply(const tal_t *ctx, const void *p, bool *success, struct gossip_state **gs)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIPD_NEW_PEER_REPLY)
		return false;
 	*success = fromwire_bool(&cursor, &plen);
 	if (!fromwire_bool(&cursor, &plen))
		*gs = NULL;
	else {
		*gs = tal(ctx, struct gossip_state);
		fromwire_gossip_state(&cursor, &plen, *gs);
	}
	return cursor != NULL;
}

/* WIRE: GOSSIPD_GET_ADDRS */
/* Connectd asks gossipd for any known addresses for that node. */
u8 *towire_gossipd_get_addrs(const tal_t *ctx, const struct node_id *id)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIPD_GET_ADDRS);
	towire_node_id(&p, id);

	return memcheck(p, tal_count(p));
}
bool fromwire_gossipd_get_addrs(const void *p, struct node_id *id)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIPD_GET_ADDRS)
		return false;
 	fromwire_node_id(&cursor, &plen, id);
	return cursor != NULL;
}

/* WIRE: GOSSIPD_GET_ADDRS_REPLY */
u8 *towire_gossipd_get_addrs_reply(const tal_t *ctx, const struct wireaddr *addrs)
{
	u16 num = tal_count(addrs);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIPD_GET_ADDRS_REPLY);
	towire_u16(&p, num);
	for (size_t i = 0; i < num; i++)
		towire_wireaddr(&p, addrs + i);

	return memcheck(p, tal_count(p));
}
bool fromwire_gossipd_get_addrs_reply(const tal_t *ctx, const void *p, struct wireaddr **addrs)
{
	u16 num;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIPD_GET_ADDRS_REPLY)
		return false;
 	num = fromwire_u16(&cursor, &plen);
 	// 2nd case addrs
	*addrs = num ? tal_arr(ctx, struct wireaddr, num) : NULL;
	for (size_t i = 0; i < num; i++)
		fromwire_wireaddr(&cursor, &plen, *addrs + i);
	return cursor != NULL;
}
// SHA256STAMP:3843c1c89472b3084feca4bb6d0a39598f768d4c4ff866f8dc94169716b6fadd
