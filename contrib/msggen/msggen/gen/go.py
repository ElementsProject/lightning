import logging
import sys
from textwrap import dedent, indent
from typing import TextIO, Tuple
from msggen.model import (ArrayField, CompositeField, EnumField,
                          PrimitiveField, Service, Field)
from msggen.gen.generator import IGenerator


logger = logging.getLogger(__name__)

# A map of schema type to rust primitive types.
typemap = {
    'boolean': 'bool',
    'hex': 'string',
    'msat': 'Amount',
    'msat_or_all': 'AmountOrAll',
    'msat_or_any': 'AmountOrAny',
    'number': 'float64',
    'pubkey': 'string',
    'short_channel_id': 'ShortChannelId',
    'signature': 'string',
    'string': 'string',
    'txid': 'string',
    'float': 'float32',
    'utxo': 'string',
    'feerate': 'FeeRate',
    'outpoint': 'string',
    'outputdesc': 'string',
    'hash': 'string',
    'secret': 'string',
    'u8': 'uint8',
    'u16': 'uint16',
    'u64': 'uint64',
    'u32': 'uint32',
}

# Paths that should be overridden.
overrides = {
    'ListPeers.peers[].channels[].state_changes[].old_state': "ChannelState",
    'ListPeers.peers[].channels[].state_changes[].new_state': "ChannelState",
    'ListPeers.peers[].channels[].state_changes[].cause': "ChannelStateChangeCause",
    # 'ListPeers.peers[].channels[].htlcs[].state': None,
    'ListPeers.peers[].channels[].opener': "ChannelSide",
    'ListPeers.peers[].channels[].closer': "ChannelSide",
    'ListPeers.peers[].channels[].features[]': "string",
    'ListFunds.channels[].state': 'ChannelState',
    # 'ListTransactions.transactions[].type[]': None,
    # 'Invoice.exposeprivatechannels': None,
    # THIS ARE THE NEW ONES.
    'ListSendPays.status': 'PayStatus',
    'ListPays.status': 'PayStatus',
    'ListSendPays.status': 'PayStatus',
    'WaitSendPay.status': 'PayStatus',
    'KeySend.status': 'PayStatus',
    'SendPay.status': 'PayStatus',
}

generated_enums = []

header = f"""package rpc

import (
	"encoding/json"
	"fmt"
)

//! This file was automatically generated using the following command:
//!
//! ```bash
//! {" ".join(sys.argv)}
//! ```
//!
//! Do not edit this file, it'll be overwritten. Rather edit the schema that
//! this file was generated from

"""

def underscore_to_camel(word: str):
    return ''.join(x.capitalize() or '_' for x in word.split('_'))

def normalize_varname(field):
    field.path = "".join(x for x in field.path.title())

def gen_field(field: Field, num=0):
    if isinstance(field, CompositeField):
        return gen_composite(field)
    elif isinstance(field, EnumField):
        return gen_enum(field)
    elif isinstance(field, ArrayField):
        return gen_array(field)
    elif isinstance(field, PrimitiveField):
        return gen_primitive(field)
    else:
        raise ValueError(f"Unmanaged type {field}")
    
def gen_array(a: ArrayField):
    name = a.normalized().replace("[]", "")
    _, decl = gen_field(a.itemtype)
    
    if a.path in overrides:
        decl = ""  # No declaration if we have an override
        itemtype = overrides[a.path]
    elif isinstance(a.itemtype, PrimitiveField):
        itemtype = a.itemtype.typename
    elif isinstance(a.itemtype, CompositeField):
        itemtype = a.itemtype.typename
    elif isinstance(a.itemtype, EnumField):
        itemtype = a.itemtype.typename
 
    if itemtype is None:
        return ("", "")  # Override said not to include

    itemtype = typemap.get(itemtype, itemtype)
    
    defi = ""
    if a.deprecated:
        defi += f"// Deprecated: This field has been deprecated in {a.deprecated}\n"
    if a.required:
        defi += f"// Required field"
    else:
        defi += f"// Optional field"

    if a.description:
        defi += f": {a.description}"

    defi += ".\n"
    defi += f"{underscore_to_camel(name.capitalize())} []{itemtype} `json:\"{name}\"`\n"
    return (defi, decl)

def gen_primitive(p: PrimitiveField):
    defi, decl = "", ""
    org = p.name.name
    typename = typemap.get(p.typename, p.typename)
    normalize_varname(p)

    if p.path in overrides:
        typename = overrides[p.path]

    if typename is None:
        return "", ""
   
    if p.deprecated:
        defi += f"// Deprecated: This field has been deprecated in {p.deprecated}\n"
    if p.required:
        defi += f"// Required field"
    else:
        defi += f"// Optional field"

    if p.description:
        defi += f": {p.description}"
    
    defi += ".\n"
    defi += f"{underscore_to_camel(p.name.normalized())} {typename} `json:\"{org}\"`\n"
    return defi, decl

def gen_enum(e: EnumField) -> Tuple[str, str]:
    defi, decl = "", ""
    typename = e.typename

    typename = e.typename
    if e.path in overrides:
        typename = overrides[e.path]

    if typename is None:
        return "", ""

    if e.deprecated:
        defi += f"// Deprecated: This field has been deprecated in {e.deprecated}\n"
    if e.required:
        defi += f"// Required field\n"
    if not e.required:
        defi += f"// Optional field\n"
    
    defi += f"{underscore_to_camel(e.name.normalized())} {typename} `json:\"{e.name.name}\"`\n"
    
    if typename in generated_enums:
        # We already generated this enum, skip it
        return defi, ""

    if e.deprecated:
        decl += "// Deprecated: This field has been deprecated in {e.deprecated}\n"
    if e.name:
        decl += f"// {typename}"
    if e.description:
        decl += f", {e.description}."

    decl += f"\n"
    # Type definition
    decl += f"type {typename} int\n\n"

    decl += f"const (\n"
    for i, v in enumerate(e.variants):
        if v is None:
            continue
        norm = underscore_to_camel( v.normalized().capitalize())
        decl += indent(f"{typename}_{norm}", "\t")
        if i == 0:
            decl += f" {typename} = iota"
        decl += "\n"
    decl += ")\n\n"

    # Add method that converts the enum to and from.
    decl += f"func (s {typename}) String() (string, error) {{\n"
    decl += "\tswitch s {\n"
    for v in e.variants:
        norm = underscore_to_camel( v.normalized().capitalize())
        decl += f"\tcase {typename}_{norm}:\n"
        decl += f"\t\treturn \"{v}\", nil\n"
    decl += "\tdefault:\n\t\treturn \"\", fmt.Errorf(\"enum type not found\")\n"
    decl += "\t}\n}\n\n"

    decl += f"func (s *{typename}) FromString(p string) error {{\n"
    decl += "\tswitch p {\n"
    for v in e.variants:
        norm = underscore_to_camel( v.normalized().capitalize())
        decl += f"\tcase \"{v}\":\n"
        decl += f"\t\t*s = {typename}_{norm}\n"
    decl += "\tdefault:\n\t\treturn fmt.Errorf(\"enum type not found\")\n"
    decl += "\t}\n"
    decl += "\treturn nil\n"
    decl += "}\n\n"

    # Add json marshaller and unmarshaller
    decl += f"func (s {typename}) MarshalJSON() ([]byte, error) {{\n" 
    decl += "\tstr, err := s.String()\n"
    decl += "\tif err != nil {\n"
    decl += "\t\treturn nil, err\n"
    decl += "\t}\n"
    decl += "\treturn []byte(str), nil\n"
    decl += "}\n\n"

    decl += f"func (s *{typename}) UnmarshalJSON(b []byte) error {{\n" 
    decl += "\tvar j string\n"
    decl += "\terr := json.Unmarshal(b, &j)\n"
    decl += "\tif err != nil {\n"
    decl += "\t\treturn err\n"
    decl += "\t}\n"
    decl += f"\terr = s.FromString(j)\n"
    decl += "\tif err != nil {\n"
    decl += "\t\treturn err\n"
    decl += "\t}\n"
    decl += "\treturn nil\n"
    decl += "}\n\n"

    generated_enums.append(typename)
    return defi, decl

def gen_composite(c: CompositeField) -> Tuple[str, str]:
    defi, decl = "", ""
    fields = []
    for f in c.fields:
        fields.append(gen_field(f))

    decl += "".join(f[1] for f in fields)

    decl += f"type {c.typename} struct{{\n"

    decl += "".join(indent(f[0], "\t") for f in fields)

    decl += "}\n\n"

    if c.deprecated:
        defi += f"// Deprecated: This field has been deprecated in {c.deprecated}\n"
    if c.required:
        defi += f"// Required field\n"
    if not c.required:
        defi += f"// Optional field\n"
    
    defi += f"{underscore_to_camel(c.name.normalized())} {c.typename} `json:\"{c.name.name}\"`\n"    

    return defi, decl

def align_fields(s: str) -> str:
    lines = s.splitlines()
    maxlens = []
    ls = []
    for line in lines:
        cols = line.split(sep=" ")
        if len(cols) == len(maxlens):
            maxlens = [max(maxlens[x], len(cols[x])) for (x, _) in enumerate(cols)]
        else:
            maxlens = [len(col) for col in cols]
    
    s = ""
    for line in lines:
        if line.startswith("//"):
            s += f"{line}\n"
        else:
            cols = line.split(sep=" ")
            s += f"{cols[0]: <{maxlens[0]}} {cols[1]: <{maxlens[1]}} {cols[2]: <{maxlens[2]}}\n"
    return s

class GoGenerator(IGenerator):
    def __init__(self, dest: TextIO):
        self.dest = dest

    def write(self, text: str, numindent: int = 0) -> None:
        raw = dedent(text)
        if numindent > 0:
            raw = indent(text, "\t" * numindent)
        self.dest.write(raw)

    def generate_requests(self, service: Service):
        for method in service.methods:
            _, decl = gen_composite(method.request)
            self.write(decl, numindent=0)
   
    def generate_response(self, service: Service):
        for method in service.methods:
            _, decl = gen_composite(method.response)
            self.write(decl, numindent=0)

    def generate(self, service: Service) -> None:
        self.write(header)
        self.generate_requests(service)
        self.generate_response(service)

