import re
import sys
from typing import TextIO, Tuple
from textwrap import dedent, indent
import logging
from .model import (ArrayField, CompositeField, EnumField,
                    PrimitiveField, Service)

logger = logging.getLogger(__name__)

typemap = {
    'boolean': 'bool',
    'hex': 'string',
    'msat': 'int64<msat>',
    'msat_or_all': 'AmountOrAll',
    'msat_or_any': 'AmountOrAny',
    'number': 'int64',
    'pubkey': 'PubKey',
    'short_channel_id': 'ShortChannelId',
    'signature': 'string',
    'string': 'string',
    'txid': 'string',
    'float': 'float',
    'feerate': 'Feerate',
    'outpoint': 'OutPoint',
    'outputdesc': 'OutputDescriptor',
    'hash': 'Hash',
    'secret': 'PrivKey',

    'u8': 'byte',
    'u16': 'uint16',
    'u32': 'uint32',
    'u64': 'uint64',
    'i8': 'byte',
    'i16': 'int16',
    'i32': 'int32',
    'i64': 'int64',
}

converter_map = {
    'int64<msat>': 'MSatJsonConverter',
    'PubKey': 'PubKeyJsonConverter',
    'ShortChannelId': 'ShortChannelIdJsonConverter',
    'PrivKey': 'PrivKeyJsonConverter',
    'Hash': 'HashJsonConverter',
    'AmountOrAny': 'AmountOrAnyJsonConverter',
    'AmountOrAll': 'AmountOrAllJsonConverter',
    'OutPoint': 'OutPointJsonConverter',
    'Feerate': 'FeerateJsonConverter',
    'OutputDescriptor': 'OutputDescriptorJsonConverter',
}

# Manual overrides for some of the auto-generated types for paths
overrides = {
    'ListPeers.peers[].channels[].state_changes[].old_state': "ChannelState",
    'ListPeers.peers[].channels[].state_changes[].new_state': "ChannelState",
    'ListPeers.peers[].channels[].state_changes[].cause': "ChannelStateChangeCause",
    'ListPeers.peers[].channels[].htlcs[].state': None,
    'ListPeers.peers[].channels[].opener': "ChannelSide",
    'ListPeers.peers[].channels[].closer': "ChannelSide",
    'ListPeers.peers[].channels[].features[]': "string",
    'ListFunds.channels[].state': 'ChannelState',
    'ListTransactions.transactions[].type[]': None,
    'Invoice.exposeprivatechannels': None,
}

header = f"""
/// This file was automatically generated using following command:
/// ```bash
/// {' '.join(sys.argv)}
/// ```
///
/// Do not edit this file, it'll be overwritten. Rather edit the schema that
/// This file was generated from
namespace ClnSharp

"""


def to_PascalCase(s):
    return s.replace("_", " ").title().replace(" ", "")


def normalize_varname(field):
    """Make sure that the variable name of this field is valid
    """
    field.path = field.path.replace("-", "_")
    field.path = re.sub(r'(?<!^)(?=[A-Z])', '_', field.path).lower()
    return field


def gen_primitive(p):
    defi, decl = "", ""
    org = p.name.name
    typename = typemap.get(p.typename, p.typename)
    normalize_varname(p)
    converter_name = converter_map.get(typename)
    if converter_name is not None:
        defi += f'    [<JsonConverter(typeof<{converter_name}>)>]\n'
    if p.required:
        defi += f'    [<JsonPropertyName("{org}")>]\n    {to_PascalCase(p.name.normalized())}: {typename}\n'
    else:
        defi += f'    [<JsonPropertyName("{org}")>]\n    [<JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)>]\n    {to_PascalCase(p.name.normalized())}: {typename} option\n'
    return defi, decl


def gen_enum(e):
    defi, decl = "", ""
    if e.path in overrides and overrides[e.path] is None:
        return "", ""
    if e.description != "":
        decl += f"/// {e.description}\n"

    decl += f'[<System.CodeDom.Compiler.GeneratedCode(\"{" ".join(sys.argv)}\", \"\")>]\n'
    decl += f"type {e.typename} =\n"

    for i, v in enumerate(e.variants):
        if v is None:
            continue
        name = v.normalized()
        decl += f'    | [<System.Runtime.Serialization.EnumMember(Value = "{v}")>] {name} = {i} \n'

    decl += "\n\n"

    typename = e.typename
    if e.path in overrides:
        decl = ""
        typename = overrides[e.path]

    if e.required:
        defi = f'    // Path `{e.path}`\n'
        defi += f'    [<JsonPropertyName("{e.name}")>]\n'
        defi += f'    [<JsonConverter(typeof<JsonStringEnumConverter>)>]\n'
        defi += f'    {to_PascalCase(e.name.normalized())}: {typename}\n'
    else:
        defi = f'    [<JsonPropertyName("{e.name}")>]\n'
        defi += f'    [<JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)>]\n'
        defi += f'    {to_PascalCase(e.name.normalized())}: {typename} option\n'
    return defi, decl


def gen_array(a: ArrayField):
    name = a.name.normalized().replace("[]", "")
    logger.debug(f"Generating array field {a.name} -> {name} ({a.path})")
    _, decl = gen_field(a.itemtype)

    if a.path in overrides:
        decl = ""
        itemtype = overrides[a.path]
    elif isinstance(a.itemtype, PrimitiveField):
        itemtype = a.itemtype.typename
    elif isinstance(a.itemtype, CompositeField):
        itemtype = a.itemtype.typename
    elif isinstance(a.itemtype, EnumField):
        itemtype = a.itemtype.typename

    if itemtype is None:
        return "", ""

    itemtype = typemap.get(itemtype, itemtype)
    alias = a.name.normalized()
    if a.required:
        defi = f'    [<JsonPropertyName("{alias}")>]\n    {to_PascalCase(name)}: {itemtype}{" []" * a.dims}\n'
    else:
        defi = f'    [<JsonPropertyName("{alias}")>]\n'
        defi += f"    [<JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)>]\n"
        defi += f"    {to_PascalCase(name)}: {itemtype}{' []' * a.dims} option\n"
    return defi, decl


def gen_field(field):
    if isinstance(field, CompositeField):
        return gen_composite(field)
    elif isinstance(field, EnumField):
        return gen_enum(field)
    elif isinstance(field, ArrayField):
        return gen_array(field)
    elif isinstance(field, PrimitiveField):
        return gen_primitive(field)
    else:
        raise ValueError(f"Unmanaged type {field}")


def gen_composite(c) -> Tuple[str, str]:
    logger.debug(f"Generating composite field {c.name} ({c.path})")
    fields = []
    for f in c.fields:
        fields.append(gen_field(f))
    r = "".join([f[1] for f in fields])
    if len(fields) == 0:
        r += f'type {c.typename} = unit\n'
    else:
        r += f'[<System.CodeDom.Compiler.GeneratedCode(\"{" ".join(sys.argv)}\", \"\")>]\n'
        r += '[<CLIMutable>]\n'
        r += f"type {c.typename} ="
        r += " {\n"
        r += "".join([f[0] for f in fields])
        r += "}\n"
    r += "\n"
    return ("", r)


class FSharpGenerator:
    def __init__(self, dest: TextIO):
        self.dest = dest

    def write(self, text: str, numindent: int = 0) -> None:
        raw = dedent(text)
        if numindent > 0:
            raw = indent(text, "    " * numindent)
        self.dest.write(raw)

    def generate_requests(self, service: Service):
        """"""

        self.write(f'[<System.CodeDom.Compiler.GeneratedCode(\"{" ".join(sys.argv)}\", \"\")>]\n')
        self.write("module Requests =\n")

        for method in service.methods:
            _, decl = gen_composite(method.request)
            self.write(decl, numindent=1)

        self.write("\n\n")

    def generate_responses(self, service: Service):
        self.write(f'[<System.CodeDom.Compiler.GeneratedCode(\"{" ".join(sys.argv)}\", \"\")>]\n')
        self.write("module Responses = \n")
        for method in service.methods:
            _, decl = gen_composite(method.response)
            self.write(decl, numindent=1)

        self.write("\n\n")

    def generate_enums(self, service: Service):
        """The reqeust and Response enums serve as parsing primitives.
        """
        self.write(f"""
        [<System.CodeDom.Compiler.GeneratedCode("{" ".join(sys.argv)}", "")>]
        type internal Request =
        """)

        for method in service.methods:
            self.write(f"| {method.name} of Requests.{method.request.typename}\n", numindent=1)
        self.write(f"with\n", numindent=2)
        self.write(f"member this.MethodName =\n", numindent=2)
        self.write(f"match this with\n", numindent=3)
        for method in service.methods:
            self.write(f"| {method.name} _ -> \"{method.name.lower()}\"\n", numindent=3)

        self.write(f"member this.Data =\n", numindent=2)
        self.write(f"match this with\n", numindent=3)
        for method in service.methods:
            self.write(f"| {method.name} x -> x |> box\n", numindent=3)

        self.write("\n")

        self.write(f"""
        [<System.CodeDom.Compiler.GeneratedCode("{" ".join(sys.argv)}", "")>]
        type private Response =
        """)

        for method in service.methods:
            self.write(f"| {method.name} of Responses.{method.response.typename}\n", numindent=1)
        self.write("\n")

    def write_header(self):
        self.write(header)
        opens = """
open System.Text.Json
open System.Text.Json.Serialization

"""
        self.write(opens)

    def generate(self, service: Service):
        self.write_header()
        self.generate_requests(service)
        self.generate_responses(service)
        self.generate_enums(service)


class FSharpClientExtensionGenerator:
    def __init__(self, dest: TextIO):
        self.dest = dest

    def write(self, text: str, numindent: int = 0) -> None:
        raw = dedent(text)
        if numindent > 0:
            raw = indent(text, "    " * numindent)
        self.dest.write(raw)

    def generate_methods(self, service: Service):
        self.write(f"""

[<System.CodeDom.Compiler.GeneratedCode("{" ".join(sys.argv)}", "")>]
[<Extension;AbstractClass;Sealed>]
type ClnClientExtensions =
""")

        for method in service.methods:
            req_fields = []
            resp_fields = []
            for f in method.request.fields:
                req_fields.append(gen_field(f))
            for f in method.response.fields:
                resp_fields.append(gen_field(f))
            self.write("[<Extension>]\n", numindent=1)
            if len(req_fields) == 0:
                self.write(
                    f"static member {method.name}Async(this: ClnClient, [<Optional;DefaultParameterValue(CancellationToken())>] ct: CancellationToken) =\n",
                    numindent=1)
                if len(resp_fields) == 0:
                    self.write(f"this.SendCommandAsync(\"{method.name.lower()}\", null, ct=ct) :> Task\n", numindent=2)
                else:
                    self.write(
                        f"this.SendCommandAsync<Responses.{method.response.typename}>(\"{method.name.lower()}\", null, ct=ct)\n",
                        numindent=2)
            else:
                self.write(
                    f"static member {method.name}Async(this: ClnClient, req: Requests.{method.request.typename}, [<Optional;DefaultParameterValue(CancellationToken())>] ct: CancellationToken) =\n",
                    numindent=1)
                if len(resp_fields) == 0:
                    self.write(f"this.SendCommandAsync(Request.{method.name} req, ct=ct) :> Task\n", numindent=2)
                else:
                    self.write(
                        f"this.SendCommandAsync<Responses.{method.response.typename}>(Request.{method.name} req, ct=ct)\n",
                        numindent=2)

    def write_header(self):
        self.write(header)
        opens = """
open System.Runtime.InteropServices
open System.Runtime.CompilerServices
open System.Threading
open System.Threading.Tasks

"""
        self.write(opens)

    def generate(self, service: Service):
        self.write_header()
        self.generate_methods(service)
