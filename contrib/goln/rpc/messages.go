package rpc

import (
	"encoding/json"
	"fmt"
)

//! This file was automatically generated using the following command:
//!
//! ```bash
//! contrib/msggen/msggen/__main__.py
//! ```
//!
//! Do not edit this file, it'll be overwritten. Rather edit the schema that
//! this file was generated from

type GetinfoRequest struct{
}

type ListpeersRequest struct{
	// Optional field: If supplied, limits the result to just the peer with the given ID, if it exists..
	Id string `json:"id"`
	// Optional field: Supplying level will show log entries related to that peer at the given log level. Valid log levels are “io”, “debug”, “info”, and “unusual”..
	Level string `json:"level"`
}

type ListfundsRequest struct{
	// Optional field: Should outputs that are already spent be included in the result?.
	Spent bool `json:"spent"`
}

type SendpayRoute struct{
	// Required field.
	AmountMsat Amount `json:"amount_msat"`
	// Required field.
	Id string `json:"id"`
	// Required field.
	Delay uint16 `json:"delay"`
	// Required field.
	Channel ShortChannelId `json:"channel"`
}

type SendpayRequest struct{
	// Required field.
	Route []SendpayRoute `json:"route"`
	// Required field.
	PaymentHash string `json:"payment_hash"`
	// Optional field.
	Label string `json:"label"`
	// Optional field.
	AmountMsat Amount `json:"amount_msat"`
	// Optional field.
	Bolt11 string `json:"bolt11"`
	// Optional field.
	PaymentSecret string `json:"payment_secret"`
	// Optional field.
	Partid uint16 `json:"partid"`
	// Optional field.
	Localinvreqid string `json:"localinvreqid"`
	// Optional field.
	Groupid uint64 `json:"groupid"`
}

type ListchannelsRequest struct{
	// Optional field: If short_channel_id is a short channel id, then only known channels with a matching short_channel_id are returned. Otherwise, it must be null..
	ShortChannelId ShortChannelId `json:"short_channel_id"`
	// Optional field: If source is a node id, then only channels leading from that node id are returned..
	Source string `json:"source"`
	// Optional field: If destination is a node id, then only channels leading to that node id are returned..
	Destination string `json:"destination"`
}

type AddgossipRequest struct{
	// Required field: The raw, hex-encoded, gossip message to add to the local gossip view..
	Message string `json:"message"`
}

type AutocleaninvoiceRequest struct{
	// Optional field: How long an invoice must be expired (seconds) before we delete it..
	ExpiredBy uint64 `json:"expired_by"`
	// Optional field: The interval (in seconds) between cleaning expired invoices.
	CycleSeconds uint64 `json:"cycle_seconds"`
}

type CheckmessageRequest struct{
	// Required field: Message to be checked against the signature..
	Message string `json:"message"`
	// Required field: The Zbase32 encoded signature to verify..
	Zbase string `json:"zbase"`
	// Optional field: The Zbase32 encoded signature to verify..
	Pubkey string `json:"pubkey"`
}

type CloseRequest struct{
	// Required field: peer id, channel id or short_channel_id.
	Id string `json:"id"`
	// Optional field.
	Unilateraltimeout uint32 `json:"unilateraltimeout"`
	// Optional field.
	Destination string `json:"destination"`
	// Optional field.
	FeeNegotiationStep string `json:"fee_negotiation_step"`
	// Optional field.
	WrongFunding string `json:"wrong_funding"`
	// Optional field.
	ForceLeaseClosed bool `json:"force_lease_closed"`
	// Optional field.
	Feerange []FeeRate `json:"feerange"`
}

type ConnectRequest struct{
	// Required field.
	Id string `json:"id"`
	// Optional field: The hostname of the node..
	Host string `json:"host"`
	// Optional field: Port to try connecting to.
	Port uint16 `json:"port"`
}

type CreateinvoiceRequest struct{
	// Required field.
	Invstring string `json:"invstring"`
	// Required field.
	Label string `json:"label"`
	// Required field.
	Preimage string `json:"preimage"`
}

// DatastoreMode
type DatastoreMode int

const (
	DatastoreMode_MustCreate DatastoreMode = iota
	DatastoreMode_MustReplace
	DatastoreMode_CreateOrReplace
	DatastoreMode_MustAppend
	DatastoreMode_CreateOrAppend
)

func (s DatastoreMode) String() (string, error) {
	switch s {
	case DatastoreMode_MustCreate:
		return "must-create", nil
	case DatastoreMode_MustReplace:
		return "must-replace", nil
	case DatastoreMode_CreateOrReplace:
		return "create-or-replace", nil
	case DatastoreMode_MustAppend:
		return "must-append", nil
	case DatastoreMode_CreateOrAppend:
		return "create-or-append", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *DatastoreMode) FromString(p string) error {
	switch p {
	case "must-create":
		*s = DatastoreMode_MustCreate
	case "must-replace":
		*s = DatastoreMode_MustReplace
	case "create-or-replace":
		*s = DatastoreMode_CreateOrReplace
	case "must-append":
		*s = DatastoreMode_MustAppend
	case "create-or-append":
		*s = DatastoreMode_CreateOrAppend
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s DatastoreMode) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *DatastoreMode) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type DatastoreRequest struct{
	// Required field.
	Key []string `json:"key"`
	// Optional field.
	String string `json:"string"`
	// Optional field.
	Hex string `json:"hex"`
	// Optional field
	Mode DatastoreMode `json:"mode"`
	// Optional field: If specified, means that the update will fail if the previously-existing data is not exactly that generation. This allows for simple atomicity. This is only legal with mode “must-replace” or “must-append”..
	Generation uint64 `json:"generation"`
}

type CreateonionHops struct{
	// Required field.
	Pubkey string `json:"pubkey"`
	// Required field.
	Payload string `json:"payload"`
}

type CreateonionRequest struct{
	// Required field.
	Hops []CreateonionHops `json:"hops"`
	// Required field.
	Assocdata string `json:"assocdata"`
	// Optional field.
	SessionKey string `json:"session_key"`
	// Optional field.
	OnionSize uint16 `json:"onion_size"`
}

type DeldatastoreRequest struct{
	// Required field.
	Key []string `json:"key"`
	// Optional field: If specified, means that the update will fail if the previously-existing data is not exactly that generation. This allows for simple atomicity. This is only legal with mode “must-replace” or “must-append”..
	Generation uint64 `json:"generation"`
}

type DelexpiredinvoiceRequest struct{
	// Optional field.
	Maxexpirytime uint64 `json:"maxexpirytime"`
}

// DelinvoiceStatus
type DelinvoiceStatus int

const (
	DelinvoiceStatus_Paid DelinvoiceStatus = iota
	DelinvoiceStatus_Expired
	DelinvoiceStatus_Unpaid
)

func (s DelinvoiceStatus) String() (string, error) {
	switch s {
	case DelinvoiceStatus_Paid:
		return "paid", nil
	case DelinvoiceStatus_Expired:
		return "expired", nil
	case DelinvoiceStatus_Unpaid:
		return "unpaid", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *DelinvoiceStatus) FromString(p string) error {
	switch p {
	case "paid":
		*s = DelinvoiceStatus_Paid
	case "expired":
		*s = DelinvoiceStatus_Expired
	case "unpaid":
		*s = DelinvoiceStatus_Unpaid
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s DelinvoiceStatus) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *DelinvoiceStatus) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type DelinvoiceRequest struct{
	// Required field.
	Label string `json:"label"`
	// Required field
	Status DelinvoiceStatus `json:"status"`
	// Optional field.
	Desconly bool `json:"desconly"`
}

type InvoiceRequest struct{
	// Required field.
	AmountMsat AmountOrAny `json:"amount_msat"`
	// Required field.
	Description string `json:"description"`
	// Required field.
	Label string `json:"label"`
	// Optional field.
	Expiry uint64 `json:"expiry"`
	// Optional field.
	Fallbacks []string `json:"fallbacks"`
	// Optional field.
	Preimage string `json:"preimage"`
	// Optional field.
	Exposeprivatechannels bool `json:"exposeprivatechannels"`
	// Optional field.
	Cltv uint32 `json:"cltv"`
	// Optional field.
	Deschashonly bool `json:"deschashonly"`
}

type ListdatastoreRequest struct{
	// Optional field.
	Key []string `json:"key"`
}

type ListinvoicesRequest struct{
	// Optional field.
	Label string `json:"label"`
	// Optional field.
	Invstring string `json:"invstring"`
	// Optional field.
	PaymentHash string `json:"payment_hash"`
	// Optional field.
	OfferId string `json:"offer_id"`
}

type SendonionFirst_hop struct{
	// Required field.
	Id string `json:"id"`
	// Required field.
	AmountMsat Amount `json:"amount_msat"`
	// Required field.
	Delay uint16 `json:"delay"`
}

type SendonionRequest struct{
	// Required field.
	Onion string `json:"onion"`
	// Required field
	FirstHop SendonionFirst_hop `json:"first_hop"`
	// Required field.
	PaymentHash string `json:"payment_hash"`
	// Optional field.
	Label string `json:"label"`
	// Optional field.
	SharedSecrets []string `json:"shared_secrets"`
	// Optional field.
	Partid uint16 `json:"partid"`
	// Optional field.
	Bolt11 string `json:"bolt11"`
	// Optional field.
	AmountMsat Amount `json:"amount_msat"`
	// Optional field.
	Destination string `json:"destination"`
	// Optional field.
	Localinvreqid string `json:"localinvreqid"`
	// Optional field.
	Groupid uint64 `json:"groupid"`
}

// PayStatus
type PayStatus int

const (
	PayStatus_Pending PayStatus = iota
	PayStatus_Complete
	PayStatus_Failed
)

func (s PayStatus) String() (string, error) {
	switch s {
	case PayStatus_Pending:
		return "pending", nil
	case PayStatus_Complete:
		return "complete", nil
	case PayStatus_Failed:
		return "failed", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *PayStatus) FromString(p string) error {
	switch p {
	case "pending":
		*s = PayStatus_Pending
	case "complete":
		*s = PayStatus_Complete
	case "failed":
		*s = PayStatus_Failed
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s PayStatus) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *PayStatus) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type ListsendpaysRequest struct{
	// Optional field.
	Bolt11 string `json:"bolt11"`
	// Optional field.
	PaymentHash string `json:"payment_hash"`
	// Optional field
	Status PayStatus `json:"status"`
}

type ListtransactionsRequest struct{
}

type PayRequest struct{
	// Required field.
	Bolt11 string `json:"bolt11"`
	// Optional field.
	AmountMsat Amount `json:"amount_msat"`
	// Optional field.
	Label string `json:"label"`
	// Optional field.
	Riskfactor float64 `json:"riskfactor"`
	// Optional field.
	Maxfeepercent float64 `json:"maxfeepercent"`
	// Optional field.
	RetryFor uint16 `json:"retry_for"`
	// Optional field.
	Maxdelay uint16 `json:"maxdelay"`
	// Optional field.
	Exemptfee Amount `json:"exemptfee"`
	// Optional field.
	Localinvreqid string `json:"localinvreqid"`
	// Optional field.
	Exclude []string `json:"exclude"`
	// Optional field.
	Maxfee Amount `json:"maxfee"`
	// Optional field.
	Description string `json:"description"`
}

type ListnodesRequest struct{
	// Optional field.
	Id string `json:"id"`
}

type WaitanyinvoiceRequest struct{
	// Optional field.
	LastpayIndex uint64 `json:"lastpay_index"`
	// Optional field.
	Timeout uint64 `json:"timeout"`
}

type WaitinvoiceRequest struct{
	// Required field.
	Label string `json:"label"`
}

type WaitsendpayRequest struct{
	// Required field.
	PaymentHash string `json:"payment_hash"`
	// Optional field.
	Timeout uint32 `json:"timeout"`
	// Optional field.
	Partid uint64 `json:"partid"`
	// Optional field.
	Groupid uint64 `json:"groupid"`
}

// NewaddrAddresstype
type NewaddrAddresstype int

const (
	NewaddrAddresstype_Bech32 NewaddrAddresstype = iota
	NewaddrAddresstype_All
)

func (s NewaddrAddresstype) String() (string, error) {
	switch s {
	case NewaddrAddresstype_Bech32:
		return "bech32", nil
	case NewaddrAddresstype_All:
		return "all", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *NewaddrAddresstype) FromString(p string) error {
	switch p {
	case "bech32":
		*s = NewaddrAddresstype_Bech32
	case "all":
		*s = NewaddrAddresstype_All
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s NewaddrAddresstype) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *NewaddrAddresstype) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type NewaddrRequest struct{
	// Optional field
	Addresstype NewaddrAddresstype `json:"addresstype"`
}

type WithdrawRequest struct{
	// Required field.
	Destination string `json:"destination"`
	// Optional field.
	Satoshi AmountOrAll `json:"satoshi"`
	// Optional field.
	Feerate FeeRate `json:"feerate"`
	// Optional field.
	Minconf uint16 `json:"minconf"`
	// Optional field.
	Utxos []string `json:"utxos"`
}

type KeysendRequest struct{
	// Required field.
	Destination string `json:"destination"`
	// Required field.
	AmountMsat Amount `json:"amount_msat"`
	// Optional field.
	Label string `json:"label"`
	// Optional field.
	Maxfeepercent float64 `json:"maxfeepercent"`
	// Optional field.
	RetryFor uint32 `json:"retry_for"`
	// Optional field.
	Maxdelay uint32 `json:"maxdelay"`
	// Optional field.
	Exemptfee Amount `json:"exemptfee"`
	// Optional field.
	Routehints RoutehintList `json:"routehints"`
	// Optional field.
	Extratlvs TlvStream `json:"extratlvs"`
}

type FundpsbtRequest struct{
	// Required field.
	Satoshi AmountOrAll `json:"satoshi"`
	// Required field.
	Feerate FeeRate `json:"feerate"`
	// Required field.
	Startweight uint32 `json:"startweight"`
	// Optional field.
	Minconf uint32 `json:"minconf"`
	// Optional field: reserve is a number: if non-zero number then reserveinputs is called (successfully, with exclusive true) on the returned PSBT for this number of blocks (default: 72)..
	Reserve uint32 `json:"reserve"`
	// Optional field.
	Locktime uint32 `json:"locktime"`
	// Optional field.
	MinWitnessWeight uint32 `json:"min_witness_weight"`
	// Optional field.
	ExcessAsChange bool `json:"excess_as_change"`
}

type SendpsbtRequest struct{
	// Required field.
	Psbt string `json:"psbt"`
	// Optional field.
	Reserve bool `json:"reserve"`
}

type SignpsbtRequest struct{
	// Required field.
	Psbt string `json:"psbt"`
	// Optional field.
	Signonly []uint32 `json:"signonly"`
}

type UtxopsbtRequest struct{
	// Required field.
	Satoshi Amount `json:"satoshi"`
	// Required field.
	Feerate FeeRate `json:"feerate"`
	// Required field.
	Startweight uint32 `json:"startweight"`
	// Required field.
	Utxos []string `json:"utxos"`
	// Optional field: reserve is a number: if non-zero number then reserveinputs is called (successfully, with exclusive true) on the returned PSBT for this number of blocks (default: 72)..
	Reserve uint32 `json:"reserve"`
	// Optional field.
	Reservedok bool `json:"reservedok"`
	// Optional field.
	Locktime uint32 `json:"locktime"`
	// Optional field.
	MinWitnessWeight uint32 `json:"min_witness_weight"`
	// Optional field.
	ExcessAsChange bool `json:"excess_as_change"`
}

type TxdiscardRequest struct{
	// Required field.
	Txid string `json:"txid"`
}

type TxprepareRequest struct{
	// Required field.
	Outputs []string `json:"outputs"`
	// Optional field.
	Feerate FeeRate `json:"feerate"`
	// Optional field.
	Minconf uint32 `json:"minconf"`
	// Optional field.
	Utxos []string `json:"utxos"`
}

type TxsendRequest struct{
	// Required field.
	Txid string `json:"txid"`
}

type DisconnectRequest struct{
	// Required field.
	Id string `json:"id"`
	// Optional field.
	Force bool `json:"force"`
}

// FeeratesStyle
type FeeratesStyle int

const (
	FeeratesStyle_Perkb FeeratesStyle = iota
	FeeratesStyle_Perkw
)

func (s FeeratesStyle) String() (string, error) {
	switch s {
	case FeeratesStyle_Perkb:
		return "perkb", nil
	case FeeratesStyle_Perkw:
		return "perkw", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *FeeratesStyle) FromString(p string) error {
	switch p {
	case "perkb":
		*s = FeeratesStyle_Perkb
	case "perkw":
		*s = FeeratesStyle_Perkw
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s FeeratesStyle) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *FeeratesStyle) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type FeeratesRequest struct{
	// Required field
	Style FeeratesStyle `json:"style"`
}

type FundchannelRequest struct{
	// Required field: id is the peer id obtained from connect..
	Id string `json:"id"`
	// Required field.
	Amount AmountOrAll `json:"amount"`
	// Optional field.
	Feerate FeeRate `json:"feerate"`
	// Optional field.
	Announce bool `json:"announce"`
	// Optional field.
	Minconf uint32 `json:"minconf"`
	// Optional field.
	PushMsat Amount `json:"push_msat"`
	// Optional field.
	CloseTo string `json:"close_to"`
	// Optional field.
	RequestAmt Amount `json:"request_amt"`
	// Optional field.
	CompactLease string `json:"compact_lease"`
	// Optional field.
	Utxos []string `json:"utxos"`
	// Optional field: Number of confirmations required before we consider the channel active.
	Mindepth uint32 `json:"mindepth"`
	// Optional field: The amount we want the peer to maintain on its side.
	Reserve Amount `json:"reserve"`
}

type GetrouteRequest struct{
	// Required field.
	Id string `json:"id"`
	// Required field.
	AmountMsat Amount `json:"amount_msat"`
	// Required field.
	Riskfactor uint64 `json:"riskfactor"`
	// Optional field.
	Cltv float64 `json:"cltv"`
	// Optional field.
	Fromid string `json:"fromid"`
	// Optional field.
	Fuzzpercent uint32 `json:"fuzzpercent"`
	// Optional field.
	Exclude []string `json:"exclude"`
	// Optional field.
	Maxhops uint32 `json:"maxhops"`
}

// ListforwardsStatus
type ListforwardsStatus int

const (
	ListforwardsStatus_Offered ListforwardsStatus = iota
	ListforwardsStatus_Settled
	ListforwardsStatus_LocalFailed
	ListforwardsStatus_Failed
)

func (s ListforwardsStatus) String() (string, error) {
	switch s {
	case ListforwardsStatus_Offered:
		return "offered", nil
	case ListforwardsStatus_Settled:
		return "settled", nil
	case ListforwardsStatus_LocalFailed:
		return "local_failed", nil
	case ListforwardsStatus_Failed:
		return "failed", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *ListforwardsStatus) FromString(p string) error {
	switch p {
	case "offered":
		*s = ListforwardsStatus_Offered
	case "settled":
		*s = ListforwardsStatus_Settled
	case "local_failed":
		*s = ListforwardsStatus_LocalFailed
	case "failed":
		*s = ListforwardsStatus_Failed
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s ListforwardsStatus) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *ListforwardsStatus) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type ListforwardsRequest struct{
	// Optional field
	Status ListforwardsStatus `json:"status"`
	// Optional field.
	InChannel ShortChannelId `json:"in_channel"`
	// Optional field.
	OutChannel ShortChannelId `json:"out_channel"`
}

type ListpaysRequest struct{
	// Optional field.
	Bolt11 string `json:"bolt11"`
	// Optional field.
	PaymentHash string `json:"payment_hash"`
	// Optional field
	Status PayStatus `json:"status"`
}

type PingRequest struct{
	// Required field.
	Id string `json:"id"`
	// Optional field.
	Len uint16 `json:"len"`
	// Optional field.
	Pongbytes uint16 `json:"pongbytes"`
}

type SendcustommsgRequest struct{
	// Required field.
	NodeId string `json:"node_id"`
	// Required field.
	Msg string `json:"msg"`
}

type SetchannelRequest struct{
	// Required field.
	Id string `json:"id"`
	// Optional field.
	Feebase Amount `json:"feebase"`
	// Optional field.
	Feeppm uint32 `json:"feeppm"`
	// Optional field.
	Htlcmin Amount `json:"htlcmin"`
	// Optional field.
	Htlcmax Amount `json:"htlcmax"`
	// Optional field.
	Enforcedelay uint32 `json:"enforcedelay"`
}

type SigninvoiceRequest struct{
	// Required field.
	Invstring string `json:"invstring"`
}

type SignmessageRequest struct{
	// Required field.
	Message string `json:"message"`
}

type StopRequest struct{
}

type GetinfoOur_features struct{
	// Required field: features (incl. globalfeatures) in our init message, these also restrict what we offer in open_channel or accept in accept_channel.
	Init string `json:"init"`
	// Required field: features in our node_announcement message.
	Node string `json:"node"`
	// Required field: negotiated channel features we (as channel initiator) publish in the channel_announcement message.
	Channel string `json:"channel"`
	// Required field: features in our BOLT11 invoices.
	Invoice string `json:"invoice"`
}

// GetinfoAddressType, Type of connection.
type GetinfoAddressType int

const (
	GetinfoAddressType_Dns GetinfoAddressType = iota
	GetinfoAddressType_Ipv4
	GetinfoAddressType_Ipv6
	GetinfoAddressType_Torv2
	GetinfoAddressType_Torv3
	GetinfoAddressType_Websocket
)

func (s GetinfoAddressType) String() (string, error) {
	switch s {
	case GetinfoAddressType_Dns:
		return "dns", nil
	case GetinfoAddressType_Ipv4:
		return "ipv4", nil
	case GetinfoAddressType_Ipv6:
		return "ipv6", nil
	case GetinfoAddressType_Torv2:
		return "torv2", nil
	case GetinfoAddressType_Torv3:
		return "torv3", nil
	case GetinfoAddressType_Websocket:
		return "websocket", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *GetinfoAddressType) FromString(p string) error {
	switch p {
	case "dns":
		*s = GetinfoAddressType_Dns
	case "ipv4":
		*s = GetinfoAddressType_Ipv4
	case "ipv6":
		*s = GetinfoAddressType_Ipv6
	case "torv2":
		*s = GetinfoAddressType_Torv2
	case "torv3":
		*s = GetinfoAddressType_Torv3
	case "websocket":
		*s = GetinfoAddressType_Websocket
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s GetinfoAddressType) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *GetinfoAddressType) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type GetinfoAddress struct{
	// Required field
	ItemType GetinfoAddressType `json:"type"`
	// Required field: port number.
	Port uint16 `json:"port"`
	// Optional field: address in expected format for **type**.
	Address string `json:"address"`
}

// GetinfoBindingType, Type of connection.
type GetinfoBindingType int

const (
	GetinfoBindingType_LocalSocket GetinfoBindingType = iota
	GetinfoBindingType_Ipv4
	GetinfoBindingType_Ipv6
	GetinfoBindingType_Torv2
	GetinfoBindingType_Torv3
)

func (s GetinfoBindingType) String() (string, error) {
	switch s {
	case GetinfoBindingType_LocalSocket:
		return "local socket", nil
	case GetinfoBindingType_Ipv4:
		return "ipv4", nil
	case GetinfoBindingType_Ipv6:
		return "ipv6", nil
	case GetinfoBindingType_Torv2:
		return "torv2", nil
	case GetinfoBindingType_Torv3:
		return "torv3", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *GetinfoBindingType) FromString(p string) error {
	switch p {
	case "local socket":
		*s = GetinfoBindingType_LocalSocket
	case "ipv4":
		*s = GetinfoBindingType_Ipv4
	case "ipv6":
		*s = GetinfoBindingType_Ipv6
	case "torv2":
		*s = GetinfoBindingType_Torv2
	case "torv3":
		*s = GetinfoBindingType_Torv3
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s GetinfoBindingType) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *GetinfoBindingType) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type GetinfoBinding struct{
	// Required field
	ItemType GetinfoBindingType `json:"type"`
	// Optional field: address in expected format for **type**.
	Address string `json:"address"`
	// Optional field: port number.
	Port uint16 `json:"port"`
	// Optional field: socket filename (only if **type** is "local socket").
	Socket string `json:"socket"`
}

type GetinfoResponse struct{
	// Required field: The public key unique to this node.
	Id string `json:"id"`
	// Required field: The fun alias this node will advertize.
	Alias string `json:"alias"`
	// Required field: The favorite RGB color this node will advertize.
	Color string `json:"color"`
	// Required field: The total count of peers, connected or with channels.
	NumPeers uint32 `json:"num_peers"`
	// Required field: The total count of channels being opened.
	NumPendingChannels uint32 `json:"num_pending_channels"`
	// Required field: The total count of channels in normal state.
	NumActiveChannels uint32 `json:"num_active_channels"`
	// Required field: The total count of channels waiting for opening or closing transactions to be mined.
	NumInactiveChannels uint32 `json:"num_inactive_channels"`
	// Required field: Identifies what bugs you are running into.
	Version string `json:"version"`
	// Required field: Identifies where you can find the configuration and other related files.
	LightningDir string `json:"lightning_dir"`
	// Optional field
	OurFeatures GetinfoOur_features `json:"our_features"`
	// Required field: The highest block height we've learned.
	Blockheight uint32 `json:"blockheight"`
	// Required field: represents the type of network on the node are working (e.g: `bitcoin`, `testnet`, or `regtest`).
	Network string `json:"network"`
	// Required field: Total routing fees collected by this node.
	FeesCollectedMsat Amount `json:"fees_collected_msat"`
	// Required field: The addresses we announce to the world.
	Address []GetinfoAddress `json:"address"`
	// Optional field: The addresses we are listening on.
	Binding []GetinfoBinding `json:"binding"`
	// Optional field: Bitcoind is not up-to-date with network..
	WarningBitcoindSync string `json:"warning_bitcoind_sync"`
	// Optional field: Lightningd is still loading latest blocks from bitcoind..
	WarningLightningdSync string `json:"warning_lightningd_sync"`
}

// ListpeersPeersLogType
type ListpeersPeersLogType int

const (
	ListpeersPeersLogType_Skipped ListpeersPeersLogType = iota
	ListpeersPeersLogType_Broken
	ListpeersPeersLogType_Unusual
	ListpeersPeersLogType_Info
	ListpeersPeersLogType_Debug
	ListpeersPeersLogType_IoIn
	ListpeersPeersLogType_IoOut
)

func (s ListpeersPeersLogType) String() (string, error) {
	switch s {
	case ListpeersPeersLogType_Skipped:
		return "SKIPPED", nil
	case ListpeersPeersLogType_Broken:
		return "BROKEN", nil
	case ListpeersPeersLogType_Unusual:
		return "UNUSUAL", nil
	case ListpeersPeersLogType_Info:
		return "INFO", nil
	case ListpeersPeersLogType_Debug:
		return "DEBUG", nil
	case ListpeersPeersLogType_IoIn:
		return "IO_IN", nil
	case ListpeersPeersLogType_IoOut:
		return "IO_OUT", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *ListpeersPeersLogType) FromString(p string) error {
	switch p {
	case "SKIPPED":
		*s = ListpeersPeersLogType_Skipped
	case "BROKEN":
		*s = ListpeersPeersLogType_Broken
	case "UNUSUAL":
		*s = ListpeersPeersLogType_Unusual
	case "INFO":
		*s = ListpeersPeersLogType_Info
	case "DEBUG":
		*s = ListpeersPeersLogType_Debug
	case "IO_IN":
		*s = ListpeersPeersLogType_IoIn
	case "IO_OUT":
		*s = ListpeersPeersLogType_IoOut
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s ListpeersPeersLogType) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *ListpeersPeersLogType) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type ListpeersPeersLog struct{
	// Required field
	ItemType ListpeersPeersLogType `json:"type"`
	// Optional field: number of deleted/omitted entries.
	NumSkipped uint32 `json:"num_skipped"`
	// Optional field: UNIX timestamp with 9 decimal places.
	Time string `json:"time"`
	// Optional field: The particular logbook this was found in.
	Source string `json:"source"`
	// Optional field: The actual log message.
	Log string `json:"log"`
	// Optional field: The peer this is associated with.
	NodeId string `json:"node_id"`
	// Optional field: The IO which occurred.
	Data string `json:"data"`
}

// ListpeersPeersChannelsState, the channel state, in particular "CHANNELD_NORMAL" means the channel can be used normally.
type ListpeersPeersChannelsState int

const (
	ListpeersPeersChannelsState_Openingd ListpeersPeersChannelsState = iota
	ListpeersPeersChannelsState_ChanneldAwaitingLockin
	ListpeersPeersChannelsState_ChanneldNormal
	ListpeersPeersChannelsState_ChanneldShuttingDown
	ListpeersPeersChannelsState_ClosingdSigexchange
	ListpeersPeersChannelsState_ClosingdComplete
	ListpeersPeersChannelsState_AwaitingUnilateral
	ListpeersPeersChannelsState_FundingSpendSeen
	ListpeersPeersChannelsState_Onchain
	ListpeersPeersChannelsState_DualopendOpenInit
	ListpeersPeersChannelsState_DualopendAwaitingLockin
)

func (s ListpeersPeersChannelsState) String() (string, error) {
	switch s {
	case ListpeersPeersChannelsState_Openingd:
		return "OPENINGD", nil
	case ListpeersPeersChannelsState_ChanneldAwaitingLockin:
		return "CHANNELD_AWAITING_LOCKIN", nil
	case ListpeersPeersChannelsState_ChanneldNormal:
		return "CHANNELD_NORMAL", nil
	case ListpeersPeersChannelsState_ChanneldShuttingDown:
		return "CHANNELD_SHUTTING_DOWN", nil
	case ListpeersPeersChannelsState_ClosingdSigexchange:
		return "CLOSINGD_SIGEXCHANGE", nil
	case ListpeersPeersChannelsState_ClosingdComplete:
		return "CLOSINGD_COMPLETE", nil
	case ListpeersPeersChannelsState_AwaitingUnilateral:
		return "AWAITING_UNILATERAL", nil
	case ListpeersPeersChannelsState_FundingSpendSeen:
		return "FUNDING_SPEND_SEEN", nil
	case ListpeersPeersChannelsState_Onchain:
		return "ONCHAIN", nil
	case ListpeersPeersChannelsState_DualopendOpenInit:
		return "DUALOPEND_OPEN_INIT", nil
	case ListpeersPeersChannelsState_DualopendAwaitingLockin:
		return "DUALOPEND_AWAITING_LOCKIN", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *ListpeersPeersChannelsState) FromString(p string) error {
	switch p {
	case "OPENINGD":
		*s = ListpeersPeersChannelsState_Openingd
	case "CHANNELD_AWAITING_LOCKIN":
		*s = ListpeersPeersChannelsState_ChanneldAwaitingLockin
	case "CHANNELD_NORMAL":
		*s = ListpeersPeersChannelsState_ChanneldNormal
	case "CHANNELD_SHUTTING_DOWN":
		*s = ListpeersPeersChannelsState_ChanneldShuttingDown
	case "CLOSINGD_SIGEXCHANGE":
		*s = ListpeersPeersChannelsState_ClosingdSigexchange
	case "CLOSINGD_COMPLETE":
		*s = ListpeersPeersChannelsState_ClosingdComplete
	case "AWAITING_UNILATERAL":
		*s = ListpeersPeersChannelsState_AwaitingUnilateral
	case "FUNDING_SPEND_SEEN":
		*s = ListpeersPeersChannelsState_FundingSpendSeen
	case "ONCHAIN":
		*s = ListpeersPeersChannelsState_Onchain
	case "DUALOPEND_OPEN_INIT":
		*s = ListpeersPeersChannelsState_DualopendOpenInit
	case "DUALOPEND_AWAITING_LOCKIN":
		*s = ListpeersPeersChannelsState_DualopendAwaitingLockin
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s ListpeersPeersChannelsState) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *ListpeersPeersChannelsState) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type ListpeersPeersChannelsFeerate struct{
	// Required field: Feerate per 1000 weight (i.e kSipa).
	Perkw uint32 `json:"perkw"`
	// Required field: Feerate per 1000 virtual bytes.
	Perkb uint32 `json:"perkb"`
}

type ListpeersPeersChannelsInflight struct{
	// Required field: ID of the funding transaction.
	FundingTxid string `json:"funding_txid"`
	// Required field: The 0-based output number of the funding transaction which opens the channel.
	FundingOutnum uint32 `json:"funding_outnum"`
	// Required field: The feerate for this funding transaction in per-1000-weight, with "kpw" appended.
	Feerate string `json:"feerate"`
	// Required field: total amount in the channel.
	TotalFundingMsat Amount `json:"total_funding_msat"`
	// Required field: amount we have in the channel.
	OurFundingMsat Amount `json:"our_funding_msat"`
	// Required field: The commitment transaction txid we would use if we went onchain now.
	ScratchTxid string `json:"scratch_txid"`
}

// ChannelSide, Who initiated the channel.
type ChannelSide int

const (
	ChannelSide_Local ChannelSide = iota
	ChannelSide_Remote
)

func (s ChannelSide) String() (string, error) {
	switch s {
	case ChannelSide_Local:
		return "local", nil
	case ChannelSide_Remote:
		return "remote", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *ChannelSide) FromString(p string) error {
	switch p {
	case "local":
		*s = ChannelSide_Local
	case "remote":
		*s = ChannelSide_Remote
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s ChannelSide) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *ChannelSide) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type ListpeersPeersChannelsFunding struct{
	// Optional field: Amount pushed from opener to peer.
	PushedMsat Amount `json:"pushed_msat"`
	// Required field: Amount of channel we funded.
	LocalFundsMsat Amount `json:"local_funds_msat"`
	// Required field: Amount of channel they funded.
	RemoteFundsMsat Amount `json:"remote_funds_msat"`
	// Optional field: Amount we paid peer at open.
	FeePaidMsat Amount `json:"fee_paid_msat"`
	// Optional field: Amount we were paid by peer at open.
	FeeRcvdMsat Amount `json:"fee_rcvd_msat"`
}

type ListpeersPeersChannelsAlias struct{
	// Optional field: An alias assigned by this node to this channel, used for outgoing payments.
	Local ShortChannelId `json:"local"`
	// Optional field: An alias assigned by the remote node to this channel, usable in routehints and invoices.
	Remote ShortChannelId `json:"remote"`
}

// ChannelState, Previous state.
type ChannelState int

const (
	ChannelState_Openingd ChannelState = iota
	ChannelState_ChanneldAwaitingLockin
	ChannelState_ChanneldNormal
	ChannelState_ChanneldShuttingDown
	ChannelState_ClosingdSigexchange
	ChannelState_ClosingdComplete
	ChannelState_AwaitingUnilateral
	ChannelState_FundingSpendSeen
	ChannelState_Onchain
	ChannelState_DualopendOpenInit
	ChannelState_DualopendAwaitingLockin
)

func (s ChannelState) String() (string, error) {
	switch s {
	case ChannelState_Openingd:
		return "OPENINGD", nil
	case ChannelState_ChanneldAwaitingLockin:
		return "CHANNELD_AWAITING_LOCKIN", nil
	case ChannelState_ChanneldNormal:
		return "CHANNELD_NORMAL", nil
	case ChannelState_ChanneldShuttingDown:
		return "CHANNELD_SHUTTING_DOWN", nil
	case ChannelState_ClosingdSigexchange:
		return "CLOSINGD_SIGEXCHANGE", nil
	case ChannelState_ClosingdComplete:
		return "CLOSINGD_COMPLETE", nil
	case ChannelState_AwaitingUnilateral:
		return "AWAITING_UNILATERAL", nil
	case ChannelState_FundingSpendSeen:
		return "FUNDING_SPEND_SEEN", nil
	case ChannelState_Onchain:
		return "ONCHAIN", nil
	case ChannelState_DualopendOpenInit:
		return "DUALOPEND_OPEN_INIT", nil
	case ChannelState_DualopendAwaitingLockin:
		return "DUALOPEND_AWAITING_LOCKIN", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *ChannelState) FromString(p string) error {
	switch p {
	case "OPENINGD":
		*s = ChannelState_Openingd
	case "CHANNELD_AWAITING_LOCKIN":
		*s = ChannelState_ChanneldAwaitingLockin
	case "CHANNELD_NORMAL":
		*s = ChannelState_ChanneldNormal
	case "CHANNELD_SHUTTING_DOWN":
		*s = ChannelState_ChanneldShuttingDown
	case "CLOSINGD_SIGEXCHANGE":
		*s = ChannelState_ClosingdSigexchange
	case "CLOSINGD_COMPLETE":
		*s = ChannelState_ClosingdComplete
	case "AWAITING_UNILATERAL":
		*s = ChannelState_AwaitingUnilateral
	case "FUNDING_SPEND_SEEN":
		*s = ChannelState_FundingSpendSeen
	case "ONCHAIN":
		*s = ChannelState_Onchain
	case "DUALOPEND_OPEN_INIT":
		*s = ChannelState_DualopendOpenInit
	case "DUALOPEND_AWAITING_LOCKIN":
		*s = ChannelState_DualopendAwaitingLockin
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s ChannelState) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *ChannelState) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

// ChannelStateChangeCause, What caused the change.
type ChannelStateChangeCause int

const (
	ChannelStateChangeCause_Unknown ChannelStateChangeCause = iota
	ChannelStateChangeCause_Local
	ChannelStateChangeCause_User
	ChannelStateChangeCause_Remote
	ChannelStateChangeCause_Protocol
	ChannelStateChangeCause_Onchain
)

func (s ChannelStateChangeCause) String() (string, error) {
	switch s {
	case ChannelStateChangeCause_Unknown:
		return "unknown", nil
	case ChannelStateChangeCause_Local:
		return "local", nil
	case ChannelStateChangeCause_User:
		return "user", nil
	case ChannelStateChangeCause_Remote:
		return "remote", nil
	case ChannelStateChangeCause_Protocol:
		return "protocol", nil
	case ChannelStateChangeCause_Onchain:
		return "onchain", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *ChannelStateChangeCause) FromString(p string) error {
	switch p {
	case "unknown":
		*s = ChannelStateChangeCause_Unknown
	case "local":
		*s = ChannelStateChangeCause_Local
	case "user":
		*s = ChannelStateChangeCause_User
	case "remote":
		*s = ChannelStateChangeCause_Remote
	case "protocol":
		*s = ChannelStateChangeCause_Protocol
	case "onchain":
		*s = ChannelStateChangeCause_Onchain
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s ChannelStateChangeCause) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *ChannelStateChangeCause) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type ListpeersPeersChannelsState_changes struct{
	// Required field: UTC timestamp of form YYYY-mm-ddTHH:MM:SS.%03dZ.
	Timestamp string `json:"timestamp"`
	// Required field
	OldState ChannelState `json:"old_state"`
	// Required field
	NewState ChannelState `json:"new_state"`
	// Required field
	Cause ChannelStateChangeCause `json:"cause"`
	// Required field: Human-readable explanation.
	Message string `json:"message"`
}

// ListpeersPeersChannelsHtlcsDirection, Whether it came from peer, or is going to peer.
type ListpeersPeersChannelsHtlcsDirection int

const (
	ListpeersPeersChannelsHtlcsDirection_In ListpeersPeersChannelsHtlcsDirection = iota
	ListpeersPeersChannelsHtlcsDirection_Out
)

func (s ListpeersPeersChannelsHtlcsDirection) String() (string, error) {
	switch s {
	case ListpeersPeersChannelsHtlcsDirection_In:
		return "in", nil
	case ListpeersPeersChannelsHtlcsDirection_Out:
		return "out", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *ListpeersPeersChannelsHtlcsDirection) FromString(p string) error {
	switch p {
	case "in":
		*s = ListpeersPeersChannelsHtlcsDirection_In
	case "out":
		*s = ListpeersPeersChannelsHtlcsDirection_Out
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s ListpeersPeersChannelsHtlcsDirection) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *ListpeersPeersChannelsHtlcsDirection) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

// ListpeersPeersChannelsHtlcsState, Status of the HTLC.
type ListpeersPeersChannelsHtlcsState int

const (
	ListpeersPeersChannelsHtlcsState_SentAddHtlc ListpeersPeersChannelsHtlcsState = iota
	ListpeersPeersChannelsHtlcsState_SentAddCommit
	ListpeersPeersChannelsHtlcsState_RcvdAddRevocation
	ListpeersPeersChannelsHtlcsState_RcvdAddAckCommit
	ListpeersPeersChannelsHtlcsState_SentAddAckRevocation
	ListpeersPeersChannelsHtlcsState_RcvdRemoveHtlc
	ListpeersPeersChannelsHtlcsState_RcvdRemoveCommit
	ListpeersPeersChannelsHtlcsState_SentRemoveRevocation
	ListpeersPeersChannelsHtlcsState_SentRemoveAckCommit
	ListpeersPeersChannelsHtlcsState_RcvdRemoveAckRevocation
)

func (s ListpeersPeersChannelsHtlcsState) String() (string, error) {
	switch s {
	case ListpeersPeersChannelsHtlcsState_SentAddHtlc:
		return "SENT_ADD_HTLC", nil
	case ListpeersPeersChannelsHtlcsState_SentAddCommit:
		return "SENT_ADD_COMMIT", nil
	case ListpeersPeersChannelsHtlcsState_RcvdAddRevocation:
		return "RCVD_ADD_REVOCATION", nil
	case ListpeersPeersChannelsHtlcsState_RcvdAddAckCommit:
		return "RCVD_ADD_ACK_COMMIT", nil
	case ListpeersPeersChannelsHtlcsState_SentAddAckRevocation:
		return "SENT_ADD_ACK_REVOCATION", nil
	case ListpeersPeersChannelsHtlcsState_RcvdRemoveHtlc:
		return "RCVD_REMOVE_HTLC", nil
	case ListpeersPeersChannelsHtlcsState_RcvdRemoveCommit:
		return "RCVD_REMOVE_COMMIT", nil
	case ListpeersPeersChannelsHtlcsState_SentRemoveRevocation:
		return "SENT_REMOVE_REVOCATION", nil
	case ListpeersPeersChannelsHtlcsState_SentRemoveAckCommit:
		return "SENT_REMOVE_ACK_COMMIT", nil
	case ListpeersPeersChannelsHtlcsState_RcvdRemoveAckRevocation:
		return "RCVD_REMOVE_ACK_REVOCATION", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *ListpeersPeersChannelsHtlcsState) FromString(p string) error {
	switch p {
	case "SENT_ADD_HTLC":
		*s = ListpeersPeersChannelsHtlcsState_SentAddHtlc
	case "SENT_ADD_COMMIT":
		*s = ListpeersPeersChannelsHtlcsState_SentAddCommit
	case "RCVD_ADD_REVOCATION":
		*s = ListpeersPeersChannelsHtlcsState_RcvdAddRevocation
	case "RCVD_ADD_ACK_COMMIT":
		*s = ListpeersPeersChannelsHtlcsState_RcvdAddAckCommit
	case "SENT_ADD_ACK_REVOCATION":
		*s = ListpeersPeersChannelsHtlcsState_SentAddAckRevocation
	case "RCVD_REMOVE_HTLC":
		*s = ListpeersPeersChannelsHtlcsState_RcvdRemoveHtlc
	case "RCVD_REMOVE_COMMIT":
		*s = ListpeersPeersChannelsHtlcsState_RcvdRemoveCommit
	case "SENT_REMOVE_REVOCATION":
		*s = ListpeersPeersChannelsHtlcsState_SentRemoveRevocation
	case "SENT_REMOVE_ACK_COMMIT":
		*s = ListpeersPeersChannelsHtlcsState_SentRemoveAckCommit
	case "RCVD_REMOVE_ACK_REVOCATION":
		*s = ListpeersPeersChannelsHtlcsState_RcvdRemoveAckRevocation
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s ListpeersPeersChannelsHtlcsState) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *ListpeersPeersChannelsHtlcsState) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type ListpeersPeersChannelsHtlcs struct{
	// Required field
	Direction ListpeersPeersChannelsHtlcsDirection `json:"direction"`
	// Required field: Unique ID for this htlc on this channel in this direction.
	Id uint64 `json:"id"`
	// Required field: Amount send/received for this HTLC.
	AmountMsat Amount `json:"amount_msat"`
	// Required field: Block this HTLC expires at.
	Expiry uint32 `json:"expiry"`
	// Required field: the hash of the payment_preimage which will prove payment.
	PaymentHash string `json:"payment_hash"`
	// Optional field: if this is too small to enforce onchain.
	LocalTrimmed bool `json:"local_trimmed"`
	// Optional field: set if this HTLC is currently waiting on a hook (and shows what plugin).
	Status string `json:"status"`
	// Required field
	State ListpeersPeersChannelsHtlcsState `json:"state"`
}

type ListpeersPeersChannels struct{
	// Required field
	State ListpeersPeersChannelsState `json:"state"`
	// Optional field: The txid we would use if we went onchain now.
	ScratchTxid string `json:"scratch_txid"`
	// Optional field
	Feerate ListpeersPeersChannelsFeerate `json:"feerate"`
	// Optional field: The current subdaemon controlling this connection.
	Owner string `json:"owner"`
	// Optional field: The short_channel_id (once locked in).
	ShortChannelId ShortChannelId `json:"short_channel_id"`
	// Optional field: The full channel_id.
	ChannelId string `json:"channel_id"`
	// Optional field: ID of the funding transaction.
	FundingTxid string `json:"funding_txid"`
	// Optional field: The 0-based output number of the funding transaction which opens the channel.
	FundingOutnum uint32 `json:"funding_outnum"`
	// Optional field: For inflight opens, the first feerate used to initiate the channel open.
	InitialFeerate string `json:"initial_feerate"`
	// Optional field: For inflight opens, the most recent feerate used on the channel open.
	LastFeerate string `json:"last_feerate"`
	// Optional field: For inflight opens, the next feerate we'll use for the channel open.
	NextFeerate string `json:"next_feerate"`
	// Optional field: For inflight opens, the next feerate step we'll use for the channel open.
	NextFeeStep uint32 `json:"next_fee_step"`
	// Optional field: Current candidate funding transactions (only for dual-funding).
	Inflight []ListpeersPeersChannelsInflight `json:"inflight"`
	// Optional field: scriptPubkey which we have to close to if we mutual close.
	CloseTo string `json:"close_to"`
	// Optional field: if False, we will not announce this channel.
	Private bool `json:"private"`
	// Required field
	Opener ChannelSide `json:"opener"`
	// Optional field
	Closer ChannelSide `json:"closer"`
	// Required field.
	Features []string `json:"features"`
	// Optional field
	Funding ListpeersPeersChannelsFunding `json:"funding"`
	// Optional field: how much of channel is owed to us.
	ToUsMsat Amount `json:"to_us_msat"`
	// Optional field: least amount owed to us ever.
	MinToUsMsat Amount `json:"min_to_us_msat"`
	// Optional field: most amount owed to us ever.
	MaxToUsMsat Amount `json:"max_to_us_msat"`
	// Optional field: total amount in the channel.
	TotalMsat Amount `json:"total_msat"`
	// Optional field: amount we charge to use the channel.
	FeeBaseMsat Amount `json:"fee_base_msat"`
	// Optional field: amount we charge to use the channel in parts-per-million.
	FeeProportionalMillionths uint32 `json:"fee_proportional_millionths"`
	// Optional field: minimum amount for an output on the channel transactions.
	DustLimitMsat Amount `json:"dust_limit_msat"`
	// Optional field: max amount accept in a single payment.
	MaxTotalHtlcInMsat Amount `json:"max_total_htlc_in_msat"`
	// Optional field: minimum we insist they keep in channel.
	TheirReserveMsat Amount `json:"their_reserve_msat"`
	// Optional field: minimum they insist we keep in channel.
	OurReserveMsat Amount `json:"our_reserve_msat"`
	// Optional field: total we could send through channel.
	SpendableMsat Amount `json:"spendable_msat"`
	// Optional field: total peer could send through channel.
	ReceivableMsat Amount `json:"receivable_msat"`
	// Optional field: the minimum amount HTLC we accept.
	MinimumHtlcInMsat Amount `json:"minimum_htlc_in_msat"`
	// Optional field: the minimum amount HTLC we will send.
	MinimumHtlcOutMsat Amount `json:"minimum_htlc_out_msat"`
	// Optional field: the maximum amount HTLC we will send.
	MaximumHtlcOutMsat Amount `json:"maximum_htlc_out_msat"`
	// Optional field: the number of blocks before they can take their funds if they unilateral close.
	TheirToSelfDelay uint32 `json:"their_to_self_delay"`
	// Optional field: the number of blocks before we can take our funds if we unilateral close.
	OurToSelfDelay uint32 `json:"our_to_self_delay"`
	// Optional field: Maximum number of incoming HTLC we will accept at once.
	MaxAcceptedHtlcs uint32 `json:"max_accepted_htlcs"`
	// Optional field
	Alias ListpeersPeersChannelsAlias `json:"alias"`
	// Optional field: Prior state changes.
	StateChanges []ListpeersPeersChannelsState_changes `json:"state_changes"`
	// Optional field.
	Status []string `json:"status"`
	// Optional field: Number of incoming payment attempts.
	InPaymentsOffered uint64 `json:"in_payments_offered"`
	// Optional field: Total amount of incoming payment attempts.
	InOfferedMsat Amount `json:"in_offered_msat"`
	// Optional field: Number of successful incoming payment attempts.
	InPaymentsFulfilled uint64 `json:"in_payments_fulfilled"`
	// Optional field: Total amount of successful incoming payment attempts.
	InFulfilledMsat Amount `json:"in_fulfilled_msat"`
	// Optional field: Number of outgoing payment attempts.
	OutPaymentsOffered uint64 `json:"out_payments_offered"`
	// Optional field: Total amount of outgoing payment attempts.
	OutOfferedMsat Amount `json:"out_offered_msat"`
	// Optional field: Number of successful outgoing payment attempts.
	OutPaymentsFulfilled uint64 `json:"out_payments_fulfilled"`
	// Optional field: Total amount of successful outgoing payment attempts.
	OutFulfilledMsat Amount `json:"out_fulfilled_msat"`
	// Optional field: current HTLCs in this channel.
	Htlcs []ListpeersPeersChannelsHtlcs `json:"htlcs"`
	// Optional field: The bitcoin address we will close to.
	CloseToAddr string `json:"close_to_addr"`
}

type ListpeersPeers struct{
	// Required field: the public key of the peer.
	Id string `json:"id"`
	// Required field: True if the peer is currently connected.
	Connected bool `json:"connected"`
	// Required field: The number of channels the peer has with this node.
	NumChannels uint32 `json:"num_channels"`
	// Optional field: if *level* is specified, logs for this peer.
	Log []ListpeersPeersLog `json:"log"`
	// Deprecated: This field has been deprecated in v23.02
	// Optional field.
	Channels []ListpeersPeersChannels `json:"channels"`
	// Optional field: A single entry array.
	Netaddr []string `json:"netaddr"`
	// Optional field: The public IPv4/6 address the peer sees us from, e.g. 1.2.3.4:1234.
	RemoteAddr string `json:"remote_addr"`
	// Optional field: bitmap of BOLT #9 features from peer's INIT message.
	Features string `json:"features"`
}

type ListpeersResponse struct{
	// Required field.
	Peers []ListpeersPeers `json:"peers"`
}

// ListfundsOutputsStatus
type ListfundsOutputsStatus int

const (
	ListfundsOutputsStatus_Unconfirmed ListfundsOutputsStatus = iota
	ListfundsOutputsStatus_Confirmed
	ListfundsOutputsStatus_Spent
	ListfundsOutputsStatus_Immature
)

func (s ListfundsOutputsStatus) String() (string, error) {
	switch s {
	case ListfundsOutputsStatus_Unconfirmed:
		return "unconfirmed", nil
	case ListfundsOutputsStatus_Confirmed:
		return "confirmed", nil
	case ListfundsOutputsStatus_Spent:
		return "spent", nil
	case ListfundsOutputsStatus_Immature:
		return "immature", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *ListfundsOutputsStatus) FromString(p string) error {
	switch p {
	case "unconfirmed":
		*s = ListfundsOutputsStatus_Unconfirmed
	case "confirmed":
		*s = ListfundsOutputsStatus_Confirmed
	case "spent":
		*s = ListfundsOutputsStatus_Spent
	case "immature":
		*s = ListfundsOutputsStatus_Immature
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s ListfundsOutputsStatus) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *ListfundsOutputsStatus) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type ListfundsOutputs struct{
	// Required field: the ID of the spendable transaction.
	Txid string `json:"txid"`
	// Required field: the index within *txid*.
	Output uint32 `json:"output"`
	// Required field: the amount of the output.
	AmountMsat Amount `json:"amount_msat"`
	// Required field: the scriptPubkey of the output.
	Scriptpubkey string `json:"scriptpubkey"`
	// Optional field: the bitcoin address of the output.
	Address string `json:"address"`
	// Optional field: the redeemscript, only if it's p2sh-wrapped.
	Redeemscript string `json:"redeemscript"`
	// Required field
	Status ListfundsOutputsStatus `json:"status"`
	// Required field: whether this UTXO is currently reserved for an in-flight tx.
	Reserved bool `json:"reserved"`
	// Optional field: Block height where it was confirmed.
	Blockheight uint32 `json:"blockheight"`
}

type ListfundsChannels struct{
	// Required field: the peer with which the channel is opened.
	PeerId string `json:"peer_id"`
	// Required field: available satoshis on our node's end of the channel.
	OurAmountMsat Amount `json:"our_amount_msat"`
	// Required field: total channel value.
	AmountMsat Amount `json:"amount_msat"`
	// Required field: funding transaction id.
	FundingTxid string `json:"funding_txid"`
	// Required field: the 0-based index of the output in the funding transaction.
	FundingOutput uint32 `json:"funding_output"`
	// Required field: whether the channel peer is connected.
	Connected bool `json:"connected"`
	// Required field
	State ChannelState `json:"state"`
	// Required field: The full channel_id (funding txid Xored with output number).
	ChannelId string `json:"channel_id"`
	// Optional field: short channel id of channel.
	ShortChannelId ShortChannelId `json:"short_channel_id"`
}

type ListfundsResponse struct{
	// Required field.
	Outputs []ListfundsOutputs `json:"outputs"`
	// Required field.
	Channels []ListfundsChannels `json:"channels"`
}

type SendpayResponse struct{
	// Required field: unique ID for this payment attempt.
	Id uint64 `json:"id"`
	// Optional field: Grouping key to disambiguate multiple attempts to pay an invoice or the same payment_hash.
	Groupid uint64 `json:"groupid"`
	// Required field: the hash of the *payment_preimage* which will prove payment.
	PaymentHash string `json:"payment_hash"`
	// Required field
	Status PayStatus `json:"status"`
	// Optional field: The amount delivered to destination (if known).
	AmountMsat Amount `json:"amount_msat"`
	// Optional field: the final destination of the payment if known.
	Destination string `json:"destination"`
	// Required field: the UNIX timestamp showing when this payment was initiated.
	CreatedAt uint64 `json:"created_at"`
	// Optional field: the UNIX timestamp showing when this payment was completed.
	CompletedAt uint64 `json:"completed_at"`
	// Required field: The amount sent.
	AmountSentMsat Amount `json:"amount_sent_msat"`
	// Optional field: the *label*, if given to sendpay.
	Label string `json:"label"`
	// Optional field: the *partid*, if given to sendpay.
	Partid uint64 `json:"partid"`
	// Optional field: the bolt11 string (if supplied).
	Bolt11 string `json:"bolt11"`
	// Optional field: the bolt12 string (if supplied: **experimental-offers** only)..
	Bolt12 string `json:"bolt12"`
	// Optional field: the proof of payment: SHA256 of this **payment_hash**.
	PaymentPreimage string `json:"payment_preimage"`
	// Optional field: Monitor status with listpays or waitsendpay.
	Message string `json:"message"`
}

type ListchannelsChannels struct{
	// Required field: the source node.
	Source string `json:"source"`
	// Required field: the destination node.
	Destination string `json:"destination"`
	// Required field: short channel id of channel.
	ShortChannelId ShortChannelId `json:"short_channel_id"`
	// Required field: direction (0 if source < destination, 1 otherwise)..
	Direction uint32 `json:"direction"`
	// Required field: true if this is announced (otherwise it must be our channel).
	Public bool `json:"public"`
	// Required field: the total capacity of this channel (always a whole number of satoshis).
	AmountMsat Amount `json:"amount_msat"`
	// Required field: as defined by BOLT #7.
	MessageFlags uint8 `json:"message_flags"`
	// Required field: as defined by BOLT #7.
	ChannelFlags uint8 `json:"channel_flags"`
	// Required field: true unless source has disabled it, or it's a local channel and the peer is disconnected or it's still opening or closing.
	Active bool `json:"active"`
	// Required field: UNIX timestamp on the last channel_update from *source*.
	LastUpdate uint32 `json:"last_update"`
	// Required field: Base fee changed by *source* to use this channel.
	BaseFeeMillisatoshi uint32 `json:"base_fee_millisatoshi"`
	// Required field: Proportional fee changed by *source* to use this channel, in parts-per-million.
	FeePerMillionth uint32 `json:"fee_per_millionth"`
	// Required field: The number of blocks delay required by *source* to use this channel.
	Delay uint32 `json:"delay"`
	// Required field: The smallest payment *source* will allow via this channel.
	HtlcMinimumMsat Amount `json:"htlc_minimum_msat"`
	// Optional field: The largest payment *source* will allow via this channel.
	HtlcMaximumMsat Amount `json:"htlc_maximum_msat"`
	// Required field: BOLT #9 features bitmap for this channel.
	Features string `json:"features"`
}

type ListchannelsResponse struct{
	// Required field.
	Channels []ListchannelsChannels `json:"channels"`
}

type AddgossipResponse struct{
}

type AutocleaninvoiceResponse struct{
	// Required field: whether invoice autocleaning is active.
	Enabled bool `json:"enabled"`
	// Optional field: how long an invoice must be expired (seconds) before we delete it.
	ExpiredBy uint64 `json:"expired_by"`
	// Optional field: how long an invoice must be expired (seconds) before we delete it.
	CycleSeconds uint64 `json:"cycle_seconds"`
}

type CheckmessageResponse struct{
	// Required field: whether the signature was valid.
	Verified bool `json:"verified"`
	// Required field: the *pubkey* parameter, or the pubkey found by looking for known nodes.
	Pubkey string `json:"pubkey"`
}

// CloseType, Whether we successfully negotiated a mutual close, closed without them, or discarded not-yet-opened channel.
type CloseType int

const (
	CloseType_Mutual CloseType = iota
	CloseType_Unilateral
	CloseType_Unopened
)

func (s CloseType) String() (string, error) {
	switch s {
	case CloseType_Mutual:
		return "mutual", nil
	case CloseType_Unilateral:
		return "unilateral", nil
	case CloseType_Unopened:
		return "unopened", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *CloseType) FromString(p string) error {
	switch p {
	case "mutual":
		*s = CloseType_Mutual
	case "unilateral":
		*s = CloseType_Unilateral
	case "unopened":
		*s = CloseType_Unopened
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s CloseType) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *CloseType) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type CloseResponse struct{
	// Required field
	ItemType CloseType `json:"type"`
	// Optional field: the raw bitcoin transaction used to close the channel (if it was open).
	Tx string `json:"tx"`
	// Optional field: the transaction id of the *tx* field.
	Txid string `json:"txid"`
}

// ConnectDirection, Whether they initiated connection or we did.
type ConnectDirection int

const (
	ConnectDirection_In ConnectDirection = iota
	ConnectDirection_Out
)

func (s ConnectDirection) String() (string, error) {
	switch s {
	case ConnectDirection_In:
		return "in", nil
	case ConnectDirection_Out:
		return "out", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *ConnectDirection) FromString(p string) error {
	switch p {
	case "in":
		*s = ConnectDirection_In
	case "out":
		*s = ConnectDirection_Out
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s ConnectDirection) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *ConnectDirection) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

// ConnectAddressType, Type of connection (*torv2*/*torv3* only if **direction** is *out*).
type ConnectAddressType int

const (
	ConnectAddressType_LocalSocket ConnectAddressType = iota
	ConnectAddressType_Ipv4
	ConnectAddressType_Ipv6
	ConnectAddressType_Torv2
	ConnectAddressType_Torv3
)

func (s ConnectAddressType) String() (string, error) {
	switch s {
	case ConnectAddressType_LocalSocket:
		return "local socket", nil
	case ConnectAddressType_Ipv4:
		return "ipv4", nil
	case ConnectAddressType_Ipv6:
		return "ipv6", nil
	case ConnectAddressType_Torv2:
		return "torv2", nil
	case ConnectAddressType_Torv3:
		return "torv3", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *ConnectAddressType) FromString(p string) error {
	switch p {
	case "local socket":
		*s = ConnectAddressType_LocalSocket
	case "ipv4":
		*s = ConnectAddressType_Ipv4
	case "ipv6":
		*s = ConnectAddressType_Ipv6
	case "torv2":
		*s = ConnectAddressType_Torv2
	case "torv3":
		*s = ConnectAddressType_Torv3
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s ConnectAddressType) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *ConnectAddressType) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type ConnectAddress struct{
	// Required field
	ItemType ConnectAddressType `json:"type"`
	// Optional field: socket filename.
	Socket string `json:"socket"`
	// Optional field: address in expected format for **type**.
	Address string `json:"address"`
	// Optional field: port number.
	Port uint16 `json:"port"`
}

type ConnectResponse struct{
	// Required field: the peer we connected to.
	Id string `json:"id"`
	// Required field: BOLT 9 features bitmap offered by peer.
	Features string `json:"features"`
	// Required field
	Direction ConnectDirection `json:"direction"`
	// Required field
	Address ConnectAddress `json:"address"`
}

// CreateinvoiceStatus, Whether it has been paid, or can no longer be paid.
type CreateinvoiceStatus int

const (
	CreateinvoiceStatus_Paid CreateinvoiceStatus = iota
	CreateinvoiceStatus_Expired
	CreateinvoiceStatus_Unpaid
)

func (s CreateinvoiceStatus) String() (string, error) {
	switch s {
	case CreateinvoiceStatus_Paid:
		return "paid", nil
	case CreateinvoiceStatus_Expired:
		return "expired", nil
	case CreateinvoiceStatus_Unpaid:
		return "unpaid", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *CreateinvoiceStatus) FromString(p string) error {
	switch p {
	case "paid":
		*s = CreateinvoiceStatus_Paid
	case "expired":
		*s = CreateinvoiceStatus_Expired
	case "unpaid":
		*s = CreateinvoiceStatus_Unpaid
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s CreateinvoiceStatus) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *CreateinvoiceStatus) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type CreateinvoiceResponse struct{
	// Required field: the label for the invoice.
	Label string `json:"label"`
	// Optional field: the bolt11 string (always present unless **bolt12** is).
	Bolt11 string `json:"bolt11"`
	// Optional field: the bolt12 string instead of **bolt11** (**experimental-offers** only).
	Bolt12 string `json:"bolt12"`
	// Required field: the hash of the *payment_preimage* which will prove payment.
	PaymentHash string `json:"payment_hash"`
	// Optional field: The amount of the invoice (if it has one).
	AmountMsat Amount `json:"amount_msat"`
	// Required field
	Status CreateinvoiceStatus `json:"status"`
	// Required field: Description extracted from **bolt11** or **bolt12**.
	Description string `json:"description"`
	// Required field: UNIX timestamp of when invoice expires (or expired).
	ExpiresAt uint64 `json:"expires_at"`
	// Optional field: Incrementing id for when this was paid (**status** *paid* only).
	PayIndex uint64 `json:"pay_index"`
	// Optional field: Amount actually received (**status** *paid* only).
	AmountReceivedMsat Amount `json:"amount_received_msat"`
	// Optional field: UNIX timestamp of when invoice was paid (**status** *paid* only).
	PaidAt uint64 `json:"paid_at"`
	// Optional field: the proof of payment: SHA256 of this **payment_hash**.
	PaymentPreimage string `json:"payment_preimage"`
	// Optional field: the *id* of our offer which created this invoice (**experimental-offers** only)..
	LocalOfferId string `json:"local_offer_id"`
	// Optional field: the optional *invreq_payer_note* from invoice_request which created this invoice (**experimental-offers** only)..
	InvreqPayerNote string `json:"invreq_payer_note"`
}

type DatastoreResponse struct{
	// Required field.
	Key []string `json:"key"`
	// Optional field: The number of times this has been updated.
	Generation uint64 `json:"generation"`
	// Optional field: The hex data which has been added to the datastore.
	Hex string `json:"hex"`
	// Optional field: The data as a string, if it's valid utf-8.
	String string `json:"string"`
}

type CreateonionResponse struct{
	// Required field: the onion packet (*onion_size* bytes).
	Onion string `json:"onion"`
	// Required field: one shared secret for each node in the *hops* parameter.
	SharedSecrets []string `json:"shared_secrets"`
}

type DeldatastoreResponse struct{
	// Required field.
	Key []string `json:"key"`
	// Optional field: The number of times this has been updated.
	Generation uint64 `json:"generation"`
	// Optional field: The hex data which has removed from the datastore.
	Hex string `json:"hex"`
	// Optional field: The data as a string, if it's valid utf-8.
	String string `json:"string"`
}

type DelexpiredinvoiceResponse struct{
}

type DelinvoiceResponse struct{
	// Required field: Unique label given at creation time.
	Label string `json:"label"`
	// Optional field: BOLT11 string.
	Bolt11 string `json:"bolt11"`
	// Optional field: BOLT12 string.
	Bolt12 string `json:"bolt12"`
	// Optional field: the amount required to pay this invoice.
	AmountMsat Amount `json:"amount_msat"`
	// Optional field: description used in the invoice.
	Description string `json:"description"`
	// Required field: the hash of the *payment_preimage* which will prove payment.
	PaymentHash string `json:"payment_hash"`
	// Required field
	Status DelinvoiceStatus `json:"status"`
	// Required field: UNIX timestamp when invoice expires (or expired).
	ExpiresAt uint64 `json:"expires_at"`
	// Optional field: offer for which this invoice was created.
	LocalOfferId string `json:"local_offer_id"`
	// Optional field: the optional *invreq_payer_note* from invoice_request which created this invoice.
	InvreqPayerNote string `json:"invreq_payer_note"`
}

type InvoiceResponse struct{
	// Required field: the bolt11 string.
	Bolt11 string `json:"bolt11"`
	// Required field: the hash of the *payment_preimage* which will prove payment.
	PaymentHash string `json:"payment_hash"`
	// Required field: the *payment_secret* to place in the onion.
	PaymentSecret string `json:"payment_secret"`
	// Required field: UNIX timestamp of when invoice expires.
	ExpiresAt uint64 `json:"expires_at"`
	// Optional field: even using all possible channels, there's not enough incoming capacity to pay this invoice..
	WarningCapacity string `json:"warning_capacity"`
	// Optional field: there would be enough incoming capacity, but some channels are offline, so there isn't..
	WarningOffline string `json:"warning_offline"`
	// Optional field: there would be enough incoming capacity, but some channels are dead-ends (no other public channels from those peers), so there isn't..
	WarningDeadends string `json:"warning_deadends"`
	// Optional field: there would be enough incoming capacity, but some channels are unannounced and *exposeprivatechannels* is *false*, so there isn't..
	WarningPrivateUnused string `json:"warning_private_unused"`
	// Optional field: there is sufficient capacity, but not in a single channel, so the payer will have to use multi-part payments..
	WarningMpp string `json:"warning_mpp"`
}

type ListdatastoreDatastore struct{
	// Required field.
	Key []string `json:"key"`
	// Optional field: The number of times this has been updated.
	Generation uint64 `json:"generation"`
	// Optional field: The hex data from the datastore.
	Hex string `json:"hex"`
	// Optional field: The data as a string, if it's valid utf-8.
	String string `json:"string"`
}

type ListdatastoreResponse struct{
	// Required field.
	Datastore []ListdatastoreDatastore `json:"datastore"`
}

// ListinvoicesInvoicesStatus, Whether it's paid, unpaid or unpayable.
type ListinvoicesInvoicesStatus int

const (
	ListinvoicesInvoicesStatus_Unpaid ListinvoicesInvoicesStatus = iota
	ListinvoicesInvoicesStatus_Paid
	ListinvoicesInvoicesStatus_Expired
)

func (s ListinvoicesInvoicesStatus) String() (string, error) {
	switch s {
	case ListinvoicesInvoicesStatus_Unpaid:
		return "unpaid", nil
	case ListinvoicesInvoicesStatus_Paid:
		return "paid", nil
	case ListinvoicesInvoicesStatus_Expired:
		return "expired", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *ListinvoicesInvoicesStatus) FromString(p string) error {
	switch p {
	case "unpaid":
		*s = ListinvoicesInvoicesStatus_Unpaid
	case "paid":
		*s = ListinvoicesInvoicesStatus_Paid
	case "expired":
		*s = ListinvoicesInvoicesStatus_Expired
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s ListinvoicesInvoicesStatus) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *ListinvoicesInvoicesStatus) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type ListinvoicesInvoices struct{
	// Required field: unique label supplied at invoice creation.
	Label string `json:"label"`
	// Optional field: description used in the invoice.
	Description string `json:"description"`
	// Required field: the hash of the *payment_preimage* which will prove payment.
	PaymentHash string `json:"payment_hash"`
	// Required field
	Status ListinvoicesInvoicesStatus `json:"status"`
	// Required field: UNIX timestamp of when it will become / became unpayable.
	ExpiresAt uint64 `json:"expires_at"`
	// Optional field: the amount required to pay this invoice.
	AmountMsat Amount `json:"amount_msat"`
	// Optional field: the BOLT11 string (always present unless *bolt12* is).
	Bolt11 string `json:"bolt11"`
	// Optional field: the BOLT12 string (always present unless *bolt11* is).
	Bolt12 string `json:"bolt12"`
	// Optional field: the *id* of our offer which created this invoice (**experimental-offers** only)..
	LocalOfferId string `json:"local_offer_id"`
	// Optional field: the optional *invreq_payer_note* from invoice_request which created this invoice (**experimental-offers** only)..
	InvreqPayerNote string `json:"invreq_payer_note"`
	// Optional field: Unique incrementing index for this payment.
	PayIndex uint64 `json:"pay_index"`
	// Optional field: the amount actually received (could be slightly greater than *amount_msat*, since clients may overpay).
	AmountReceivedMsat Amount `json:"amount_received_msat"`
	// Optional field: UNIX timestamp of when it was paid.
	PaidAt uint64 `json:"paid_at"`
	// Optional field: proof of payment.
	PaymentPreimage string `json:"payment_preimage"`
}

type ListinvoicesResponse struct{
	// Required field.
	Invoices []ListinvoicesInvoices `json:"invoices"`
}

// SendonionStatus, status of the payment (could be complete if already sent previously).
type SendonionStatus int

const (
	SendonionStatus_Pending SendonionStatus = iota
	SendonionStatus_Complete
)

func (s SendonionStatus) String() (string, error) {
	switch s {
	case SendonionStatus_Pending:
		return "pending", nil
	case SendonionStatus_Complete:
		return "complete", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *SendonionStatus) FromString(p string) error {
	switch p {
	case "pending":
		*s = SendonionStatus_Pending
	case "complete":
		*s = SendonionStatus_Complete
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s SendonionStatus) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *SendonionStatus) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type SendonionResponse struct{
	// Required field: unique ID for this payment attempt.
	Id uint64 `json:"id"`
	// Required field: the hash of the *payment_preimage* which will prove payment.
	PaymentHash string `json:"payment_hash"`
	// Required field
	Status SendonionStatus `json:"status"`
	// Optional field: The amount delivered to destination (if known).
	AmountMsat Amount `json:"amount_msat"`
	// Optional field: the final destination of the payment if known.
	Destination string `json:"destination"`
	// Required field: the UNIX timestamp showing when this payment was initiated.
	CreatedAt uint64 `json:"created_at"`
	// Required field: The amount sent.
	AmountSentMsat Amount `json:"amount_sent_msat"`
	// Optional field: the label, if given to sendpay.
	Label string `json:"label"`
	// Optional field: the bolt11 string (if supplied).
	Bolt11 string `json:"bolt11"`
	// Optional field: the bolt12 string (if supplied: **experimental-offers** only)..
	Bolt12 string `json:"bolt12"`
	// Optional field: the partid (if supplied) to sendonion/sendpay.
	Partid uint64 `json:"partid"`
	// Optional field: the proof of payment: SHA256 of this **payment_hash**.
	PaymentPreimage string `json:"payment_preimage"`
	// Optional field: Monitor status with listpays or waitsendpay.
	Message string `json:"message"`
}

// ListsendpaysPaymentsStatus, status of the payment.
type ListsendpaysPaymentsStatus int

const (
	ListsendpaysPaymentsStatus_Pending ListsendpaysPaymentsStatus = iota
	ListsendpaysPaymentsStatus_Failed
	ListsendpaysPaymentsStatus_Complete
)

func (s ListsendpaysPaymentsStatus) String() (string, error) {
	switch s {
	case ListsendpaysPaymentsStatus_Pending:
		return "pending", nil
	case ListsendpaysPaymentsStatus_Failed:
		return "failed", nil
	case ListsendpaysPaymentsStatus_Complete:
		return "complete", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *ListsendpaysPaymentsStatus) FromString(p string) error {
	switch p {
	case "pending":
		*s = ListsendpaysPaymentsStatus_Pending
	case "failed":
		*s = ListsendpaysPaymentsStatus_Failed
	case "complete":
		*s = ListsendpaysPaymentsStatus_Complete
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s ListsendpaysPaymentsStatus) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *ListsendpaysPaymentsStatus) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type ListsendpaysPayments struct{
	// Required field: unique ID for this payment attempt.
	Id uint64 `json:"id"`
	// Required field: Grouping key to disambiguate multiple attempts to pay an invoice or the same payment_hash.
	Groupid uint64 `json:"groupid"`
	// Optional field: Part number (for multiple parts to a single payment).
	Partid uint64 `json:"partid"`
	// Required field: the hash of the *payment_preimage* which will prove payment.
	PaymentHash string `json:"payment_hash"`
	// Required field
	Status ListsendpaysPaymentsStatus `json:"status"`
	// Optional field: The amount delivered to destination (if known).
	AmountMsat Amount `json:"amount_msat"`
	// Optional field: the final destination of the payment if known.
	Destination string `json:"destination"`
	// Required field: the UNIX timestamp showing when this payment was initiated.
	CreatedAt uint64 `json:"created_at"`
	// Required field: The amount sent.
	AmountSentMsat Amount `json:"amount_sent_msat"`
	// Optional field: the label, if given to sendpay.
	Label string `json:"label"`
	// Optional field: the bolt11 string (if pay supplied one).
	Bolt11 string `json:"bolt11"`
	// Optional field: the description matching the bolt11 description hash (if pay supplied one).
	Description string `json:"description"`
	// Optional field: the bolt12 string (if supplied for pay: **experimental-offers** only)..
	Bolt12 string `json:"bolt12"`
	// Optional field: the proof of payment: SHA256 of this **payment_hash**.
	PaymentPreimage string `json:"payment_preimage"`
	// Optional field: the onion message returned.
	Erroronion string `json:"erroronion"`
}

type ListsendpaysResponse struct{
	// Required field.
	Payments []ListsendpaysPayments `json:"payments"`
}

// ListtransactionsTransactionsInputsType, the purpose of this input (*EXPERIMENTAL_FEATURES* only).
type ListtransactionsTransactionsInputsType int

const (
	ListtransactionsTransactionsInputsType_Theirs ListtransactionsTransactionsInputsType = iota
	ListtransactionsTransactionsInputsType_Deposit
	ListtransactionsTransactionsInputsType_Withdraw
	ListtransactionsTransactionsInputsType_ChannelFunding
	ListtransactionsTransactionsInputsType_ChannelMutualClose
	ListtransactionsTransactionsInputsType_ChannelUnilateralClose
	ListtransactionsTransactionsInputsType_ChannelSweep
	ListtransactionsTransactionsInputsType_ChannelHtlcSuccess
	ListtransactionsTransactionsInputsType_ChannelHtlcTimeout
	ListtransactionsTransactionsInputsType_ChannelPenalty
	ListtransactionsTransactionsInputsType_ChannelUnilateralCheat
)

func (s ListtransactionsTransactionsInputsType) String() (string, error) {
	switch s {
	case ListtransactionsTransactionsInputsType_Theirs:
		return "theirs", nil
	case ListtransactionsTransactionsInputsType_Deposit:
		return "deposit", nil
	case ListtransactionsTransactionsInputsType_Withdraw:
		return "withdraw", nil
	case ListtransactionsTransactionsInputsType_ChannelFunding:
		return "channel_funding", nil
	case ListtransactionsTransactionsInputsType_ChannelMutualClose:
		return "channel_mutual_close", nil
	case ListtransactionsTransactionsInputsType_ChannelUnilateralClose:
		return "channel_unilateral_close", nil
	case ListtransactionsTransactionsInputsType_ChannelSweep:
		return "channel_sweep", nil
	case ListtransactionsTransactionsInputsType_ChannelHtlcSuccess:
		return "channel_htlc_success", nil
	case ListtransactionsTransactionsInputsType_ChannelHtlcTimeout:
		return "channel_htlc_timeout", nil
	case ListtransactionsTransactionsInputsType_ChannelPenalty:
		return "channel_penalty", nil
	case ListtransactionsTransactionsInputsType_ChannelUnilateralCheat:
		return "channel_unilateral_cheat", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *ListtransactionsTransactionsInputsType) FromString(p string) error {
	switch p {
	case "theirs":
		*s = ListtransactionsTransactionsInputsType_Theirs
	case "deposit":
		*s = ListtransactionsTransactionsInputsType_Deposit
	case "withdraw":
		*s = ListtransactionsTransactionsInputsType_Withdraw
	case "channel_funding":
		*s = ListtransactionsTransactionsInputsType_ChannelFunding
	case "channel_mutual_close":
		*s = ListtransactionsTransactionsInputsType_ChannelMutualClose
	case "channel_unilateral_close":
		*s = ListtransactionsTransactionsInputsType_ChannelUnilateralClose
	case "channel_sweep":
		*s = ListtransactionsTransactionsInputsType_ChannelSweep
	case "channel_htlc_success":
		*s = ListtransactionsTransactionsInputsType_ChannelHtlcSuccess
	case "channel_htlc_timeout":
		*s = ListtransactionsTransactionsInputsType_ChannelHtlcTimeout
	case "channel_penalty":
		*s = ListtransactionsTransactionsInputsType_ChannelPenalty
	case "channel_unilateral_cheat":
		*s = ListtransactionsTransactionsInputsType_ChannelUnilateralCheat
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s ListtransactionsTransactionsInputsType) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *ListtransactionsTransactionsInputsType) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type ListtransactionsTransactionsInputs struct{
	// Required field: the transaction id spent.
	Txid string `json:"txid"`
	// Required field: the output spent.
	Index uint32 `json:"index"`
	// Required field: the nSequence value.
	Sequence uint32 `json:"sequence"`
	// Optional field
	ItemType ListtransactionsTransactionsInputsType `json:"type"`
	// Optional field: the channel this input is associated with (*EXPERIMENTAL_FEATURES* only).
	Channel ShortChannelId `json:"channel"`
}

// ListtransactionsTransactionsOutputsType, the purpose of this output (*EXPERIMENTAL_FEATURES* only).
type ListtransactionsTransactionsOutputsType int

const (
	ListtransactionsTransactionsOutputsType_Theirs ListtransactionsTransactionsOutputsType = iota
	ListtransactionsTransactionsOutputsType_Deposit
	ListtransactionsTransactionsOutputsType_Withdraw
	ListtransactionsTransactionsOutputsType_ChannelFunding
	ListtransactionsTransactionsOutputsType_ChannelMutualClose
	ListtransactionsTransactionsOutputsType_ChannelUnilateralClose
	ListtransactionsTransactionsOutputsType_ChannelSweep
	ListtransactionsTransactionsOutputsType_ChannelHtlcSuccess
	ListtransactionsTransactionsOutputsType_ChannelHtlcTimeout
	ListtransactionsTransactionsOutputsType_ChannelPenalty
	ListtransactionsTransactionsOutputsType_ChannelUnilateralCheat
)

func (s ListtransactionsTransactionsOutputsType) String() (string, error) {
	switch s {
	case ListtransactionsTransactionsOutputsType_Theirs:
		return "theirs", nil
	case ListtransactionsTransactionsOutputsType_Deposit:
		return "deposit", nil
	case ListtransactionsTransactionsOutputsType_Withdraw:
		return "withdraw", nil
	case ListtransactionsTransactionsOutputsType_ChannelFunding:
		return "channel_funding", nil
	case ListtransactionsTransactionsOutputsType_ChannelMutualClose:
		return "channel_mutual_close", nil
	case ListtransactionsTransactionsOutputsType_ChannelUnilateralClose:
		return "channel_unilateral_close", nil
	case ListtransactionsTransactionsOutputsType_ChannelSweep:
		return "channel_sweep", nil
	case ListtransactionsTransactionsOutputsType_ChannelHtlcSuccess:
		return "channel_htlc_success", nil
	case ListtransactionsTransactionsOutputsType_ChannelHtlcTimeout:
		return "channel_htlc_timeout", nil
	case ListtransactionsTransactionsOutputsType_ChannelPenalty:
		return "channel_penalty", nil
	case ListtransactionsTransactionsOutputsType_ChannelUnilateralCheat:
		return "channel_unilateral_cheat", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *ListtransactionsTransactionsOutputsType) FromString(p string) error {
	switch p {
	case "theirs":
		*s = ListtransactionsTransactionsOutputsType_Theirs
	case "deposit":
		*s = ListtransactionsTransactionsOutputsType_Deposit
	case "withdraw":
		*s = ListtransactionsTransactionsOutputsType_Withdraw
	case "channel_funding":
		*s = ListtransactionsTransactionsOutputsType_ChannelFunding
	case "channel_mutual_close":
		*s = ListtransactionsTransactionsOutputsType_ChannelMutualClose
	case "channel_unilateral_close":
		*s = ListtransactionsTransactionsOutputsType_ChannelUnilateralClose
	case "channel_sweep":
		*s = ListtransactionsTransactionsOutputsType_ChannelSweep
	case "channel_htlc_success":
		*s = ListtransactionsTransactionsOutputsType_ChannelHtlcSuccess
	case "channel_htlc_timeout":
		*s = ListtransactionsTransactionsOutputsType_ChannelHtlcTimeout
	case "channel_penalty":
		*s = ListtransactionsTransactionsOutputsType_ChannelPenalty
	case "channel_unilateral_cheat":
		*s = ListtransactionsTransactionsOutputsType_ChannelUnilateralCheat
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s ListtransactionsTransactionsOutputsType) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *ListtransactionsTransactionsOutputsType) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type ListtransactionsTransactionsOutputs struct{
	// Required field: the 0-based output number.
	Index uint32 `json:"index"`
	// Required field: the amount of the output.
	AmountMsat Amount `json:"amount_msat"`
	// Required field: the scriptPubKey.
	ScriptPubKey string `json:"script_pub_key"`
	// Optional field
	ItemType ListtransactionsTransactionsOutputsType `json:"type"`
	// Optional field: the channel this output is associated with (*EXPERIMENTAL_FEATURES* only).
	Channel ShortChannelId `json:"channel"`
}

type ListtransactionsTransactions struct{
	// Required field: the transaction id.
	Hash string `json:"hash"`
	// Required field: the raw transaction.
	Rawtx string `json:"rawtx"`
	// Required field: the block height of this tx.
	Blockheight uint32 `json:"blockheight"`
	// Required field: the transaction number within the block.
	Txindex uint32 `json:"txindex"`
	// Required field: The nLocktime for this tx.
	Locktime uint32 `json:"locktime"`
	// Required field: The nVersion for this tx.
	Version uint32 `json:"version"`
	// Required field: Each input, in order.
	Inputs []ListtransactionsTransactionsInputs `json:"inputs"`
	// Required field: Each output, in order.
	Outputs []ListtransactionsTransactionsOutputs `json:"outputs"`
}

type ListtransactionsResponse struct{
	// Required field.
	Transactions []ListtransactionsTransactions `json:"transactions"`
}

type PayResponse struct{
	// Required field: the proof of payment: SHA256 of this **payment_hash**.
	PaymentPreimage string `json:"payment_preimage"`
	// Optional field: the final destination of the payment.
	Destination string `json:"destination"`
	// Required field: the hash of the *payment_preimage* which will prove payment.
	PaymentHash string `json:"payment_hash"`
	// Required field: the UNIX timestamp showing when this payment was initiated.
	CreatedAt float64 `json:"created_at"`
	// Required field: how many attempts this took.
	Parts uint32 `json:"parts"`
	// Required field: Amount the recipient received.
	AmountMsat Amount `json:"amount_msat"`
	// Required field: Total amount we sent (including fees).
	AmountSentMsat Amount `json:"amount_sent_msat"`
	// Optional field: Not all parts of a multi-part payment have completed.
	WarningPartialCompletion string `json:"warning_partial_completion"`
	// Required field
	Status PayStatus `json:"status"`
}

// ListnodesNodesAddressesType, Type of connection.
type ListnodesNodesAddressesType int

const (
	ListnodesNodesAddressesType_Dns ListnodesNodesAddressesType = iota
	ListnodesNodesAddressesType_Ipv4
	ListnodesNodesAddressesType_Ipv6
	ListnodesNodesAddressesType_Torv2
	ListnodesNodesAddressesType_Torv3
	ListnodesNodesAddressesType_Websocket
)

func (s ListnodesNodesAddressesType) String() (string, error) {
	switch s {
	case ListnodesNodesAddressesType_Dns:
		return "dns", nil
	case ListnodesNodesAddressesType_Ipv4:
		return "ipv4", nil
	case ListnodesNodesAddressesType_Ipv6:
		return "ipv6", nil
	case ListnodesNodesAddressesType_Torv2:
		return "torv2", nil
	case ListnodesNodesAddressesType_Torv3:
		return "torv3", nil
	case ListnodesNodesAddressesType_Websocket:
		return "websocket", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *ListnodesNodesAddressesType) FromString(p string) error {
	switch p {
	case "dns":
		*s = ListnodesNodesAddressesType_Dns
	case "ipv4":
		*s = ListnodesNodesAddressesType_Ipv4
	case "ipv6":
		*s = ListnodesNodesAddressesType_Ipv6
	case "torv2":
		*s = ListnodesNodesAddressesType_Torv2
	case "torv3":
		*s = ListnodesNodesAddressesType_Torv3
	case "websocket":
		*s = ListnodesNodesAddressesType_Websocket
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s ListnodesNodesAddressesType) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *ListnodesNodesAddressesType) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type ListnodesNodesAddresses struct{
	// Required field
	ItemType ListnodesNodesAddressesType `json:"type"`
	// Required field: port number.
	Port uint16 `json:"port"`
	// Optional field: address in expected format for **type**.
	Address string `json:"address"`
}

type ListnodesNodes struct{
	// Required field: the public key of the node.
	Nodeid string `json:"nodeid"`
	// Optional field: A node_announcement has been received for this node (UNIX timestamp).
	LastTimestamp uint32 `json:"last_timestamp"`
	// Optional field: The fun alias this node advertized.
	Alias string `json:"alias"`
	// Optional field: The favorite RGB color this node advertized.
	Color string `json:"color"`
	// Optional field: BOLT #9 features bitmap this node advertized.
	Features string `json:"features"`
	// Optional field: The addresses this node advertized.
	Addresses []ListnodesNodesAddresses `json:"addresses"`
}

type ListnodesResponse struct{
	// Required field.
	Nodes []ListnodesNodes `json:"nodes"`
}

// WaitanyinvoiceStatus, Whether it's paid or expired.
type WaitanyinvoiceStatus int

const (
	WaitanyinvoiceStatus_Paid WaitanyinvoiceStatus = iota
	WaitanyinvoiceStatus_Expired
)

func (s WaitanyinvoiceStatus) String() (string, error) {
	switch s {
	case WaitanyinvoiceStatus_Paid:
		return "paid", nil
	case WaitanyinvoiceStatus_Expired:
		return "expired", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *WaitanyinvoiceStatus) FromString(p string) error {
	switch p {
	case "paid":
		*s = WaitanyinvoiceStatus_Paid
	case "expired":
		*s = WaitanyinvoiceStatus_Expired
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s WaitanyinvoiceStatus) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *WaitanyinvoiceStatus) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type WaitanyinvoiceResponse struct{
	// Required field: unique label supplied at invoice creation.
	Label string `json:"label"`
	// Required field: description used in the invoice.
	Description string `json:"description"`
	// Required field: the hash of the *payment_preimage* which will prove payment.
	PaymentHash string `json:"payment_hash"`
	// Required field
	Status WaitanyinvoiceStatus `json:"status"`
	// Required field: UNIX timestamp of when it will become / became unpayable.
	ExpiresAt uint64 `json:"expires_at"`
	// Optional field: the amount required to pay this invoice.
	AmountMsat Amount `json:"amount_msat"`
	// Optional field: the BOLT11 string (always present unless *bolt12* is).
	Bolt11 string `json:"bolt11"`
	// Optional field: the BOLT12 string (always present unless *bolt11* is).
	Bolt12 string `json:"bolt12"`
	// Optional field: Unique incrementing index for this payment.
	PayIndex uint64 `json:"pay_index"`
	// Optional field: the amount actually received (could be slightly greater than *amount_msat*, since clients may overpay).
	AmountReceivedMsat Amount `json:"amount_received_msat"`
	// Optional field: UNIX timestamp of when it was paid.
	PaidAt uint64 `json:"paid_at"`
	// Optional field: proof of payment.
	PaymentPreimage string `json:"payment_preimage"`
}

// WaitinvoiceStatus, Whether it's paid or expired.
type WaitinvoiceStatus int

const (
	WaitinvoiceStatus_Paid WaitinvoiceStatus = iota
	WaitinvoiceStatus_Expired
)

func (s WaitinvoiceStatus) String() (string, error) {
	switch s {
	case WaitinvoiceStatus_Paid:
		return "paid", nil
	case WaitinvoiceStatus_Expired:
		return "expired", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *WaitinvoiceStatus) FromString(p string) error {
	switch p {
	case "paid":
		*s = WaitinvoiceStatus_Paid
	case "expired":
		*s = WaitinvoiceStatus_Expired
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s WaitinvoiceStatus) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *WaitinvoiceStatus) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type WaitinvoiceResponse struct{
	// Required field: unique label supplied at invoice creation.
	Label string `json:"label"`
	// Required field: description used in the invoice.
	Description string `json:"description"`
	// Required field: the hash of the *payment_preimage* which will prove payment.
	PaymentHash string `json:"payment_hash"`
	// Required field
	Status WaitinvoiceStatus `json:"status"`
	// Required field: UNIX timestamp of when it will become / became unpayable.
	ExpiresAt uint64 `json:"expires_at"`
	// Optional field: the amount required to pay this invoice.
	AmountMsat Amount `json:"amount_msat"`
	// Optional field: the BOLT11 string (always present unless *bolt12* is).
	Bolt11 string `json:"bolt11"`
	// Optional field: the BOLT12 string (always present unless *bolt11* is).
	Bolt12 string `json:"bolt12"`
	// Optional field: Unique incrementing index for this payment.
	PayIndex uint64 `json:"pay_index"`
	// Optional field: the amount actually received (could be slightly greater than *amount_msat*, since clients may overpay).
	AmountReceivedMsat Amount `json:"amount_received_msat"`
	// Optional field: UNIX timestamp of when it was paid.
	PaidAt uint64 `json:"paid_at"`
	// Optional field: proof of payment.
	PaymentPreimage string `json:"payment_preimage"`
}

type WaitsendpayResponse struct{
	// Required field: unique ID for this payment attempt.
	Id uint64 `json:"id"`
	// Optional field: Grouping key to disambiguate multiple attempts to pay an invoice or the same payment_hash.
	Groupid uint64 `json:"groupid"`
	// Required field: the hash of the *payment_preimage* which will prove payment.
	PaymentHash string `json:"payment_hash"`
	// Required field
	Status PayStatus `json:"status"`
	// Optional field: The amount delivered to destination (if known).
	AmountMsat Amount `json:"amount_msat"`
	// Optional field: the final destination of the payment if known.
	Destination string `json:"destination"`
	// Required field: the UNIX timestamp showing when this payment was initiated.
	CreatedAt uint64 `json:"created_at"`
	// Optional field: the UNIX timestamp showing when this payment was completed.
	CompletedAt float64 `json:"completed_at"`
	// Required field: The amount sent.
	AmountSentMsat Amount `json:"amount_sent_msat"`
	// Optional field: the label, if given to sendpay.
	Label string `json:"label"`
	// Optional field: the *partid*, if given to sendpay.
	Partid uint64 `json:"partid"`
	// Optional field: the bolt11 string (if pay supplied one).
	Bolt11 string `json:"bolt11"`
	// Optional field: the bolt12 string (if supplied for pay: **experimental-offers** only)..
	Bolt12 string `json:"bolt12"`
	// Optional field: the proof of payment: SHA256 of this **payment_hash**.
	PaymentPreimage string `json:"payment_preimage"`
}

type NewaddrResponse struct{
	// Optional field: The bech32 (native segwit) address.
	Bech32 string `json:"bech32"`
	// Deprecated: This field has been deprecated in v23.02
	// Optional field: The p2sh-wrapped address.
	P2shSegwit string `json:"p2sh_segwit"`
}

type WithdrawResponse struct{
	// Required field: the fully signed bitcoin transaction.
	Tx string `json:"tx"`
	// Required field: the transaction id of *tx*.
	Txid string `json:"txid"`
	// Required field: the PSBT representing the unsigned transaction.
	Psbt string `json:"psbt"`
}

type KeysendResponse struct{
	// Required field: the proof of payment: SHA256 of this **payment_hash**.
	PaymentPreimage string `json:"payment_preimage"`
	// Optional field: the final destination of the payment.
	Destination string `json:"destination"`
	// Required field: the hash of the *payment_preimage* which will prove payment.
	PaymentHash string `json:"payment_hash"`
	// Required field: the UNIX timestamp showing when this payment was initiated.
	CreatedAt float64 `json:"created_at"`
	// Required field: how many attempts this took.
	Parts uint32 `json:"parts"`
	// Required field: Amount the recipient received.
	AmountMsat Amount `json:"amount_msat"`
	// Required field: Total amount we sent (including fees).
	AmountSentMsat Amount `json:"amount_sent_msat"`
	// Optional field: Not all parts of a multi-part payment have completed.
	WarningPartialCompletion string `json:"warning_partial_completion"`
	// Required field
	Status PayStatus `json:"status"`
}

type FundpsbtReservations struct{
	// Required field: The txid of the transaction.
	Txid string `json:"txid"`
	// Required field: The 0-based output number.
	Vout uint32 `json:"vout"`
	// Required field: Whether this output was previously reserved.
	WasReserved bool `json:"was_reserved"`
	// Required field: Whether this output is now reserved.
	Reserved bool `json:"reserved"`
	// Required field: The blockheight the reservation will expire.
	ReservedToBlock uint32 `json:"reserved_to_block"`
}

type FundpsbtResponse struct{
	// Required field: Unsigned PSBT which fulfills the parameters given.
	Psbt string `json:"psbt"`
	// Required field: The feerate used to create the PSBT, in satoshis-per-kiloweight.
	FeeratePerKw uint32 `json:"feerate_per_kw"`
	// Required field: The estimated weight of the transaction once fully signed.
	EstimatedFinalWeight uint32 `json:"estimated_final_weight"`
	// Required field: The amount above *satoshi* which is available.  This could be zero, or dust; it will be zero if *change_outnum* is also returned.
	ExcessMsat Amount `json:"excess_msat"`
	// Optional field: The 0-based output number where change was placed (only if parameter *excess_as_change* was true and there was sufficient funds).
	ChangeOutnum uint32 `json:"change_outnum"`
	// Optional field: If *reserve* was true or a non-zero number, just as per lightning-reserveinputs(7).
	Reservations []FundpsbtReservations `json:"reservations"`
}

type SendpsbtResponse struct{
	// Required field: The raw transaction which was sent.
	Tx string `json:"tx"`
	// Required field: The txid of the **tx**.
	Txid string `json:"txid"`
}

type SignpsbtResponse struct{
	// Required field: The fully signed PSBT.
	SignedPsbt string `json:"signed_psbt"`
}

type UtxopsbtReservations struct{
	// Required field: The txid of the transaction.
	Txid string `json:"txid"`
	// Required field: The 0-based output number.
	Vout uint32 `json:"vout"`
	// Required field: Whether this output was previously reserved.
	WasReserved bool `json:"was_reserved"`
	// Required field: Whether this output is now reserved.
	Reserved bool `json:"reserved"`
	// Required field: The blockheight the reservation will expire.
	ReservedToBlock uint32 `json:"reserved_to_block"`
}

type UtxopsbtResponse struct{
	// Required field: Unsigned PSBT which fulfills the parameters given.
	Psbt string `json:"psbt"`
	// Required field: The feerate used to create the PSBT, in satoshis-per-kiloweight.
	FeeratePerKw uint32 `json:"feerate_per_kw"`
	// Required field: The estimated weight of the transaction once fully signed.
	EstimatedFinalWeight uint32 `json:"estimated_final_weight"`
	// Required field: The amount above *satoshi* which is available.  This could be zero, or dust; it will be zero if *change_outnum* is also returned.
	ExcessMsat Amount `json:"excess_msat"`
	// Optional field: The 0-based output number where change was placed (only if parameter *excess_as_change* was true and there was sufficient funds).
	ChangeOutnum uint32 `json:"change_outnum"`
	// Optional field: If *reserve* was true or a non-zero number, just as per lightning-reserveinputs(7).
	Reservations []UtxopsbtReservations `json:"reservations"`
}

type TxdiscardResponse struct{
	// Required field: the unsigned transaction.
	UnsignedTx string `json:"unsigned_tx"`
	// Required field: the transaction id of *unsigned_tx*.
	Txid string `json:"txid"`
}

type TxprepareResponse struct{
	// Required field: the PSBT representing the unsigned transaction.
	Psbt string `json:"psbt"`
	// Required field: the unsigned transaction.
	UnsignedTx string `json:"unsigned_tx"`
	// Required field: the transaction id of *unsigned_tx*; you hand this to lightning-txsend(7) or lightning-txdiscard(7), as the inputs of this transaction are reserved..
	Txid string `json:"txid"`
}

type TxsendResponse struct{
	// Required field: the completed PSBT representing the signed transaction.
	Psbt string `json:"psbt"`
	// Required field: the fully signed transaction.
	Tx string `json:"tx"`
	// Required field: the transaction id of *tx*.
	Txid string `json:"txid"`
}

type DisconnectResponse struct{
}

type FeeratesPerkb struct{
	// Required field: The smallest feerate that you can use, usually the minimum relayed feerate of the backend.
	MinAcceptable uint32 `json:"min_acceptable"`
	// Required field: The largest feerate we will accept from remote negotiations.  If a peer attempts to set the feerate higher than this we will unilaterally close the channel (or simply forget it if it's not open yet)..
	MaxAcceptable uint32 `json:"max_acceptable"`
	// Optional field: Default feerate for lightning-fundchannel(7) and lightning-withdraw(7).
	Opening uint32 `json:"opening"`
	// Optional field: Feerate to aim for in cooperative shutdown.  Note that since mutual close is a **negotiation**, the actual feerate used in mutual close will be somewhere between this and the corresponding mutual close feerate of the peer..
	MutualClose uint32 `json:"mutual_close"`
	// Optional field: Feerate for commitment_transaction in a live channel which we originally funded.
	UnilateralClose uint32 `json:"unilateral_close"`
	// Optional field: Feerate for returning unilateral close funds to our wallet.
	DelayedToUs uint32 `json:"delayed_to_us"`
	// Optional field: Feerate for returning unilateral close HTLC outputs to our wallet.
	HtlcResolution uint32 `json:"htlc_resolution"`
	// Optional field: Feerate to start at when penalizing a cheat attempt.
	Penalty uint32 `json:"penalty"`
}

type FeeratesPerkw struct{
	// Required field: The smallest feerate that you can use, usually the minimum relayed feerate of the backend.
	MinAcceptable uint32 `json:"min_acceptable"`
	// Required field: The largest feerate we will accept from remote negotiations.  If a peer attempts to set the feerate higher than this we will unilaterally close the channel (or simply forget it if it's not open yet)..
	MaxAcceptable uint32 `json:"max_acceptable"`
	// Optional field: Default feerate for lightning-fundchannel(7) and lightning-withdraw(7).
	Opening uint32 `json:"opening"`
	// Optional field: Feerate to aim for in cooperative shutdown.  Note that since mutual close is a **negotiation**, the actual feerate used in mutual close will be somewhere between this and the corresponding mutual close feerate of the peer..
	MutualClose uint32 `json:"mutual_close"`
	// Optional field: Feerate for commitment_transaction in a live channel which we originally funded.
	UnilateralClose uint32 `json:"unilateral_close"`
	// Optional field: Feerate for returning unilateral close funds to our wallet.
	DelayedToUs uint32 `json:"delayed_to_us"`
	// Optional field: Feerate for returning unilateral close HTLC outputs to our wallet.
	HtlcResolution uint32 `json:"htlc_resolution"`
	// Optional field: Feerate to start at when penalizing a cheat attempt.
	Penalty uint32 `json:"penalty"`
}

type FeeratesOnchain_fee_estimates struct{
	// Required field: Estimated cost of typical channel open.
	OpeningChannelSatoshis uint64 `json:"opening_channel_satoshis"`
	// Required field: Estimated cost of typical channel close.
	MutualCloseSatoshis uint64 `json:"mutual_close_satoshis"`
	// Required field: Estimated cost of typical unilateral close (without HTLCs).
	UnilateralCloseSatoshis uint64 `json:"unilateral_close_satoshis"`
	// Required field: Estimated cost of typical HTLC timeout transaction.
	HtlcTimeoutSatoshis uint64 `json:"htlc_timeout_satoshis"`
	// Required field: Estimated cost of typical HTLC fulfillment transaction.
	HtlcSuccessSatoshis uint64 `json:"htlc_success_satoshis"`
}

type FeeratesResponse struct{
	// Optional field: Some fee estimates are missing.
	WarningMissingFeerates string `json:"warning_missing_feerates"`
	// Optional field
	Perkb FeeratesPerkb `json:"perkb"`
	// Optional field
	Perkw FeeratesPerkw `json:"perkw"`
	// Optional field
	OnchainFeeEstimates FeeratesOnchain_fee_estimates `json:"onchain_fee_estimates"`
}

type FundchannelResponse struct{
	// Required field: The raw transaction which funded the channel.
	Tx string `json:"tx"`
	// Required field: The txid of the transaction which funded the channel.
	Txid string `json:"txid"`
	// Required field: The 0-based output index showing which output funded the channel.
	Outnum uint32 `json:"outnum"`
	// Required field: The channel_id of the resulting channel.
	ChannelId string `json:"channel_id"`
	// Optional field: The raw scriptPubkey which mutual close will go to; only present if *close_to* parameter was specified and peer supports `option_upfront_shutdown_script`.
	CloseTo string `json:"close_to"`
	// Optional field: Number of confirmations before we consider the channel active..
	Mindepth uint32 `json:"mindepth"`
}

// GetrouteRouteStyle, The features understood by the destination node.
type GetrouteRouteStyle int

const (
	GetrouteRouteStyle_Tlv GetrouteRouteStyle = iota
)

func (s GetrouteRouteStyle) String() (string, error) {
	switch s {
	case GetrouteRouteStyle_Tlv:
		return "tlv", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *GetrouteRouteStyle) FromString(p string) error {
	switch p {
	case "tlv":
		*s = GetrouteRouteStyle_Tlv
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s GetrouteRouteStyle) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *GetrouteRouteStyle) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type GetrouteRoute struct{
	// Required field: The node at the end of this hop.
	Id string `json:"id"`
	// Required field: The channel joining these nodes.
	Channel ShortChannelId `json:"channel"`
	// Required field: 0 if this channel is traversed from lesser to greater **id**, otherwise 1.
	Direction uint32 `json:"direction"`
	// Required field: The amount expected by the node at the end of this hop.
	AmountMsat Amount `json:"amount_msat"`
	// Required field: The total CLTV expected by the node at the end of this hop.
	Delay uint32 `json:"delay"`
	// Required field
	Style GetrouteRouteStyle `json:"style"`
}

type GetrouteResponse struct{
	// Required field.
	Route []GetrouteRoute `json:"route"`
}

// ListforwardsForwardsStatus, still ongoing, completed, failed locally, or failed after forwarding.
type ListforwardsForwardsStatus int

const (
	ListforwardsForwardsStatus_Offered ListforwardsForwardsStatus = iota
	ListforwardsForwardsStatus_Settled
	ListforwardsForwardsStatus_LocalFailed
	ListforwardsForwardsStatus_Failed
)

func (s ListforwardsForwardsStatus) String() (string, error) {
	switch s {
	case ListforwardsForwardsStatus_Offered:
		return "offered", nil
	case ListforwardsForwardsStatus_Settled:
		return "settled", nil
	case ListforwardsForwardsStatus_LocalFailed:
		return "local_failed", nil
	case ListforwardsForwardsStatus_Failed:
		return "failed", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *ListforwardsForwardsStatus) FromString(p string) error {
	switch p {
	case "offered":
		*s = ListforwardsForwardsStatus_Offered
	case "settled":
		*s = ListforwardsForwardsStatus_Settled
	case "local_failed":
		*s = ListforwardsForwardsStatus_LocalFailed
	case "failed":
		*s = ListforwardsForwardsStatus_Failed
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s ListforwardsForwardsStatus) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *ListforwardsForwardsStatus) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

// ListforwardsForwardsStyle, Either a legacy onion format or a modern tlv format.
type ListforwardsForwardsStyle int

const (
	ListforwardsForwardsStyle_Legacy ListforwardsForwardsStyle = iota
	ListforwardsForwardsStyle_Tlv
)

func (s ListforwardsForwardsStyle) String() (string, error) {
	switch s {
	case ListforwardsForwardsStyle_Legacy:
		return "legacy", nil
	case ListforwardsForwardsStyle_Tlv:
		return "tlv", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *ListforwardsForwardsStyle) FromString(p string) error {
	switch p {
	case "legacy":
		*s = ListforwardsForwardsStyle_Legacy
	case "tlv":
		*s = ListforwardsForwardsStyle_Tlv
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s ListforwardsForwardsStyle) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *ListforwardsForwardsStyle) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type ListforwardsForwards struct{
	// Required field: the channel that received the HTLC.
	InChannel ShortChannelId `json:"in_channel"`
	// Optional field: the unique HTLC id the sender gave this (not present if incoming channel was closed before ugprade to v22.11).
	InHtlcId uint64 `json:"in_htlc_id"`
	// Required field: the value of the incoming HTLC.
	InMsat Amount `json:"in_msat"`
	// Required field
	Status ListforwardsForwardsStatus `json:"status"`
	// Required field: the UNIX timestamp when this was received.
	ReceivedTime float64 `json:"received_time"`
	// Optional field: the channel that the HTLC (trying to) forward to.
	OutChannel ShortChannelId `json:"out_channel"`
	// Optional field: the unique HTLC id we gave this when sending (may be missing even if out_channel is present, for old forwards before v22.11).
	OutHtlcId uint64 `json:"out_htlc_id"`
	// Optional field
	Style ListforwardsForwardsStyle `json:"style"`
	// Optional field: the amount this paid in fees.
	FeeMsat Amount `json:"fee_msat"`
	// Optional field: the amount we sent out the *out_channel*.
	OutMsat Amount `json:"out_msat"`
}

type ListforwardsResponse struct{
	// Required field.
	Forwards []ListforwardsForwards `json:"forwards"`
}

// ListpaysPaysStatus, status of the payment.
type ListpaysPaysStatus int

const (
	ListpaysPaysStatus_Pending ListpaysPaysStatus = iota
	ListpaysPaysStatus_Failed
	ListpaysPaysStatus_Complete
)

func (s ListpaysPaysStatus) String() (string, error) {
	switch s {
	case ListpaysPaysStatus_Pending:
		return "pending", nil
	case ListpaysPaysStatus_Failed:
		return "failed", nil
	case ListpaysPaysStatus_Complete:
		return "complete", nil
	default:
		return "", fmt.Errorf("enum type not found")
	}
}

func (s *ListpaysPaysStatus) FromString(p string) error {
	switch p {
	case "pending":
		*s = ListpaysPaysStatus_Pending
	case "failed":
		*s = ListpaysPaysStatus_Failed
	case "complete":
		*s = ListpaysPaysStatus_Complete
	default:
		return fmt.Errorf("enum type not found")
	}
	return nil
}

func (s ListpaysPaysStatus) MarshalJSON() ([]byte, error) {
	str, err := s.String()
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func (s *ListpaysPaysStatus) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	err = s.FromString(j)
	if err != nil {
		return err
	}
	return nil
}

type ListpaysPays struct{
	// Required field: the hash of the *payment_preimage* which will prove payment.
	PaymentHash string `json:"payment_hash"`
	// Required field
	Status ListpaysPaysStatus `json:"status"`
	// Optional field: the final destination of the payment if known.
	Destination string `json:"destination"`
	// Required field: the UNIX timestamp showing when this payment was initiated.
	CreatedAt uint64 `json:"created_at"`
	// Optional field: the UNIX timestamp showing when this payment was completed.
	CompletedAt uint64 `json:"completed_at"`
	// Optional field: the label, if given to sendpay.
	Label string `json:"label"`
	// Optional field: the bolt11 string (if pay supplied one).
	Bolt11 string `json:"bolt11"`
	// Optional field: the description matching the bolt11 description hash (if pay supplied one).
	Description string `json:"description"`
	// Optional field: the bolt12 string (if supplied for pay: **experimental-offers** only)..
	Bolt12 string `json:"bolt12"`
	// Optional field: proof of payment.
	Preimage string `json:"preimage"`
	// Optional field: the number of parts for a successful payment (only if more than one)..
	NumberOfParts uint64 `json:"number_of_parts"`
	// Optional field: the error onion returned on failure, if any..
	Erroronion string `json:"erroronion"`
}

type ListpaysResponse struct{
	// Required field.
	Pays []ListpaysPays `json:"pays"`
}

type PingResponse struct{
	// Required field: the answer length of the reply message (including header: 0 means no reply expected).
	Totlen uint16 `json:"totlen"`
}

type SendcustommsgResponse struct{
	// Required field: Information about where message was queued.
	Status string `json:"status"`
}

type SetchannelChannels struct{
	// Required field: The node_id of the peer.
	PeerId string `json:"peer_id"`
	// Required field: The channel_id of the channel.
	ChannelId string `json:"channel_id"`
	// Optional field: the short_channel_id (if locked in).
	ShortChannelId ShortChannelId `json:"short_channel_id"`
	// Required field: The resulting feebase (this is the BOLT #7 name).
	FeeBaseMsat Amount `json:"fee_base_msat"`
	// Required field: The resulting feeppm (this is the BOLT #7 name).
	FeeProportionalMillionths uint32 `json:"fee_proportional_millionths"`
	// Required field: The resulting htlcmin we will advertize (the BOLT #7 name is htlc_minimum_msat).
	MinimumHtlcOutMsat Amount `json:"minimum_htlc_out_msat"`
	// Optional field: The requested htlcmin was too low for this peer, so we set it to the minimum they will allow.
	WarningHtlcminTooLow string `json:"warning_htlcmin_too_low"`
	// Required field: The resulting htlcmax we will advertize (the BOLT #7 name is htlc_maximum_msat).
	MaximumHtlcOutMsat Amount `json:"maximum_htlc_out_msat"`
	// Optional field: The requested htlcmax was greater than the channel capacity, so we set it to the channel capacity.
	WarningHtlcmaxTooHigh string `json:"warning_htlcmax_too_high"`
}

type SetchannelResponse struct{
	// Required field: channel(s) set, and their resulting configuration.
	Channels []SetchannelChannels `json:"channels"`
}

type SigninvoiceResponse struct{
	// Required field: the bolt11 string.
	Bolt11 string `json:"bolt11"`
}

type SignmessageResponse struct{
	// Required field: The signature.
	Signature string `json:"signature"`
	// Required field: The recovery id (0, 1, 2 or 3).
	Recid string `json:"recid"`
	// Required field: *signature* and *recid* encoded in a style compatible with **lnd**'s [SignMessageRequest](https://api.lightning.community/#grpc-request-signmessagerequest).
	Zbase string `json:"zbase"`
}

type StopResponse struct{
}

