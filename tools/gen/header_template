/* This file was generated by generate-bolts.py */
/* Do not modify this file! Modify the _csv file it was generated from. */
/* Original template can be found at tools/gen/header_template */

#ifndef LIGHTNING_${idem}
#define LIGHTNING_${idem}
#include <ccan/tal/tal.h>
#include <wire/wire.h>
% for i in includes:
${i}
% endfor

## Enum sets for wire messages & tlvs
% for enum_set in enum_sets:
enum ${enum_set['name']} {
    % for msg in enum_set['set']:
        % for comment in msg.msg_comments:
        /* ${comment} */
        % endfor
        ${msg.enum_name()} = ${msg.number},
    % endfor
};

%endfor
## The 'name' functions for the enums
% for enum_set in enum_sets:
const char *${enum_set['name']}_name(int e);
% endfor

## Structs for subtypes + tlv messages
% for struct in structs:
struct ${struct.struct_name()} {
        % for f in struct.fields.values():
            % for c in f.field_comments:
        /* ${c} */
            % endfor
        % if bool(f.len_field_of):
<% continue %>
        % endif
            % if f.has_len_field():
        ${f.type_obj.type_name()} *${f.name};
            % elif f.is_array():
        ${f.type_obj.type_name()} ${f.name}[${f.count}];
            % else:
        ${f.type_obj.type_name()} ${f.name};
            % endif
        % endfor
};
% endfor
## Structs for TLV types!
% for tlv in tlvs:
struct ${tlv.name} {
    % for msg_name in tlv.messages.keys():
        struct ${tlv.name}_${msg_name} *${msg_name};
    % endfor
};
% endfor

% if options.expose_subtypes and bool(subtypes):
% for subtype in subtypes:
/* SUBTYPE: ${subtype.name.upper()} */
void towire_${subtype.name}(u8 **p, const struct ${subtype.name} *${subtype.name});
bool fromwire_${subtype.name}(${'const tal_t *ctx, ' if subtype.has_len_fields() else '' }const u8 **cursor, size_t *plen, struct ${subtype.name} *${subtype.name});
    % for c in subtype.type_comments:
/* ${c} */
    % endfor

% endfor
% endif
% for msg in messages:
/* WIRE: ${msg.name.upper()} */
    % for c in msg.msg_comments:
/* ${c} */
    % endfor
u8 *towire_${msg.name}(const tal_t *ctx${''.join([f.arg_desc_to() for f in msg.fields.values() if not f.is_optional])});
bool fromwire_${msg.name}(${'const tal_t *ctx, ' if msg.has_len_fields() else ''}const void *p${''.join([f.arg_desc_from() for f in msg.fields.values() if not f.is_optional])});

% endfor
#endif /* LIGHTNING_${idem} */
