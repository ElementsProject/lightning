/* This file was generated by generate-wire.py */
/* Do not modify this file! Modify the .csv file it was generated from. */

#include <${header_filename}>
#include <ccan/array_size/array_size.h>
#include <ccan/mem/mem.h>
#include <ccan/tal/str/str.h>
#include <common/utils.h>
#include <inttypes.h>
#include <stdio.h>
% for i in includes:
${i}
% endfor

% if enum_sets:
bool print${options.enum_name}_message(const u8 *msg)
{
	switch ((enum ${options.enum_name})fromwire_peektype(msg)) {
% for msg in enum_sets[0]['set']:
		case ${msg.enum_name()}:
			printf("${msg.enum_name()}:\n");
			return printwire_${msg.name}("${msg.name}", msg);
% endfor
	}

	printf("UNKNOWN: %s\\n", tal_hex(msg, msg));
	return false;
}
% endif

## 'component' for 'truncate check 
<%def name="truncate_check()">
	if (!*cursor) {
		printf("**TRUNCATED**\n");
		return false;
	}
</%def> \
## definition for printing field sets
<%def name="print_fieldset(fields)">
% for f in fields:
    % if f.is_extension():
	if (*plen == 0)
		return true;
	printf("(${','.join(f.extension_names)}):");
    % endif
    % if f.len_field_of:
	${f.type_obj.type_name()} ${f.name} = fromwire_${f.type_obj.name}(cursor, plen);${truncate_check()} <% continue %> \
    % endif	
	printf("${f.name}=");
    % if f.type_obj.is_tlv():
	printwire_${f.type_obj.tlv.name}(tal_fmt(NULL, "%s.${f.name}", fieldname), cursor, plen);
    % elif f.is_array() or f.is_varlen():
	% if f.type_obj.has_array_helper():
	printwire_${f.type_obj.name}_array(tal_fmt(NULL, "%s.${f.name}", fieldname), cursor, plen, ${f.size('*plen')});
	% else:
	printf("[");
            % if f.is_implicit_len():
	while (*plen) {
	    % else:
	for (size_t i = 0; i < ${f.size()}; i++) {
	    % endif
		if (!printwire_${f.type_obj.name}(tal_fmt(NULL, "%s.${f.name}", fieldname), cursor, plen))
			return false;
	}
	printf("]");
	% endif
    % else:
	if (!printwire_${f.type_obj.name}(tal_fmt(NULL, "%s.${f.name}", fieldname), cursor, plen))
		return false;
    % endif
% endfor
</%def> \
## Definitions for 'subtypes'
% for subtype in subtypes:

<%
    static = '' if options.expose_subtypes else 'static '
%>\
${static}bool printwire_${subtype.name}(const char *fieldname, const u8 **cursor, size_t *plen)
{
	${print_fieldset(subtype.fields.values())}
	return true;
}
% endfor
% for tlv in tlvs.values():

    % for msg in tlv.messages.values():
static bool printwire_${msg.struct_name()}(const char *fieldname, const u8 **cursor, size_t *plen)
{
	printf("(msg_name=%s)\n", "${msg.name}");
	${print_fieldset(msg.fields.values())}
	return true;
}
    % endfor

static const struct tlv_print_record_type print_tlvs_${tlv.name}[] = {
    % for msg in tlv.messages.values():
	{ ${msg.number}, printwire_${msg.struct_name()} },
    % endfor
};
% endfor
% for msg in messages:
bool printwire_${msg.name}(const char *fieldname, const u8 *msg)
{
	size_t msglen = tal_count(msg);
	const u8 **cursor = &msg;
	size_t *plen = &msglen;

	if (fromwire_u16(cursor, plen) != ${msg.enum_name()}) {
		printf("WRONG TYPE?!\n");
		return false;
	}
${print_fieldset(msg.fields.values())}

## Length check
	if (*plen != 0)
		printf("EXTRA: %s\n", tal_hexstr(NULL, *cursor, *plen));
	return *cursor != NULL;
}
% endfor

% for tlv in tlvs.values():
bool printwire_${tlv.name}(const char *fieldname, const u8 **cursor, size_t *plen)
{
	return printwire_tlvs(fieldname, cursor, plen, print_tlvs_${tlv.name}, ARRAY_SIZE(print_tlvs_${tlv.name}));
}
% endfor

const struct tlv_print${options.enum_name}_byname tlvs_print${options.enum_name}_byname[] = {
    % for tlv in tlvs.values():
	{ "${tlv.name}", printwire_${tlv.name} },
    % endfor
	{ NULL, NULL }        
};
