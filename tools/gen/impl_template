/* This file was generated by generate-bolts.py */
/* Do not modify this file! Modify the _csv file it was generated from. */
/* Original template can be found at tools/gen/impl_template */

#include <${header_filename}>
#include <ccan/mem/mem.h>
#include <ccan/tal/str/str.h>
#include <stdio.h>

% for enum_set in enum_sets:
const char *${enum_set['name']}_name(int e)
{
	static char invalidbuf[sizeof("INVALID ") + STR_MAX_CHARS(e)];

	switch ((enum ${enum_set['name']})e) {
    % for msg in enum_set['set']:
	case ${msg.enum_name()}: return "${msg.enum_name()}";
    % endfor
	}

	snprintf(invalidbuf, sizeof(invalidbuf), "INVALID %i", e);
	return invalidbuf;
}

% endfor

## FIXME: extract out partials for the method declarations
## (shared between here and header_template)
% for subtype in subtypes:
/* SUBTYPE: ${subtype.name.upper()} */
<% static = '' if options.expose_subtypes else 'static ' %>
${static}void towire_${subtype.name}(u8 **p, const struct ${subtype.name} *${subtype.name})
{
	% for f in subtype.get_len_fields():
	${f.type_obj.type_name()} ${f.name} = tal_count(${subtype.name}->${f.len_field_of});
	% endfor

## FIXME: abstract this out? (semi-shared with towire_msg, minus the optional bits)
	% for f in subtype.fields.values():
## FIXME: add field level comments
<%
    fieldname = '{}->{}'.format(subtype.name,f.name)
%> \
	% if f.is_array() or f.has_len_field(): ## multiples?
	    % if f.type_obj.has_array_helper():
	towire_${f.type_obj.name}_array(&p, ${fieldname}, ${f.size()});
	    % else:
	for (size_t i = 0; i < ${f.size()}; i++)
		% if f.type_obj.is_assignable() or f.type_obj.has_len_fields():
		towire_${f.type_obj.name}(p, ${fieldname}[i]);
		% else:
		towire_${f.type_obj.name}(p, ${fieldname} + i);
		% endif
	    % endif
	% elif f.len_field_of:
	towire_${f.type_obj.name}(p, ${f.name});
	% else:
	towire_${f.type_obj.name}(&p, ${'' if f.type_obj.is_assignable() else '*'}${fieldname});
	% endif
	% endfor
}
${static}bool fromwire_${subtype.name}(${'const tal_t *ctx, ' if subtype.has_len_fields() else '' }const u8 **cursor, size_t *plen, struct ${subtype.name} *${subtype.name})
{
	## Length field declarations
	% for f in subtype.get_len_fields():
	${f.type_obj.type_name()} ${f.name};
	% endfor

## FIXME: field level comments
	% for f in subtype.fields.values():
<%
    fieldname = '{}->{}'.format(subtype.name,f.name)
    typename = f.type_obj.type_name()
    type_ = f.type_obj.name
%> \
	% if f.has_len_field():
	${fieldname} = ${f.len_field} ? tal_arr(ctx, ${typename}${' *' if f.type_obj.has_len_fields() else ''}, ${f.len_field}) : NULL;
	% endif
<%
    if f.is_array():
	fieldname = '*' + fieldname
	ctx = 'ctx'
    else:
	ctx = fieldname
%> \
	% if f.is_array() or f.has_len_field():
	    % if f.type_obj.has_array_helper():
	fromwire_${type_}_array(cursor, plen, ${fieldname}, ${f.size()});
	    % else:
	for (size_t i = 0; i < ${f.size()}; i++)
		% if f.type_obj.is_assignable():
		(${fieldname})[i] = fromwire_${type_}(cursor, plen);
		% elif f.has_len_field():
		(${fieldname})[i] = fromwire_${type_}(${ctx}, cursor, plen);
		% else:
		fromwire_${type_}(${ctx}, cursor, plen, ${fieldname} + i);
		% endif
	    % endif
	% else:
	    % if f.type_obj.is_assignable():
	${ f.name if f.len_field_of else fieldname} = fromwire_${type_}(cursor, plen);
	    % else:
	fromwire_${type_}(cursor, plen, &${fieldname});
	    % endif
	%endif
	% endfor

	return cursor != NULL;
}

% endfor
% for msg in messages:
/* WIRE: ${msg.name.upper()} */
u8 *towire_${msg.name}(const tal_t *ctx${''.join([f.arg_desc_to() for f in msg.fields.values() if not f.is_optional])})
{
## FIXME: we're ignoring TLV's rn
	% for f in msg.get_len_fields():
	${f.type_obj.type_name()} ${f.name} = tal_count(${f.len_field_of});
	% endfor
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, ${msg.enum_name()});
	% for f in msg.fields.values():
## FIXME: add field level comments
	% if f.is_array() or f.has_len_field(): ## multiples?
	    % if f.type_obj.has_array_helper():
	towire_${f.type_obj.name}_array(&p, ${f.name}, ${f.size()});
	    % else:
	for (size_t i = 0; i < ${f.size()}; i++)
		% if f.type_obj.is_assignable() or f.type_obj.has_len_fields():
		towire_${f.type_obj.name}(&p, ${f.name}[i]);
		% else:
		towire_${f.type_obj.name}(&p, ${f.name} + i);
		% endif
	    % endif
        % elif f.is_optional: ## is optional?
	if (!${f.name})
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_${f.type_obj.name}(&p, ${'*' if f.type_obj.is_assignable() else ''}${f.name});
	}
	% else: ## all other cases
	towire_${f.type_obj.name}(&p, ${f.name});
	% endif
	% endfor

	return memcheck(p, tal_count(p));
}
bool fromwire_${msg.name}(${'const tal_t *ctx, ' if msg.has_len_fields() else ''}const void *p${''.join([f.arg_desc_from() for f in msg.fields.values() if not f.is_optional])})
{
	% if msg.get_len_fields():
	    % for f in msg.get_len_fields():
	${f.type_obj.type_name()} ${f.name};
	    % endfor

	% endif
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != ${msg.enum_name()})
		return false;
## FIXME: TLV has been omitted
	% for f in msg.fields.values():
<%
	    typename = f.type_obj.type_name()
	    if f.type_obj.has_len_fields():
		typename = typename + ' *'
	    type_ = f.type_obj.name
	%> \
	% if f.has_len_field():
	// 2nd case ${f.name}
	*${f.name} = ${f.len_field} ? tal_arr(ctx, ${typename}, ${f.len_field}) : NULL;
	% endif
	% if f.len_field_of:
	${f.name} = fromwire_${type_}(&cursor, &plen);
	% elif f.is_array() or f.has_len_field():
<%
	    if f.has_len_field():
		fieldname = '*' + f.name
		ctx = fieldname
	    else:
		fieldname = f.name
		ctx = 'ctx'
	%> \
	    % if f.type_obj.has_array_helper():
	fromwire_${type_}_array(&cursor, &plen, ${fieldname}, ${f.size()});
	    % else:
	for (size_t i = 0; i < ${f.size()}; i++)
		% if f.type_obj.is_assignable():
		(${fieldname})[i] = fromwire_${type_}(&cursor, &plen);
		## FIXME: case for 'varlen' structs
		## (${fieldname})[i] = fromwire_${type_}(${ctx}, &cursor, &plen);
		% else:
		fromwire_${type_}(${ctx + ', ' if f.type_obj.is_subtype() else ''}&cursor, &plen, ${fieldname} + i);
		% endif
	    % endif
	% else:
## FIXME: leaves out optional fields + 'varlen' structs
	    %if f.type_obj.is_assignable():
	*${f.name} = fromwire_${type_}(&cursor, &plen);
	    % else:
	fromwire_${type_}(&cursor, &plen, ${f.name});
	## assignment
	    % endif
	% endif
	% endfor
	return cursor != NULL;
}

% endfor
##${func_decls}
