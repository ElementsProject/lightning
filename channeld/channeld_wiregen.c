/* This file was generated by generate-wire.py */
/* Do not modify this file! Modify the .csv file it was generated from. */
/* Original template can be found at tools/gen/impl_template */

#include <channeld/channeld_wiregen.h>
#include <assert.h>
#include <ccan/array_size/array_size.h>
#include <ccan/mem/mem.h>
#include <ccan/tal/str/str.h>
#include <common/utils.h>
#include <stdio.h>

#ifndef SUPERVERBOSE
#define SUPERVERBOSE(...)
#endif


const char *channeld_wire_name(int e)
{
	static char invalidbuf[sizeof("INVALID ") + STR_MAX_CHARS(e)];

	switch ((enum channeld_wire)e) {
	case WIRE_CHANNELD_INIT: return "WIRE_CHANNELD_INIT";
	case WIRE_CHANNELD_FUNDING_DEPTH: return "WIRE_CHANNELD_FUNDING_DEPTH";
	case WIRE_CHANNELD_OFFER_HTLC: return "WIRE_CHANNELD_OFFER_HTLC";
	case WIRE_CHANNELD_OFFER_HTLC_REPLY: return "WIRE_CHANNELD_OFFER_HTLC_REPLY";
	case WIRE_CHANNELD_FULFILL_HTLC: return "WIRE_CHANNELD_FULFILL_HTLC";
	case WIRE_CHANNELD_FAIL_HTLC: return "WIRE_CHANNELD_FAIL_HTLC";
	case WIRE_CHANNELD_GOT_FUNDING_LOCKED: return "WIRE_CHANNELD_GOT_FUNDING_LOCKED";
	case WIRE_CHANNELD_SENDING_COMMITSIG: return "WIRE_CHANNELD_SENDING_COMMITSIG";
	case WIRE_CHANNELD_SENDING_COMMITSIG_REPLY: return "WIRE_CHANNELD_SENDING_COMMITSIG_REPLY";
	case WIRE_CHANNELD_GOT_COMMITSIG: return "WIRE_CHANNELD_GOT_COMMITSIG";
	case WIRE_CHANNELD_GOT_COMMITSIG_REPLY: return "WIRE_CHANNELD_GOT_COMMITSIG_REPLY";
	case WIRE_CHANNELD_GOT_REVOKE: return "WIRE_CHANNELD_GOT_REVOKE";
	case WIRE_CHANNELD_GOT_REVOKE_REPLY: return "WIRE_CHANNELD_GOT_REVOKE_REPLY";
	case WIRE_CHANNELD_SEND_SHUTDOWN: return "WIRE_CHANNELD_SEND_SHUTDOWN";
	case WIRE_CHANNELD_GOT_SHUTDOWN: return "WIRE_CHANNELD_GOT_SHUTDOWN";
	case WIRE_CHANNELD_SHUTDOWN_COMPLETE: return "WIRE_CHANNELD_SHUTDOWN_COMPLETE";
	case WIRE_CHANNELD_DEV_REENABLE_COMMIT: return "WIRE_CHANNELD_DEV_REENABLE_COMMIT";
	case WIRE_CHANNELD_DEV_REENABLE_COMMIT_REPLY: return "WIRE_CHANNELD_DEV_REENABLE_COMMIT_REPLY";
	case WIRE_CHANNELD_FEERATES: return "WIRE_CHANNELD_FEERATES";
	case WIRE_CHANNELD_DEV_MEMLEAK: return "WIRE_CHANNELD_DEV_MEMLEAK";
	case WIRE_CHANNELD_DEV_MEMLEAK_REPLY: return "WIRE_CHANNELD_DEV_MEMLEAK_REPLY";
	case WIRE_CHANNELD_FAIL_FALLEN_BEHIND: return "WIRE_CHANNELD_FAIL_FALLEN_BEHIND";
	case WIRE_CHANNELD_SPECIFIC_FEERATES: return "WIRE_CHANNELD_SPECIFIC_FEERATES";
	case WIRE_CHANNELD_GOT_ANNOUNCEMENT: return "WIRE_CHANNELD_GOT_ANNOUNCEMENT";
	case WIRE_CHANNELD_SEND_ERROR: return "WIRE_CHANNELD_SEND_ERROR";
	case WIRE_CHANNELD_SEND_ERROR_REPLY: return "WIRE_CHANNELD_SEND_ERROR_REPLY";
	case WIRE_CHANNELD_DEV_QUIESCE: return "WIRE_CHANNELD_DEV_QUIESCE";
	case WIRE_CHANNELD_DEV_QUIESCE_REPLY: return "WIRE_CHANNELD_DEV_QUIESCE_REPLY";
	case WIRE_CHANNELD_UPGRADED: return "WIRE_CHANNELD_UPGRADED";
	}

	snprintf(invalidbuf, sizeof(invalidbuf), "INVALID %i", e);
	return invalidbuf;
}

bool channeld_wire_is_defined(u16 type)
{
	switch ((enum channeld_wire)type) {
	case WIRE_CHANNELD_INIT:;
	case WIRE_CHANNELD_FUNDING_DEPTH:;
	case WIRE_CHANNELD_OFFER_HTLC:;
	case WIRE_CHANNELD_OFFER_HTLC_REPLY:;
	case WIRE_CHANNELD_FULFILL_HTLC:;
	case WIRE_CHANNELD_FAIL_HTLC:;
	case WIRE_CHANNELD_GOT_FUNDING_LOCKED:;
	case WIRE_CHANNELD_SENDING_COMMITSIG:;
	case WIRE_CHANNELD_SENDING_COMMITSIG_REPLY:;
	case WIRE_CHANNELD_GOT_COMMITSIG:;
	case WIRE_CHANNELD_GOT_COMMITSIG_REPLY:;
	case WIRE_CHANNELD_GOT_REVOKE:;
	case WIRE_CHANNELD_GOT_REVOKE_REPLY:;
	case WIRE_CHANNELD_SEND_SHUTDOWN:;
	case WIRE_CHANNELD_GOT_SHUTDOWN:;
	case WIRE_CHANNELD_SHUTDOWN_COMPLETE:;
	case WIRE_CHANNELD_DEV_REENABLE_COMMIT:;
	case WIRE_CHANNELD_DEV_REENABLE_COMMIT_REPLY:;
	case WIRE_CHANNELD_FEERATES:;
	case WIRE_CHANNELD_DEV_MEMLEAK:;
	case WIRE_CHANNELD_DEV_MEMLEAK_REPLY:;
	case WIRE_CHANNELD_FAIL_FALLEN_BEHIND:;
	case WIRE_CHANNELD_SPECIFIC_FEERATES:;
	case WIRE_CHANNELD_GOT_ANNOUNCEMENT:;
	case WIRE_CHANNELD_SEND_ERROR:;
	case WIRE_CHANNELD_SEND_ERROR_REPLY:;
	case WIRE_CHANNELD_DEV_QUIESCE:;
	case WIRE_CHANNELD_DEV_QUIESCE_REPLY:;
	case WIRE_CHANNELD_UPGRADED:;
	      return true;
	}
	return false;
}





/* WIRE: CHANNELD_INIT */
/* Begin!  (passes gossipd-client fd) */
u8 *towire_channeld_init(const tal_t *ctx, const struct chainparams *chainparams, const struct feature_set *our_features, const struct channel_id *channel_id, const struct bitcoin_txid *funding_txid, u16 funding_txout, struct amount_sat funding_satoshi, u32 minimum_depth, const struct channel_config *our_config, const struct channel_config *their_config, const struct fee_states *fee_states, u32 feerate_min, u32 feerate_max, u32 feerate_penalty, const struct bitcoin_signature *first_commit_sig, const struct per_peer_state *per_peer_state, const struct pubkey *remote_fundingkey, const struct basepoints *remote_basepoints, const struct pubkey *remote_per_commit, const struct pubkey *old_remote_per_commit, enum side opener, u32 fee_base, u32 fee_proportional, struct amount_msat local_msatoshi, const struct basepoints *our_basepoints, const struct pubkey *our_funding_pubkey, const struct node_id *local_node_id, const struct node_id *remote_node_id, u32 commit_msec, u16 cltv_delta, bool last_was_revoke, const struct changed_htlc *last_sent_commit, u64 next_index_local, u64 next_index_remote, u64 revocations_received, u64 next_htlc_id, const struct existing_htlc **htlcs, bool local_funding_locked, bool remote_funding_locked, const struct short_channel_id *funding_short_id, bool reestablish, bool send_shutdown, bool remote_shutdown_received, const u8 *final_scriptpubkey, u8 flags, const u8 *init_peer_pkt, bool reached_announce_depth, const struct secret *last_remote_secret, const u8 *their_features, const u8 *upfront_shutdown_script, const secp256k1_ecdsa_signature *remote_ann_node_sig, const secp256k1_ecdsa_signature *remote_ann_bitcoin_sig, bool option_static_remotekey, bool option_anchor_outputs, bool dev_fast_gossip, bool dev_fail_process_onionpacket, const struct penalty_base *pbases)
{
	u16 num_last_sent_commit = tal_count(last_sent_commit);
	u16 num_existing_htlcs = tal_count(htlcs);
	u16 final_scriptpubkey_len = tal_count(final_scriptpubkey);
	u16 init_peer_pkt_len = tal_count(init_peer_pkt);
	u16 flen = tal_count(their_features);
	u16 upfront_shutdown_script_len = tal_count(upfront_shutdown_script);
	u32 num_penalty_bases = tal_count(pbases);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_INIT);
	towire_chainparams(&p, chainparams);
	towire_feature_set(&p, our_features);
	towire_channel_id(&p, channel_id);
	towire_bitcoin_txid(&p, funding_txid);
	towire_u16(&p, funding_txout);
	towire_amount_sat(&p, funding_satoshi);
	towire_u32(&p, minimum_depth);
	towire_channel_config(&p, our_config);
	towire_channel_config(&p, their_config);
	towire_fee_states(&p, fee_states);
	towire_u32(&p, feerate_min);
	towire_u32(&p, feerate_max);
	towire_u32(&p, feerate_penalty);
	towire_bitcoin_signature(&p, first_commit_sig);
	towire_per_peer_state(&p, per_peer_state);
	towire_pubkey(&p, remote_fundingkey);
	towire_basepoints(&p, remote_basepoints);
	towire_pubkey(&p, remote_per_commit);
	towire_pubkey(&p, old_remote_per_commit);
	towire_side(&p, opener);
	towire_u32(&p, fee_base);
	towire_u32(&p, fee_proportional);
	towire_amount_msat(&p, local_msatoshi);
	towire_basepoints(&p, our_basepoints);
	towire_pubkey(&p, our_funding_pubkey);
	towire_node_id(&p, local_node_id);
	towire_node_id(&p, remote_node_id);
	towire_u32(&p, commit_msec);
	towire_u16(&p, cltv_delta);
	towire_bool(&p, last_was_revoke);
	towire_u16(&p, num_last_sent_commit);
	for (size_t i = 0; i < num_last_sent_commit; i++)
		towire_changed_htlc(&p, last_sent_commit + i);
	towire_u64(&p, next_index_local);
	towire_u64(&p, next_index_remote);
	towire_u64(&p, revocations_received);
	towire_u64(&p, next_htlc_id);
	towire_u16(&p, num_existing_htlcs);
	for (size_t i = 0; i < num_existing_htlcs; i++)
		towire_existing_htlc(&p, htlcs[i]);
	towire_bool(&p, local_funding_locked);
	towire_bool(&p, remote_funding_locked);
	towire_short_channel_id(&p, funding_short_id);
	towire_bool(&p, reestablish);
	towire_bool(&p, send_shutdown);
	towire_bool(&p, remote_shutdown_received);
	towire_u16(&p, final_scriptpubkey_len);
	towire_u8_array(&p, final_scriptpubkey, final_scriptpubkey_len);
	towire_u8(&p, flags);
	towire_u16(&p, init_peer_pkt_len);
	towire_u8_array(&p, init_peer_pkt, init_peer_pkt_len);
	towire_bool(&p, reached_announce_depth);
	towire_secret(&p, last_remote_secret);
	towire_u16(&p, flen);
	towire_u8_array(&p, their_features, flen);
	towire_u16(&p, upfront_shutdown_script_len);
	towire_u8_array(&p, upfront_shutdown_script, upfront_shutdown_script_len);
	if (!remote_ann_node_sig)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_secp256k1_ecdsa_signature(&p, remote_ann_node_sig);
	}
	if (!remote_ann_bitcoin_sig)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_secp256k1_ecdsa_signature(&p, remote_ann_bitcoin_sig);
	}
	towire_bool(&p, option_static_remotekey);
	towire_bool(&p, option_anchor_outputs);
	towire_bool(&p, dev_fast_gossip);
	towire_bool(&p, dev_fail_process_onionpacket);
	towire_u32(&p, num_penalty_bases);
	for (size_t i = 0; i < num_penalty_bases; i++)
		towire_penalty_base(&p, pbases + i);

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_init(const tal_t *ctx, const void *p, const struct chainparams **chainparams, struct feature_set **our_features, struct channel_id *channel_id, struct bitcoin_txid *funding_txid, u16 *funding_txout, struct amount_sat *funding_satoshi, u32 *minimum_depth, struct channel_config *our_config, struct channel_config *their_config, struct fee_states **fee_states, u32 *feerate_min, u32 *feerate_max, u32 *feerate_penalty, struct bitcoin_signature *first_commit_sig, struct per_peer_state **per_peer_state, struct pubkey *remote_fundingkey, struct basepoints *remote_basepoints, struct pubkey *remote_per_commit, struct pubkey *old_remote_per_commit, enum side *opener, u32 *fee_base, u32 *fee_proportional, struct amount_msat *local_msatoshi, struct basepoints *our_basepoints, struct pubkey *our_funding_pubkey, struct node_id *local_node_id, struct node_id *remote_node_id, u32 *commit_msec, u16 *cltv_delta, bool *last_was_revoke, struct changed_htlc **last_sent_commit, u64 *next_index_local, u64 *next_index_remote, u64 *revocations_received, u64 *next_htlc_id, struct existing_htlc ***htlcs, bool *local_funding_locked, bool *remote_funding_locked, struct short_channel_id *funding_short_id, bool *reestablish, bool *send_shutdown, bool *remote_shutdown_received, u8 **final_scriptpubkey, u8 *flags, u8 **init_peer_pkt, bool *reached_announce_depth, struct secret *last_remote_secret, u8 **their_features, u8 **upfront_shutdown_script, secp256k1_ecdsa_signature **remote_ann_node_sig, secp256k1_ecdsa_signature **remote_ann_bitcoin_sig, bool *option_static_remotekey, bool *option_anchor_outputs, bool *dev_fast_gossip, bool *dev_fail_process_onionpacket, struct penalty_base **pbases)
{
	u16 num_last_sent_commit;
	u16 num_existing_htlcs;
	u16 final_scriptpubkey_len;
	u16 init_peer_pkt_len;
	u16 flen;
	u16 upfront_shutdown_script_len;
	u32 num_penalty_bases;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_INIT)
		return false;
 	fromwire_chainparams(&cursor, &plen, chainparams);
 	*our_features = fromwire_feature_set(ctx, &cursor, &plen);
 	fromwire_channel_id(&cursor, &plen, channel_id);
 	fromwire_bitcoin_txid(&cursor, &plen, funding_txid);
 	*funding_txout = fromwire_u16(&cursor, &plen);
 	*funding_satoshi = fromwire_amount_sat(&cursor, &plen);
 	*minimum_depth = fromwire_u32(&cursor, &plen);
 	fromwire_channel_config(&cursor, &plen, our_config);
 	fromwire_channel_config(&cursor, &plen, their_config);
 	*fee_states = fromwire_fee_states(ctx, &cursor, &plen);
 	*feerate_min = fromwire_u32(&cursor, &plen);
 	*feerate_max = fromwire_u32(&cursor, &plen);
 	*feerate_penalty = fromwire_u32(&cursor, &plen);
 	fromwire_bitcoin_signature(&cursor, &plen, first_commit_sig);
 	*per_peer_state = fromwire_per_peer_state(ctx, &cursor, &plen);
 	fromwire_pubkey(&cursor, &plen, remote_fundingkey);
 	fromwire_basepoints(&cursor, &plen, remote_basepoints);
 	fromwire_pubkey(&cursor, &plen, remote_per_commit);
 	fromwire_pubkey(&cursor, &plen, old_remote_per_commit);
 	*opener = fromwire_side(&cursor, &plen);
 	*fee_base = fromwire_u32(&cursor, &plen);
 	*fee_proportional = fromwire_u32(&cursor, &plen);
 	*local_msatoshi = fromwire_amount_msat(&cursor, &plen);
 	fromwire_basepoints(&cursor, &plen, our_basepoints);
 	fromwire_pubkey(&cursor, &plen, our_funding_pubkey);
 	fromwire_node_id(&cursor, &plen, local_node_id);
 	fromwire_node_id(&cursor, &plen, remote_node_id);
 	*commit_msec = fromwire_u32(&cursor, &plen);
 	*cltv_delta = fromwire_u16(&cursor, &plen);
 	*last_was_revoke = fromwire_bool(&cursor, &plen);
 	num_last_sent_commit = fromwire_u16(&cursor, &plen);
 	// 2nd case last_sent_commit
	*last_sent_commit = num_last_sent_commit ? tal_arr(ctx, struct changed_htlc, num_last_sent_commit) : NULL;
	for (size_t i = 0; i < num_last_sent_commit; i++)
		fromwire_changed_htlc(&cursor, &plen, *last_sent_commit + i);
 	*next_index_local = fromwire_u64(&cursor, &plen);
 	*next_index_remote = fromwire_u64(&cursor, &plen);
 	*revocations_received = fromwire_u64(&cursor, &plen);
 	*next_htlc_id = fromwire_u64(&cursor, &plen);
 	num_existing_htlcs = fromwire_u16(&cursor, &plen);
 	// 2nd case htlcs
	*htlcs = num_existing_htlcs ? tal_arr(ctx, struct existing_htlc *, num_existing_htlcs) : NULL;
	for (size_t i = 0; i < num_existing_htlcs; i++)
		(*htlcs)[i] = fromwire_existing_htlc(*htlcs, &cursor, &plen);
 	*local_funding_locked = fromwire_bool(&cursor, &plen);
 	*remote_funding_locked = fromwire_bool(&cursor, &plen);
 	fromwire_short_channel_id(&cursor, &plen, funding_short_id);
 	*reestablish = fromwire_bool(&cursor, &plen);
 	*send_shutdown = fromwire_bool(&cursor, &plen);
 	*remote_shutdown_received = fromwire_bool(&cursor, &plen);
 	final_scriptpubkey_len = fromwire_u16(&cursor, &plen);
 	// 2nd case final_scriptpubkey
	*final_scriptpubkey = final_scriptpubkey_len ? tal_arr(ctx, u8, final_scriptpubkey_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *final_scriptpubkey, final_scriptpubkey_len);
 	*flags = fromwire_u8(&cursor, &plen);
 	init_peer_pkt_len = fromwire_u16(&cursor, &plen);
 	// 2nd case init_peer_pkt
	*init_peer_pkt = init_peer_pkt_len ? tal_arr(ctx, u8, init_peer_pkt_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *init_peer_pkt, init_peer_pkt_len);
 	*reached_announce_depth = fromwire_bool(&cursor, &plen);
 	fromwire_secret(&cursor, &plen, last_remote_secret);
 	flen = fromwire_u16(&cursor, &plen);
 	// 2nd case their_features
	*their_features = flen ? tal_arr(ctx, u8, flen) : NULL;
	fromwire_u8_array(&cursor, &plen, *their_features, flen);
 	upfront_shutdown_script_len = fromwire_u16(&cursor, &plen);
 	// 2nd case upfront_shutdown_script
	*upfront_shutdown_script = upfront_shutdown_script_len ? tal_arr(ctx, u8, upfront_shutdown_script_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *upfront_shutdown_script, upfront_shutdown_script_len);
 	if (!fromwire_bool(&cursor, &plen))
		*remote_ann_node_sig = NULL;
	else {
		*remote_ann_node_sig = tal(ctx, secp256k1_ecdsa_signature);
		fromwire_secp256k1_ecdsa_signature(&cursor, &plen, *remote_ann_node_sig);
	}
 	if (!fromwire_bool(&cursor, &plen))
		*remote_ann_bitcoin_sig = NULL;
	else {
		*remote_ann_bitcoin_sig = tal(ctx, secp256k1_ecdsa_signature);
		fromwire_secp256k1_ecdsa_signature(&cursor, &plen, *remote_ann_bitcoin_sig);
	}
 	*option_static_remotekey = fromwire_bool(&cursor, &plen);
 	*option_anchor_outputs = fromwire_bool(&cursor, &plen);
 	*dev_fast_gossip = fromwire_bool(&cursor, &plen);
 	*dev_fail_process_onionpacket = fromwire_bool(&cursor, &plen);
 	num_penalty_bases = fromwire_u32(&cursor, &plen);
 	// 2nd case pbases
	*pbases = num_penalty_bases ? tal_arr(ctx, struct penalty_base, num_penalty_bases) : NULL;
	for (size_t i = 0; i < num_penalty_bases; i++)
		fromwire_penalty_base(&cursor, &plen, *pbases + i);
	return cursor != NULL;
}

/* WIRE: CHANNELD_FUNDING_DEPTH */
/* master->channeld funding hit new depth(funding locked if >= lock depth) */
u8 *towire_channeld_funding_depth(const tal_t *ctx, const struct short_channel_id *short_channel_id, u32 depth)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_FUNDING_DEPTH);
	if (!short_channel_id)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_short_channel_id(&p, short_channel_id);
	}
	towire_u32(&p, depth);

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_funding_depth(const tal_t *ctx, const void *p, struct short_channel_id **short_channel_id, u32 *depth)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_FUNDING_DEPTH)
		return false;
 	if (!fromwire_bool(&cursor, &plen))
		*short_channel_id = NULL;
	else {
		*short_channel_id = tal(ctx, struct short_channel_id);
		fromwire_short_channel_id(&cursor, &plen, *short_channel_id);
	}
 	*depth = fromwire_u32(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: CHANNELD_OFFER_HTLC */
/* Tell channel to offer this htlc */
u8 *towire_channeld_offer_htlc(const tal_t *ctx, struct amount_msat amount_msat, u32 cltv_expiry, const struct sha256 *payment_hash, const u8 onion_routing_packet[1366], const struct pubkey *blinding)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_OFFER_HTLC);
	towire_amount_msat(&p, amount_msat);
	towire_u32(&p, cltv_expiry);
	towire_sha256(&p, payment_hash);
	towire_u8_array(&p, onion_routing_packet, 1366);
	if (!blinding)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_pubkey(&p, blinding);
	}

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_offer_htlc(const tal_t *ctx, const void *p, struct amount_msat *amount_msat, u32 *cltv_expiry, struct sha256 *payment_hash, u8 onion_routing_packet[1366], struct pubkey **blinding)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_OFFER_HTLC)
		return false;
 	*amount_msat = fromwire_amount_msat(&cursor, &plen);
 	*cltv_expiry = fromwire_u32(&cursor, &plen);
 	fromwire_sha256(&cursor, &plen, payment_hash);
 	fromwire_u8_array(&cursor, &plen, onion_routing_packet, 1366);
 	if (!fromwire_bool(&cursor, &plen))
		*blinding = NULL;
	else {
		*blinding = tal(ctx, struct pubkey);
		fromwire_pubkey(&cursor, &plen, *blinding);
	}
	return cursor != NULL;
}

/* WIRE: CHANNELD_OFFER_HTLC_REPLY */
/* Reply; synchronous since IDs have to increment. */
u8 *towire_channeld_offer_htlc_reply(const tal_t *ctx, u64 id, const u8 *failuremsg, const wirestring *failurestr)
{
	u16 len = tal_count(failuremsg);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_OFFER_HTLC_REPLY);
	towire_u64(&p, id);
	/* Empty failure message means success. */
	towire_u16(&p, len);
	towire_u8_array(&p, failuremsg, len);
	towire_wirestring(&p, failurestr);

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_offer_htlc_reply(const tal_t *ctx, const void *p, u64 *id, u8 **failuremsg, wirestring **failurestr)
{
	u16 len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_OFFER_HTLC_REPLY)
		return false;
 	*id = fromwire_u64(&cursor, &plen);
 	/* Empty failure message means success. */
	len = fromwire_u16(&cursor, &plen);
 	// 2nd case failuremsg
	*failuremsg = len ? tal_arr(ctx, u8, len) : NULL;
	fromwire_u8_array(&cursor, &plen, *failuremsg, len);
 	*failurestr = fromwire_wirestring(ctx, &cursor, &plen);
	return cursor != NULL;
}

/* WIRE: CHANNELD_FULFILL_HTLC */
/* Main daemon found out the preimage for an HTLC */
u8 *towire_channeld_fulfill_htlc(const tal_t *ctx, const struct fulfilled_htlc *fulfilled_htlc)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_FULFILL_HTLC);
	towire_fulfilled_htlc(&p, fulfilled_htlc);

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_fulfill_htlc(const void *p, struct fulfilled_htlc *fulfilled_htlc)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_FULFILL_HTLC)
		return false;
 	fromwire_fulfilled_htlc(&cursor, &plen, fulfilled_htlc);
	return cursor != NULL;
}

/* WIRE: CHANNELD_FAIL_HTLC */
/* Main daemon says HTLC failed */
u8 *towire_channeld_fail_htlc(const tal_t *ctx, const struct failed_htlc *failed_htlc)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_FAIL_HTLC);
	towire_failed_htlc(&p, failed_htlc);

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_fail_htlc(const tal_t *ctx, const void *p, struct failed_htlc **failed_htlc)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_FAIL_HTLC)
		return false;
 	*failed_htlc = fromwire_failed_htlc(ctx, &cursor, &plen);
	return cursor != NULL;
}

/* WIRE: CHANNELD_GOT_FUNDING_LOCKED */
/* When we receive funding_locked. */
u8 *towire_channeld_got_funding_locked(const tal_t *ctx, const struct pubkey *next_per_commit_point)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_GOT_FUNDING_LOCKED);
	towire_pubkey(&p, next_per_commit_point);

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_got_funding_locked(const void *p, struct pubkey *next_per_commit_point)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_GOT_FUNDING_LOCKED)
		return false;
 	fromwire_pubkey(&cursor, &plen, next_per_commit_point);
	return cursor != NULL;
}

/* WIRE: CHANNELD_SENDING_COMMITSIG */
/* When we send a commitment_signed message */
u8 *towire_channeld_sending_commitsig(const tal_t *ctx, u64 commitnum, const struct penalty_base *pbase, const struct fee_states *fee_states, const struct changed_htlc *changed, const struct bitcoin_signature *commit_sig, const struct bitcoin_signature *htlc_sigs)
{
	u16 num_changed = tal_count(changed);
	u16 num_htlc_sigs = tal_count(htlc_sigs);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_SENDING_COMMITSIG);
	towire_u64(&p, commitnum);
	if (!pbase)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_penalty_base(&p, pbase);
	}
	towire_fee_states(&p, fee_states);
	/* SENT_ADD_COMMIT */
	towire_u16(&p, num_changed);
	for (size_t i = 0; i < num_changed; i++)
		towire_changed_htlc(&p, changed + i);
	towire_bitcoin_signature(&p, commit_sig);
	towire_u16(&p, num_htlc_sigs);
	for (size_t i = 0; i < num_htlc_sigs; i++)
		towire_bitcoin_signature(&p, htlc_sigs + i);

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_sending_commitsig(const tal_t *ctx, const void *p, u64 *commitnum, struct penalty_base **pbase, struct fee_states **fee_states, struct changed_htlc **changed, struct bitcoin_signature *commit_sig, struct bitcoin_signature **htlc_sigs)
{
	u16 num_changed;
	u16 num_htlc_sigs;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_SENDING_COMMITSIG)
		return false;
 	*commitnum = fromwire_u64(&cursor, &plen);
 	if (!fromwire_bool(&cursor, &plen))
		*pbase = NULL;
	else {
		*pbase = tal(ctx, struct penalty_base);
		fromwire_penalty_base(&cursor, &plen, *pbase);
	}
 	*fee_states = fromwire_fee_states(ctx, &cursor, &plen);
 	/* SENT_ADD_COMMIT */
	num_changed = fromwire_u16(&cursor, &plen);
 	// 2nd case changed
	*changed = num_changed ? tal_arr(ctx, struct changed_htlc, num_changed) : NULL;
	for (size_t i = 0; i < num_changed; i++)
		fromwire_changed_htlc(&cursor, &plen, *changed + i);
 	fromwire_bitcoin_signature(&cursor, &plen, commit_sig);
 	num_htlc_sigs = fromwire_u16(&cursor, &plen);
 	// 2nd case htlc_sigs
	*htlc_sigs = num_htlc_sigs ? tal_arr(ctx, struct bitcoin_signature, num_htlc_sigs) : NULL;
	for (size_t i = 0; i < num_htlc_sigs; i++)
		fromwire_bitcoin_signature(&cursor, &plen, *htlc_sigs + i);
	return cursor != NULL;
}

/* WIRE: CHANNELD_SENDING_COMMITSIG_REPLY */
/* Wait for reply */
u8 *towire_channeld_sending_commitsig_reply(const tal_t *ctx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_SENDING_COMMITSIG_REPLY);

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_sending_commitsig_reply(const void *p)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_SENDING_COMMITSIG_REPLY)
		return false;
	return cursor != NULL;
}

/* WIRE: CHANNELD_GOT_COMMITSIG */
/* When we have a commitment_signed message */
u8 *towire_channeld_got_commitsig(const tal_t *ctx, u64 commitnum, const struct fee_states *fee_states, const struct bitcoin_signature *signature, const struct bitcoin_signature *htlc_signature, const struct added_htlc *added, const struct fulfilled_htlc *fulfilled, const struct failed_htlc **failed, const struct changed_htlc *changed, const struct bitcoin_tx *tx)
{
	u16 num_htlcs = tal_count(htlc_signature);
	u16 num_added = tal_count(added);
	u16 num_fulfilled = tal_count(fulfilled);
	u16 num_failed = tal_count(failed);
	u16 num_changed = tal_count(changed);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_GOT_COMMITSIG);
	towire_u64(&p, commitnum);
	towire_fee_states(&p, fee_states);
	towire_bitcoin_signature(&p, signature);
	towire_u16(&p, num_htlcs);
	for (size_t i = 0; i < num_htlcs; i++)
		towire_bitcoin_signature(&p, htlc_signature + i);
	/* RCVD_ADD_COMMIT: we're now committed to their new offered HTLCs. */
	towire_u16(&p, num_added);
	for (size_t i = 0; i < num_added; i++)
		towire_added_htlc(&p, added + i);
	/* RCVD_REMOVE_COMMIT: we're now no longer committed to these HTLCs. */
	towire_u16(&p, num_fulfilled);
	for (size_t i = 0; i < num_fulfilled; i++)
		towire_fulfilled_htlc(&p, fulfilled + i);
	towire_u16(&p, num_failed);
	for (size_t i = 0; i < num_failed; i++)
		towire_failed_htlc(&p, failed[i]);
	/* RCVD_ADD_ACK_COMMIT */
	towire_u16(&p, num_changed);
	for (size_t i = 0; i < num_changed; i++)
		towire_changed_htlc(&p, changed + i);
	towire_bitcoin_tx(&p, tx);

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_got_commitsig(const tal_t *ctx, const void *p, u64 *commitnum, struct fee_states **fee_states, struct bitcoin_signature *signature, struct bitcoin_signature **htlc_signature, struct added_htlc **added, struct fulfilled_htlc **fulfilled, struct failed_htlc ***failed, struct changed_htlc **changed, struct bitcoin_tx **tx)
{
	u16 num_htlcs;
	u16 num_added;
	u16 num_fulfilled;
	u16 num_failed;
	u16 num_changed;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_GOT_COMMITSIG)
		return false;
 	*commitnum = fromwire_u64(&cursor, &plen);
 	*fee_states = fromwire_fee_states(ctx, &cursor, &plen);
 	fromwire_bitcoin_signature(&cursor, &plen, signature);
 	num_htlcs = fromwire_u16(&cursor, &plen);
 	// 2nd case htlc_signature
	*htlc_signature = num_htlcs ? tal_arr(ctx, struct bitcoin_signature, num_htlcs) : NULL;
	for (size_t i = 0; i < num_htlcs; i++)
		fromwire_bitcoin_signature(&cursor, &plen, *htlc_signature + i);
 	/* RCVD_ADD_COMMIT: we're now committed to their new offered HTLCs. */
	num_added = fromwire_u16(&cursor, &plen);
 	// 2nd case added
	*added = num_added ? tal_arr(ctx, struct added_htlc, num_added) : NULL;
	for (size_t i = 0; i < num_added; i++)
		fromwire_added_htlc(&cursor, &plen, *added + i);
 	/* RCVD_REMOVE_COMMIT: we're now no longer committed to these HTLCs. */
	num_fulfilled = fromwire_u16(&cursor, &plen);
 	// 2nd case fulfilled
	*fulfilled = num_fulfilled ? tal_arr(ctx, struct fulfilled_htlc, num_fulfilled) : NULL;
	for (size_t i = 0; i < num_fulfilled; i++)
		fromwire_fulfilled_htlc(&cursor, &plen, *fulfilled + i);
 	num_failed = fromwire_u16(&cursor, &plen);
 	// 2nd case failed
	*failed = num_failed ? tal_arr(ctx, struct failed_htlc *, num_failed) : NULL;
	for (size_t i = 0; i < num_failed; i++)
		(*failed)[i] = fromwire_failed_htlc(*failed, &cursor, &plen);
 	/* RCVD_ADD_ACK_COMMIT */
	num_changed = fromwire_u16(&cursor, &plen);
 	// 2nd case changed
	*changed = num_changed ? tal_arr(ctx, struct changed_htlc, num_changed) : NULL;
	for (size_t i = 0; i < num_changed; i++)
		fromwire_changed_htlc(&cursor, &plen, *changed + i);
 	*tx = fromwire_bitcoin_tx(ctx, &cursor, &plen);
	return cursor != NULL;
}

/* WIRE: CHANNELD_GOT_COMMITSIG_REPLY */
/* Wait for reply */
u8 *towire_channeld_got_commitsig_reply(const tal_t *ctx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_GOT_COMMITSIG_REPLY);

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_got_commitsig_reply(const void *p)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_GOT_COMMITSIG_REPLY)
		return false;
	return cursor != NULL;
}

/* WIRE: CHANNELD_GOT_REVOKE */
u8 *towire_channeld_got_revoke(const tal_t *ctx, u64 revokenum, const struct secret *per_commitment_secret, const struct pubkey *next_per_commit_point, const struct fee_states *fee_states, const struct changed_htlc *changed, const struct penalty_base *pbase, const struct bitcoin_tx *penalty_tx)
{
	u16 num_changed = tal_count(changed);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_GOT_REVOKE);
	towire_u64(&p, revokenum);
	towire_secret(&p, per_commitment_secret);
	towire_pubkey(&p, next_per_commit_point);
	/* RCVD_ADD_ACK_REVOCATION */
	towire_fee_states(&p, fee_states);
	towire_u16(&p, num_changed);
	for (size_t i = 0; i < num_changed; i++)
		towire_changed_htlc(&p, changed + i);
	if (!pbase)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_penalty_base(&p, pbase);
	}
	if (!penalty_tx)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_bitcoin_tx(&p, penalty_tx);
	}

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_got_revoke(const tal_t *ctx, const void *p, u64 *revokenum, struct secret *per_commitment_secret, struct pubkey *next_per_commit_point, struct fee_states **fee_states, struct changed_htlc **changed, struct penalty_base **pbase, struct bitcoin_tx **penalty_tx)
{
	u16 num_changed;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_GOT_REVOKE)
		return false;
 	*revokenum = fromwire_u64(&cursor, &plen);
 	fromwire_secret(&cursor, &plen, per_commitment_secret);
 	fromwire_pubkey(&cursor, &plen, next_per_commit_point);
 	/* RCVD_ADD_ACK_REVOCATION */
	*fee_states = fromwire_fee_states(ctx, &cursor, &plen);
 	num_changed = fromwire_u16(&cursor, &plen);
 	// 2nd case changed
	*changed = num_changed ? tal_arr(ctx, struct changed_htlc, num_changed) : NULL;
	for (size_t i = 0; i < num_changed; i++)
		fromwire_changed_htlc(&cursor, &plen, *changed + i);
 	if (!fromwire_bool(&cursor, &plen))
		*pbase = NULL;
	else {
		*pbase = tal(ctx, struct penalty_base);
		fromwire_penalty_base(&cursor, &plen, *pbase);
	}
 	if (!fromwire_bool(&cursor, &plen))
		*penalty_tx = NULL;
	else {
		*penalty_tx = fromwire_bitcoin_tx(ctx, &cursor, &plen);
	}
	return cursor != NULL;
}

/* WIRE: CHANNELD_GOT_REVOKE_REPLY */
/* Wait for reply */
/* (eg. if we sent another commitment_signed */
u8 *towire_channeld_got_revoke_reply(const tal_t *ctx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_GOT_REVOKE_REPLY);

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_got_revoke_reply(const void *p)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_GOT_REVOKE_REPLY)
		return false;
	return cursor != NULL;
}

/* WIRE: CHANNELD_SEND_SHUTDOWN */
/* Tell peer to shut down channel. */
u8 *towire_channeld_send_shutdown(const tal_t *ctx, const u8 *shutdown_scriptpubkey, const struct bitcoin_outpoint *wrong_funding)
{
	u16 shutdown_len = tal_count(shutdown_scriptpubkey);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_SEND_SHUTDOWN);
	towire_u16(&p, shutdown_len);
	towire_u8_array(&p, shutdown_scriptpubkey, shutdown_len);
	if (!wrong_funding)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_bitcoin_outpoint(&p, wrong_funding);
	}

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_send_shutdown(const tal_t *ctx, const void *p, u8 **shutdown_scriptpubkey, struct bitcoin_outpoint **wrong_funding)
{
	u16 shutdown_len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_SEND_SHUTDOWN)
		return false;
 	shutdown_len = fromwire_u16(&cursor, &plen);
 	// 2nd case shutdown_scriptpubkey
	*shutdown_scriptpubkey = shutdown_len ? tal_arr(ctx, u8, shutdown_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *shutdown_scriptpubkey, shutdown_len);
 	if (!fromwire_bool(&cursor, &plen))
		*wrong_funding = NULL;
	else {
		*wrong_funding = tal(ctx, struct bitcoin_outpoint);
		fromwire_bitcoin_outpoint(&cursor, &plen, *wrong_funding);
	}
	return cursor != NULL;
}

/* WIRE: CHANNELD_GOT_SHUTDOWN */
/* Peer told us that channel is shutting down */
u8 *towire_channeld_got_shutdown(const tal_t *ctx, const u8 *scriptpubkey, const struct bitcoin_outpoint *wrong_funding)
{
	u16 scriptpubkey_len = tal_count(scriptpubkey);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_GOT_SHUTDOWN);
	towire_u16(&p, scriptpubkey_len);
	towire_u8_array(&p, scriptpubkey, scriptpubkey_len);
	if (!wrong_funding)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_bitcoin_outpoint(&p, wrong_funding);
	}

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_got_shutdown(const tal_t *ctx, const void *p, u8 **scriptpubkey, struct bitcoin_outpoint **wrong_funding)
{
	u16 scriptpubkey_len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_GOT_SHUTDOWN)
		return false;
 	scriptpubkey_len = fromwire_u16(&cursor, &plen);
 	// 2nd case scriptpubkey
	*scriptpubkey = scriptpubkey_len ? tal_arr(ctx, u8, scriptpubkey_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *scriptpubkey, scriptpubkey_len);
 	if (!fromwire_bool(&cursor, &plen))
		*wrong_funding = NULL;
	else {
		*wrong_funding = tal(ctx, struct bitcoin_outpoint);
		fromwire_bitcoin_outpoint(&cursor, &plen, *wrong_funding);
	}
	return cursor != NULL;
}

/* WIRE: CHANNELD_SHUTDOWN_COMPLETE */
/* Shutdown is complete */
u8 *towire_channeld_shutdown_complete(const tal_t *ctx, const struct per_peer_state *per_peer_state)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_SHUTDOWN_COMPLETE);
	towire_per_peer_state(&p, per_peer_state);

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_shutdown_complete(const tal_t *ctx, const void *p, struct per_peer_state **per_peer_state)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_SHUTDOWN_COMPLETE)
		return false;
 	*per_peer_state = fromwire_per_peer_state(ctx, &cursor, &plen);
	return cursor != NULL;
}

/* WIRE: CHANNELD_DEV_REENABLE_COMMIT */
/* Re-enable commit timer. */
u8 *towire_channeld_dev_reenable_commit(const tal_t *ctx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_DEV_REENABLE_COMMIT);

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_dev_reenable_commit(const void *p)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_DEV_REENABLE_COMMIT)
		return false;
	return cursor != NULL;
}

/* WIRE: CHANNELD_DEV_REENABLE_COMMIT_REPLY */
u8 *towire_channeld_dev_reenable_commit_reply(const tal_t *ctx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_DEV_REENABLE_COMMIT_REPLY);

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_dev_reenable_commit_reply(const void *p)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_DEV_REENABLE_COMMIT_REPLY)
		return false;
	return cursor != NULL;
}

/* WIRE: CHANNELD_FEERATES */
u8 *towire_channeld_feerates(const tal_t *ctx, u32 feerate, u32 min_feerate, u32 max_feerate, u32 penalty_feerate)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_FEERATES);
	towire_u32(&p, feerate);
	towire_u32(&p, min_feerate);
	towire_u32(&p, max_feerate);
	towire_u32(&p, penalty_feerate);

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_feerates(const void *p, u32 *feerate, u32 *min_feerate, u32 *max_feerate, u32 *penalty_feerate)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_FEERATES)
		return false;
 	*feerate = fromwire_u32(&cursor, &plen);
 	*min_feerate = fromwire_u32(&cursor, &plen);
 	*max_feerate = fromwire_u32(&cursor, &plen);
 	*penalty_feerate = fromwire_u32(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: CHANNELD_DEV_MEMLEAK */
/* master -> channeld: do you have a memleak? */
u8 *towire_channeld_dev_memleak(const tal_t *ctx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_DEV_MEMLEAK);

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_dev_memleak(const void *p)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_DEV_MEMLEAK)
		return false;
	return cursor != NULL;
}

/* WIRE: CHANNELD_DEV_MEMLEAK_REPLY */
u8 *towire_channeld_dev_memleak_reply(const tal_t *ctx, bool leak)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_DEV_MEMLEAK_REPLY);
	towire_bool(&p, leak);

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_dev_memleak_reply(const void *p, bool *leak)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_DEV_MEMLEAK_REPLY)
		return false;
 	*leak = fromwire_bool(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: CHANNELD_FAIL_FALLEN_BEHIND */
/* Peer presented proof it was from the future. */
u8 *towire_channeld_fail_fallen_behind(const tal_t *ctx, const struct pubkey *remote_per_commitment_point)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_FAIL_FALLEN_BEHIND);
	/* This is NULL if option_static_remotekey. */
	if (!remote_per_commitment_point)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_pubkey(&p, remote_per_commitment_point);
	}

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_fail_fallen_behind(const tal_t *ctx, const void *p, struct pubkey **remote_per_commitment_point)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_FAIL_FALLEN_BEHIND)
		return false;
 	/* This is NULL if option_static_remotekey. */
	if (!fromwire_bool(&cursor, &plen))
		*remote_per_commitment_point = NULL;
	else {
		*remote_per_commitment_point = tal(ctx, struct pubkey);
		fromwire_pubkey(&cursor, &plen, *remote_per_commitment_point);
	}
	return cursor != NULL;
}

/* WIRE: CHANNELD_SPECIFIC_FEERATES */
/* Handle a channel specific feerate base ppm configuration */
u8 *towire_channeld_specific_feerates(const tal_t *ctx, u32 feerate_base, u32 feerate_ppm)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_SPECIFIC_FEERATES);
	towire_u32(&p, feerate_base);
	towire_u32(&p, feerate_ppm);

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_specific_feerates(const void *p, u32 *feerate_base, u32 *feerate_ppm)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_SPECIFIC_FEERATES)
		return false;
 	*feerate_base = fromwire_u32(&cursor, &plen);
 	*feerate_ppm = fromwire_u32(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: CHANNELD_GOT_ANNOUNCEMENT */
/* When we receive announcement_signatures for channel announce */
u8 *towire_channeld_got_announcement(const tal_t *ctx, const secp256k1_ecdsa_signature *remote_ann_node_sig, const secp256k1_ecdsa_signature *remote_ann_bitcoin_sig)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_GOT_ANNOUNCEMENT);
	towire_secp256k1_ecdsa_signature(&p, remote_ann_node_sig);
	towire_secp256k1_ecdsa_signature(&p, remote_ann_bitcoin_sig);

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_got_announcement(const void *p, secp256k1_ecdsa_signature *remote_ann_node_sig, secp256k1_ecdsa_signature *remote_ann_bitcoin_sig)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_GOT_ANNOUNCEMENT)
		return false;
 	fromwire_secp256k1_ecdsa_signature(&cursor, &plen, remote_ann_node_sig);
 	fromwire_secp256k1_ecdsa_signature(&cursor, &plen, remote_ann_bitcoin_sig);
	return cursor != NULL;
}

/* WIRE: CHANNELD_SEND_ERROR */
/* Ask channeld to send a error message. Used in forgetting channel case. */
u8 *towire_channeld_send_error(const tal_t *ctx, const wirestring *reason)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_SEND_ERROR);
	towire_wirestring(&p, reason);

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_send_error(const tal_t *ctx, const void *p, wirestring **reason)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_SEND_ERROR)
		return false;
 	*reason = fromwire_wirestring(ctx, &cursor, &plen);
	return cursor != NULL;
}

/* WIRE: CHANNELD_SEND_ERROR_REPLY */
/* Tell master channeld has sent the error message. */
u8 *towire_channeld_send_error_reply(const tal_t *ctx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_SEND_ERROR_REPLY);

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_send_error_reply(const void *p)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_SEND_ERROR_REPLY)
		return false;
	return cursor != NULL;
}

/* WIRE: CHANNELD_DEV_QUIESCE */
/* Ask channeld to quiesce. */
u8 *towire_channeld_dev_quiesce(const tal_t *ctx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_DEV_QUIESCE);

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_dev_quiesce(const void *p)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_DEV_QUIESCE)
		return false;
	return cursor != NULL;
}

/* WIRE: CHANNELD_DEV_QUIESCE_REPLY */
u8 *towire_channeld_dev_quiesce_reply(const tal_t *ctx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_DEV_QUIESCE_REPLY);

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_dev_quiesce_reply(const void *p)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_DEV_QUIESCE_REPLY)
		return false;
	return cursor != NULL;
}

/* WIRE: CHANNELD_UPGRADED */
/* Tell master we're upgrading the commitment tx. */
u8 *towire_channeld_upgraded(const tal_t *ctx, bool option_static_remotekey)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNELD_UPGRADED);
	towire_bool(&p, option_static_remotekey);

	return memcheck(p, tal_count(p));
}
bool fromwire_channeld_upgraded(const void *p, bool *option_static_remotekey)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNELD_UPGRADED)
		return false;
 	*option_static_remotekey = fromwire_bool(&cursor, &plen);
	return cursor != NULL;
}
// SHA256STAMP:2d7b763e89512ad8c5921b90c13f37ac83ab0016384c38e8c8e831683d668651
