/* This file was generated by generate-wire.py */
/* Do not modify this file! Modify the .csv file it was generated from. */
/* Original template can be found at tools/gen/impl_template */

#include <openingd/dualopend_wiregen.h>
#include <assert.h>
#include <ccan/array_size/array_size.h>
#include <ccan/mem/mem.h>
#include <ccan/tal/str/str.h>
#include <common/utils.h>
#include <stdio.h>

#ifndef SUPERVERBOSE
#define SUPERVERBOSE(...)
#endif


const char *dualopend_wire_name(int e)
{
	static char invalidbuf[sizeof("INVALID ") + STR_MAX_CHARS(e)];

	switch ((enum dualopend_wire)e) {
	case WIRE_DUAL_OPEN_INIT: return "WIRE_DUAL_OPEN_INIT";
	case WIRE_DUAL_OPEN_GOT_OFFER: return "WIRE_DUAL_OPEN_GOT_OFFER";
	case WIRE_DUAL_OPEN_GOT_OFFER_REPLY: return "WIRE_DUAL_OPEN_GOT_OFFER_REPLY";
	case WIRE_DUAL_OPEN_COMMIT_RCVD: return "WIRE_DUAL_OPEN_COMMIT_RCVD";
	case WIRE_DUAL_OPEN_PSBT_CHANGED: return "WIRE_DUAL_OPEN_PSBT_CHANGED";
	case WIRE_DUAL_OPEN_PSBT_UPDATED: return "WIRE_DUAL_OPEN_PSBT_UPDATED";
	case WIRE_DUAL_OPEN_FAIL: return "WIRE_DUAL_OPEN_FAIL";
	case WIRE_DUAL_OPEN_FAILED: return "WIRE_DUAL_OPEN_FAILED";
	case WIRE_DUAL_OPEN_OPENER_INIT: return "WIRE_DUAL_OPEN_OPENER_INIT";
	case WIRE_DUAL_OPEN_DEV_MEMLEAK: return "WIRE_DUAL_OPEN_DEV_MEMLEAK";
	case WIRE_DUAL_OPEN_DEV_MEMLEAK_REPLY: return "WIRE_DUAL_OPEN_DEV_MEMLEAK_REPLY";
	}

	snprintf(invalidbuf, sizeof(invalidbuf), "INVALID %i", e);
	return invalidbuf;
}

bool dualopend_wire_is_defined(u16 type)
{
	switch ((enum dualopend_wire)type) {
	case WIRE_DUAL_OPEN_INIT:;
	case WIRE_DUAL_OPEN_GOT_OFFER:;
	case WIRE_DUAL_OPEN_GOT_OFFER_REPLY:;
	case WIRE_DUAL_OPEN_COMMIT_RCVD:;
	case WIRE_DUAL_OPEN_PSBT_CHANGED:;
	case WIRE_DUAL_OPEN_PSBT_UPDATED:;
	case WIRE_DUAL_OPEN_FAIL:;
	case WIRE_DUAL_OPEN_FAILED:;
	case WIRE_DUAL_OPEN_OPENER_INIT:;
	case WIRE_DUAL_OPEN_DEV_MEMLEAK:;
	case WIRE_DUAL_OPEN_DEV_MEMLEAK_REPLY:;
	      return true;
	}
	return false;
}





/* WIRE: DUAL_OPEN_INIT */
u8 *towire_dual_open_init(const tal_t *ctx, const struct chainparams *chainparams, const struct feature_set *our_feature_set, const u8 *their_init_features, const struct channel_config *our_config, u32 max_to_self_delay, struct amount_msat min_effective_htlc_capacity_msat, const struct per_peer_state *pps, const struct basepoints *our_basepoints, const struct pubkey *our_funding_pubkey, u32 minimum_depth, u32 min_feerate, u32 max_feerate, const u8 *msg)
{
	u16 their_init_features_len = tal_count(their_init_features);
	u16 len = tal_count(msg);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_DUAL_OPEN_INIT);
	/* Which network are we configured for? */
	towire_chainparams(&p, chainparams);
	towire_feature_set(&p, our_feature_set);
	towire_u16(&p, their_init_features_len);
	towire_u8_array(&p, their_init_features, their_init_features_len);
	/* Base configuration we'll offer */
	towire_channel_config(&p, our_config);
	/* Minimum/maximum configuration values we'll accept */
	towire_u32(&p, max_to_self_delay);
	towire_amount_msat(&p, min_effective_htlc_capacity_msat);
	towire_per_peer_state(&p, pps);
	towire_basepoints(&p, our_basepoints);
	towire_pubkey(&p, our_funding_pubkey);
	/* Constraints in case the other end tries to open a channel. */
	towire_u32(&p, minimum_depth);
	towire_u32(&p, min_feerate);
	towire_u32(&p, max_feerate);
	/* Optional msg to send. */
	towire_u16(&p, len);
	towire_u8_array(&p, msg, len);

	return memcheck(p, tal_count(p));
}
bool fromwire_dual_open_init(const tal_t *ctx, const void *p, const struct chainparams **chainparams, struct feature_set **our_feature_set, u8 **their_init_features, struct channel_config *our_config, u32 *max_to_self_delay, struct amount_msat *min_effective_htlc_capacity_msat, struct per_peer_state **pps, struct basepoints *our_basepoints, struct pubkey *our_funding_pubkey, u32 *minimum_depth, u32 *min_feerate, u32 *max_feerate, u8 **msg)
{
	u16 their_init_features_len;
	u16 len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_DUAL_OPEN_INIT)
		return false;
 	/* Which network are we configured for? */
	fromwire_chainparams(&cursor, &plen, chainparams);
 	*our_feature_set = fromwire_feature_set(ctx, &cursor, &plen);
 	their_init_features_len = fromwire_u16(&cursor, &plen);
 	// 2nd case their_init_features
	*their_init_features = their_init_features_len ? tal_arr(ctx, u8, their_init_features_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *their_init_features, their_init_features_len);
 	/* Base configuration we'll offer */
	fromwire_channel_config(&cursor, &plen, our_config);
 	/* Minimum/maximum configuration values we'll accept */
	*max_to_self_delay = fromwire_u32(&cursor, &plen);
 	*min_effective_htlc_capacity_msat = fromwire_amount_msat(&cursor, &plen);
 	*pps = fromwire_per_peer_state(ctx, &cursor, &plen);
 	fromwire_basepoints(&cursor, &plen, our_basepoints);
 	fromwire_pubkey(&cursor, &plen, our_funding_pubkey);
 	/* Constraints in case the other end tries to open a channel. */
	*minimum_depth = fromwire_u32(&cursor, &plen);
 	*min_feerate = fromwire_u32(&cursor, &plen);
 	*max_feerate = fromwire_u32(&cursor, &plen);
 	/* Optional msg to send. */
	len = fromwire_u16(&cursor, &plen);
 	// 2nd case msg
	*msg = len ? tal_arr(ctx, u8, len) : NULL;
	fromwire_u8_array(&cursor, &plen, *msg, len);
	return cursor != NULL;
}

/* WIRE: DUAL_OPEN_GOT_OFFER */
/* dualopend->master: they offered channel */
u8 *towire_dual_open_got_offer(const tal_t *ctx, struct amount_sat opener_funding, struct amount_sat dust_limit_satoshis, struct amount_msat max_htlc_value_in_flight_msat, struct amount_msat htlc_minimum_msat, u32 feerate_funding_max, u32 feerate_funding_min, u32 feerate_funding_best, u32 feerate_per_kw, u16 to_self_delay, u16 max_accepted_htlcs, u8 channel_flags, u32 locktime, const u8 *shutdown_scriptpubkey)
{
	u16 shutdown_len = tal_count(shutdown_scriptpubkey);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_DUAL_OPEN_GOT_OFFER);
	towire_amount_sat(&p, opener_funding);
	towire_amount_sat(&p, dust_limit_satoshis);
	towire_amount_msat(&p, max_htlc_value_in_flight_msat);
	towire_amount_msat(&p, htlc_minimum_msat);
	towire_u32(&p, feerate_funding_max);
	towire_u32(&p, feerate_funding_min);
	towire_u32(&p, feerate_funding_best);
	towire_u32(&p, feerate_per_kw);
	towire_u16(&p, to_self_delay);
	towire_u16(&p, max_accepted_htlcs);
	towire_u8(&p, channel_flags);
	towire_u32(&p, locktime);
	towire_u16(&p, shutdown_len);
	towire_u8_array(&p, shutdown_scriptpubkey, shutdown_len);

	return memcheck(p, tal_count(p));
}
bool fromwire_dual_open_got_offer(const tal_t *ctx, const void *p, struct amount_sat *opener_funding, struct amount_sat *dust_limit_satoshis, struct amount_msat *max_htlc_value_in_flight_msat, struct amount_msat *htlc_minimum_msat, u32 *feerate_funding_max, u32 *feerate_funding_min, u32 *feerate_funding_best, u32 *feerate_per_kw, u16 *to_self_delay, u16 *max_accepted_htlcs, u8 *channel_flags, u32 *locktime, u8 **shutdown_scriptpubkey)
{
	u16 shutdown_len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_DUAL_OPEN_GOT_OFFER)
		return false;
 	*opener_funding = fromwire_amount_sat(&cursor, &plen);
 	*dust_limit_satoshis = fromwire_amount_sat(&cursor, &plen);
 	*max_htlc_value_in_flight_msat = fromwire_amount_msat(&cursor, &plen);
 	*htlc_minimum_msat = fromwire_amount_msat(&cursor, &plen);
 	*feerate_funding_max = fromwire_u32(&cursor, &plen);
 	*feerate_funding_min = fromwire_u32(&cursor, &plen);
 	*feerate_funding_best = fromwire_u32(&cursor, &plen);
 	*feerate_per_kw = fromwire_u32(&cursor, &plen);
 	*to_self_delay = fromwire_u16(&cursor, &plen);
 	*max_accepted_htlcs = fromwire_u16(&cursor, &plen);
 	*channel_flags = fromwire_u8(&cursor, &plen);
 	*locktime = fromwire_u32(&cursor, &plen);
 	shutdown_len = fromwire_u16(&cursor, &plen);
 	// 2nd case shutdown_scriptpubkey
	*shutdown_scriptpubkey = shutdown_len ? tal_arr(ctx, u8, shutdown_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *shutdown_scriptpubkey, shutdown_len);
	return cursor != NULL;
}

/* WIRE: DUAL_OPEN_GOT_OFFER_REPLY */
/* master->dualopend: reply back with our first funding info/contribs */
u8 *towire_dual_open_got_offer_reply(const tal_t *ctx, struct amount_sat accepter_funding, u32 feerate_funding, const struct wally_psbt *psbt, const u8 *our_shutdown_scriptpubkey)
{
	u16 shutdown_len = tal_count(our_shutdown_scriptpubkey);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_DUAL_OPEN_GOT_OFFER_REPLY);
	towire_amount_sat(&p, accepter_funding);
	towire_u32(&p, feerate_funding);
	towire_wally_psbt(&p, psbt);
	towire_u16(&p, shutdown_len);
	towire_u8_array(&p, our_shutdown_scriptpubkey, shutdown_len);

	return memcheck(p, tal_count(p));
}
bool fromwire_dual_open_got_offer_reply(const tal_t *ctx, const void *p, struct amount_sat *accepter_funding, u32 *feerate_funding, struct wally_psbt **psbt, u8 **our_shutdown_scriptpubkey)
{
	u16 shutdown_len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_DUAL_OPEN_GOT_OFFER_REPLY)
		return false;
 	*accepter_funding = fromwire_amount_sat(&cursor, &plen);
 	*feerate_funding = fromwire_u32(&cursor, &plen);
 	*psbt = fromwire_wally_psbt(ctx, &cursor, &plen);
 	shutdown_len = fromwire_u16(&cursor, &plen);
 	// 2nd case our_shutdown_scriptpubkey
	*our_shutdown_scriptpubkey = shutdown_len ? tal_arr(ctx, u8, shutdown_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *our_shutdown_scriptpubkey, shutdown_len);
	return cursor != NULL;
}

/* WIRE: DUAL_OPEN_COMMIT_RCVD */
/* dualopend->master: ready to commit channel open to database and */
/*                    get some signatures for the funding_tx. */
u8 *towire_dual_open_commit_rcvd(const tal_t *ctx, const struct channel_config *their_config, const struct bitcoin_tx *remote_first_commit, const struct penalty_base *pbase, const struct bitcoin_signature *first_commit_sig, const struct wally_psbt *psbt, const struct channel_id *channel_id, const struct per_peer_state *pps, const struct pubkey *revocation_basepoint, const struct pubkey *payment_basepoint, const struct pubkey *htlc_basepoint, const struct pubkey *delayed_payment_basepoint, const struct pubkey *their_per_commit_point, const struct pubkey *remote_fundingkey, const struct bitcoin_txid *funding_txid, u16 funding_txout, struct amount_sat funding_satoshis, struct amount_sat our_funding_sats, u8 channel_flags, u32 feerate_per_kw, const u8 *commitment_msg, struct amount_sat our_channel_reserve_satoshis, const u8 *local_shutdown_scriptpubkey, const u8 *remote_shutdown_scriptpubkey)
{
	u16 msglen = tal_count(commitment_msg);
	u16 local_shutdown_len = tal_count(local_shutdown_scriptpubkey);
	u16 remote_shutdown_len = tal_count(remote_shutdown_scriptpubkey);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_DUAL_OPEN_COMMIT_RCVD);
	towire_channel_config(&p, their_config);
	towire_bitcoin_tx(&p, remote_first_commit);
	if (!pbase)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_penalty_base(&p, pbase);
	}
	towire_bitcoin_signature(&p, first_commit_sig);
	towire_wally_psbt(&p, psbt);
	towire_channel_id(&p, channel_id);
	towire_per_peer_state(&p, pps);
	towire_pubkey(&p, revocation_basepoint);
	towire_pubkey(&p, payment_basepoint);
	towire_pubkey(&p, htlc_basepoint);
	towire_pubkey(&p, delayed_payment_basepoint);
	towire_pubkey(&p, their_per_commit_point);
	towire_pubkey(&p, remote_fundingkey);
	towire_bitcoin_txid(&p, funding_txid);
	towire_u16(&p, funding_txout);
	towire_amount_sat(&p, funding_satoshis);
	towire_amount_sat(&p, our_funding_sats);
	towire_u8(&p, channel_flags);
	towire_u32(&p, feerate_per_kw);
	/* our commitment signatures */
	towire_u16(&p, msglen);
	towire_u8_array(&p, commitment_msg, msglen);
	towire_amount_sat(&p, our_channel_reserve_satoshis);
	towire_u16(&p, local_shutdown_len);
	towire_u8_array(&p, local_shutdown_scriptpubkey, local_shutdown_len);
	towire_u16(&p, remote_shutdown_len);
	towire_u8_array(&p, remote_shutdown_scriptpubkey, remote_shutdown_len);

	return memcheck(p, tal_count(p));
}
bool fromwire_dual_open_commit_rcvd(const tal_t *ctx, const void *p, struct channel_config *their_config, struct bitcoin_tx **remote_first_commit, struct penalty_base **pbase, struct bitcoin_signature *first_commit_sig, struct wally_psbt **psbt, struct channel_id *channel_id, struct per_peer_state **pps, struct pubkey *revocation_basepoint, struct pubkey *payment_basepoint, struct pubkey *htlc_basepoint, struct pubkey *delayed_payment_basepoint, struct pubkey *their_per_commit_point, struct pubkey *remote_fundingkey, struct bitcoin_txid *funding_txid, u16 *funding_txout, struct amount_sat *funding_satoshis, struct amount_sat *our_funding_sats, u8 *channel_flags, u32 *feerate_per_kw, u8 **commitment_msg, struct amount_sat *our_channel_reserve_satoshis, u8 **local_shutdown_scriptpubkey, u8 **remote_shutdown_scriptpubkey)
{
	u16 msglen;
	u16 local_shutdown_len;
	u16 remote_shutdown_len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_DUAL_OPEN_COMMIT_RCVD)
		return false;
 	fromwire_channel_config(&cursor, &plen, their_config);
 	*remote_first_commit = fromwire_bitcoin_tx(ctx, &cursor, &plen);
 	if (!fromwire_bool(&cursor, &plen))
		*pbase = NULL;
	else {
		*pbase = tal(ctx, struct penalty_base);
		fromwire_penalty_base(&cursor, &plen, *pbase);
	}
 	fromwire_bitcoin_signature(&cursor, &plen, first_commit_sig);
 	*psbt = fromwire_wally_psbt(ctx, &cursor, &plen);
 	fromwire_channel_id(&cursor, &plen, channel_id);
 	*pps = fromwire_per_peer_state(ctx, &cursor, &plen);
 	fromwire_pubkey(&cursor, &plen, revocation_basepoint);
 	fromwire_pubkey(&cursor, &plen, payment_basepoint);
 	fromwire_pubkey(&cursor, &plen, htlc_basepoint);
 	fromwire_pubkey(&cursor, &plen, delayed_payment_basepoint);
 	fromwire_pubkey(&cursor, &plen, their_per_commit_point);
 	fromwire_pubkey(&cursor, &plen, remote_fundingkey);
 	fromwire_bitcoin_txid(&cursor, &plen, funding_txid);
 	*funding_txout = fromwire_u16(&cursor, &plen);
 	*funding_satoshis = fromwire_amount_sat(&cursor, &plen);
 	*our_funding_sats = fromwire_amount_sat(&cursor, &plen);
 	*channel_flags = fromwire_u8(&cursor, &plen);
 	*feerate_per_kw = fromwire_u32(&cursor, &plen);
 	/* our commitment signatures */
	msglen = fromwire_u16(&cursor, &plen);
 	// 2nd case commitment_msg
	*commitment_msg = msglen ? tal_arr(ctx, u8, msglen) : NULL;
	fromwire_u8_array(&cursor, &plen, *commitment_msg, msglen);
 	*our_channel_reserve_satoshis = fromwire_amount_sat(&cursor, &plen);
 	local_shutdown_len = fromwire_u16(&cursor, &plen);
 	// 2nd case local_shutdown_scriptpubkey
	*local_shutdown_scriptpubkey = local_shutdown_len ? tal_arr(ctx, u8, local_shutdown_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *local_shutdown_scriptpubkey, local_shutdown_len);
 	remote_shutdown_len = fromwire_u16(&cursor, &plen);
 	// 2nd case remote_shutdown_scriptpubkey
	*remote_shutdown_scriptpubkey = remote_shutdown_len ? tal_arr(ctx, u8, remote_shutdown_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *remote_shutdown_scriptpubkey, remote_shutdown_len);
	return cursor != NULL;
}

/* WIRE: DUAL_OPEN_PSBT_CHANGED */
/* dualopend->master: peer updated the psbt */
u8 *towire_dual_open_psbt_changed(const tal_t *ctx, const struct channel_id *channel_id, u64 funding_serial, const struct wally_psbt *psbt)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_DUAL_OPEN_PSBT_CHANGED);
	towire_channel_id(&p, channel_id);
	towire_u64(&p, funding_serial);
	towire_wally_psbt(&p, psbt);

	return memcheck(p, tal_count(p));
}
bool fromwire_dual_open_psbt_changed(const tal_t *ctx, const void *p, struct channel_id *channel_id, u64 *funding_serial, struct wally_psbt **psbt)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_DUAL_OPEN_PSBT_CHANGED)
		return false;
 	fromwire_channel_id(&cursor, &plen, channel_id);
 	*funding_serial = fromwire_u64(&cursor, &plen);
 	*psbt = fromwire_wally_psbt(ctx, &cursor, &plen);
	return cursor != NULL;
}

/* WIRE: DUAL_OPEN_PSBT_UPDATED */
/* master->dualopend: we updated the psbt */
u8 *towire_dual_open_psbt_updated(const tal_t *ctx, const struct wally_psbt *psbt)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_DUAL_OPEN_PSBT_UPDATED);
	towire_wally_psbt(&p, psbt);

	return memcheck(p, tal_count(p));
}
bool fromwire_dual_open_psbt_updated(const tal_t *ctx, const void *p, struct wally_psbt **psbt)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_DUAL_OPEN_PSBT_UPDATED)
		return false;
 	*psbt = fromwire_wally_psbt(ctx, &cursor, &plen);
	return cursor != NULL;
}

/* WIRE: DUAL_OPEN_FAIL */
/* master->dualopend: fail this channel open */
u8 *towire_dual_open_fail(const tal_t *ctx, const wirestring *reason)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_DUAL_OPEN_FAIL);
	towire_wirestring(&p, reason);

	return memcheck(p, tal_count(p));
}
bool fromwire_dual_open_fail(const tal_t *ctx, const void *p, wirestring **reason)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_DUAL_OPEN_FAIL)
		return false;
 	*reason = fromwire_wirestring(ctx, &cursor, &plen);
	return cursor != NULL;
}

/* WIRE: DUAL_OPEN_FAILED */
/* dualopend->master: we failed to negotiate channel */
u8 *towire_dual_open_failed(const tal_t *ctx, const wirestring *reason)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_DUAL_OPEN_FAILED);
	towire_wirestring(&p, reason);

	return memcheck(p, tal_count(p));
}
bool fromwire_dual_open_failed(const tal_t *ctx, const void *p, wirestring **reason)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_DUAL_OPEN_FAILED)
		return false;
 	*reason = fromwire_wirestring(ctx, &cursor, &plen);
	return cursor != NULL;
}

/* WIRE: DUAL_OPEN_OPENER_INIT */
/* master->dualopend: hello */
u8 *towire_dual_open_opener_init(const tal_t *ctx, const struct wally_psbt *psbt, struct amount_sat funding_amount, const u8 *local_shutdown_scriptpubkey, u32 feerate_per_kw, u32 feerate_per_kw_funding, u8 channel_flags)
{
	u16 local_shutdown_len = tal_count(local_shutdown_scriptpubkey);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_DUAL_OPEN_OPENER_INIT);
	towire_wally_psbt(&p, psbt);
	towire_amount_sat(&p, funding_amount);
	towire_u16(&p, local_shutdown_len);
	towire_u8_array(&p, local_shutdown_scriptpubkey, local_shutdown_len);
	towire_u32(&p, feerate_per_kw);
	towire_u32(&p, feerate_per_kw_funding);
	towire_u8(&p, channel_flags);

	return memcheck(p, tal_count(p));
}
bool fromwire_dual_open_opener_init(const tal_t *ctx, const void *p, struct wally_psbt **psbt, struct amount_sat *funding_amount, u8 **local_shutdown_scriptpubkey, u32 *feerate_per_kw, u32 *feerate_per_kw_funding, u8 *channel_flags)
{
	u16 local_shutdown_len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_DUAL_OPEN_OPENER_INIT)
		return false;
 	*psbt = fromwire_wally_psbt(ctx, &cursor, &plen);
 	*funding_amount = fromwire_amount_sat(&cursor, &plen);
 	local_shutdown_len = fromwire_u16(&cursor, &plen);
 	// 2nd case local_shutdown_scriptpubkey
	*local_shutdown_scriptpubkey = local_shutdown_len ? tal_arr(ctx, u8, local_shutdown_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *local_shutdown_scriptpubkey, local_shutdown_len);
 	*feerate_per_kw = fromwire_u32(&cursor, &plen);
 	*feerate_per_kw_funding = fromwire_u32(&cursor, &plen);
 	*channel_flags = fromwire_u8(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: DUAL_OPEN_DEV_MEMLEAK */
/* master -> dualopend: do you have a memleak? */
u8 *towire_dual_open_dev_memleak(const tal_t *ctx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_DUAL_OPEN_DEV_MEMLEAK);

	return memcheck(p, tal_count(p));
}
bool fromwire_dual_open_dev_memleak(const void *p)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_DUAL_OPEN_DEV_MEMLEAK)
		return false;
	return cursor != NULL;
}

/* WIRE: DUAL_OPEN_DEV_MEMLEAK_REPLY */
u8 *towire_dual_open_dev_memleak_reply(const tal_t *ctx, bool leak)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_DUAL_OPEN_DEV_MEMLEAK_REPLY);
	towire_bool(&p, leak);

	return memcheck(p, tal_count(p));
}
bool fromwire_dual_open_dev_memleak_reply(const void *p, bool *leak)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_DUAL_OPEN_DEV_MEMLEAK_REPLY)
		return false;
 	*leak = fromwire_bool(&cursor, &plen);
	return cursor != NULL;
}
// SHA256STAMP:f08f0c25f359d5c8f843d78c94eca9b0543b39e62a34983f6572adf92ff02aaa
