// This file is autogenerated by `msggen`
// Do not edit it manually, your changes will be overwritten



use crate::primitives::*;
use serde::{Serialize, Deserialize};
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum Notification {
    #[serde(rename = "block_added")]
    BlockAdded(BlockAddedNotification),
    #[serde(rename = "channel_open_failed")]
    ChannelOpenFailed(ChannelOpenFailedNotification),
    #[serde(rename = "channel_opened")]
    ChannelOpened(ChannelOpenedNotification),
    #[serde(rename = "connect")]
    Connect(ConnectNotification),
    #[serde(rename = "custommsg")]
    CustomMsg(CustomMsgNotification),
}


#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BlockAddedNotification {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hash: Option<Sha256>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub height: Option<u32>,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ChannelOpenFailedNotification {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub channel_id: Option<Sha256>,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ChannelOpenedNotification {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub channel_ready: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub funding_msat: Option<Amount>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub funding_txid: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<PublicKey>,
}

#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
pub enum ConnectDirection {
    #[serde(rename = "in")]
    IN = 0,
    #[serde(rename = "out")]
    OUT = 1,
}

impl TryFrom<i32> for ConnectDirection {
    type Error = anyhow::Error;
    fn try_from(c: i32) -> Result<ConnectDirection, anyhow::Error> {
        match c {
    0 => Ok(ConnectDirection::IN),
    1 => Ok(ConnectDirection::OUT),
            o => Err(anyhow::anyhow!("Unknown variant {} for enum ConnectDirection", o)),
        }
    }
}

impl ToString for ConnectDirection {
    fn to_string(&self) -> String {
        match self {
            ConnectDirection::IN => "IN",
            ConnectDirection::OUT => "OUT",
        }.to_string()
    }
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ConnectNotification {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub direction: Option<ConnectDirection>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<PublicKey>,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct CustomMsgNotification {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub payload: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub peer_id: Option<PublicKey>,
}

