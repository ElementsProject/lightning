#![allow(non_camel_case_types)]
//
// This file was automatically generated using the following command:
//
// ```bash
// contrib/msggen/msggen/__main__.py generate
// ```
//
// Do not edit this file, it'll be overwritten. Rather edit the schema that
// this file was generated from

//! A collection of models to describe [requests] and [responses].
//!
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(tag = "method", content = "params")]
#[serde(rename_all = "lowercase")]
pub enum Request {
	Getinfo(requests::GetinfoRequest),
	ListPeers(requests::ListpeersRequest),
	ListFunds(requests::ListfundsRequest),
	SendPay(requests::SendpayRequest),
	ListChannels(requests::ListchannelsRequest),
	AddGossip(requests::AddgossipRequest),
	AutoCleanInvoice(requests::AutocleaninvoiceRequest),
	CheckMessage(requests::CheckmessageRequest),
	Close(requests::CloseRequest),
	Connect(requests::ConnectRequest),
	CreateInvoice(requests::CreateinvoiceRequest),
	Datastore(requests::DatastoreRequest),
	DatastoreUsage(requests::DatastoreusageRequest),
	CreateOnion(requests::CreateonionRequest),
	DelDatastore(requests::DeldatastoreRequest),
	DelInvoice(requests::DelinvoiceRequest),
	Invoice(requests::InvoiceRequest),
	ListDatastore(requests::ListdatastoreRequest),
	ListInvoices(requests::ListinvoicesRequest),
	SendOnion(requests::SendonionRequest),
	ListSendPays(requests::ListsendpaysRequest),
	ListTransactions(requests::ListtransactionsRequest),
	Pay(requests::PayRequest),
	ListNodes(requests::ListnodesRequest),
	WaitAnyInvoice(requests::WaitanyinvoiceRequest),
	WaitInvoice(requests::WaitinvoiceRequest),
	WaitSendPay(requests::WaitsendpayRequest),
	NewAddr(requests::NewaddrRequest),
	Withdraw(requests::WithdrawRequest),
	KeySend(requests::KeysendRequest),
	FundPsbt(requests::FundpsbtRequest),
	SendPsbt(requests::SendpsbtRequest),
	SignPsbt(requests::SignpsbtRequest),
	UtxoPsbt(requests::UtxopsbtRequest),
	TxDiscard(requests::TxdiscardRequest),
	TxPrepare(requests::TxprepareRequest),
	TxSend(requests::TxsendRequest),
	ListPeerChannels(requests::ListpeerchannelsRequest),
	ListClosedChannels(requests::ListclosedchannelsRequest),
	DecodePay(requests::DecodepayRequest),
	Decode(requests::DecodeRequest),
	Disconnect(requests::DisconnectRequest),
	Feerates(requests::FeeratesRequest),
	FetchInvoice(requests::FetchinvoiceRequest),
	FundChannel(requests::FundchannelRequest),
	GetRoute(requests::GetrouteRequest),
	ListForwards(requests::ListforwardsRequest),
	ListOffers(requests::ListoffersRequest),
	ListPays(requests::ListpaysRequest),
	ListHtlcs(requests::ListhtlcsRequest),
	Offer(requests::OfferRequest),
	Ping(requests::PingRequest),
	SendCustomMsg(requests::SendcustommsgRequest),
	SetChannel(requests::SetchannelRequest),
	SignInvoice(requests::SigninvoiceRequest),
	SignMessage(requests::SignmessageRequest),
	WaitBlockHeight(requests::WaitblockheightRequest),
	Wait(requests::WaitRequest),
	Stop(requests::StopRequest),
	PreApproveKeysend(requests::PreapprovekeysendRequest),
	PreApproveInvoice(requests::PreapproveinvoiceRequest),
	StaticBackup(requests::StaticbackupRequest),
	BkprListIncome(requests::BkprlistincomeRequest),
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(tag = "method", content = "result")]
#[serde(rename_all = "lowercase")]
pub enum Response {
	Getinfo(responses::GetinfoResponse),
	ListPeers(responses::ListpeersResponse),
	ListFunds(responses::ListfundsResponse),
	SendPay(responses::SendpayResponse),
	ListChannels(responses::ListchannelsResponse),
	AddGossip(responses::AddgossipResponse),
	AutoCleanInvoice(responses::AutocleaninvoiceResponse),
	CheckMessage(responses::CheckmessageResponse),
	Close(responses::CloseResponse),
	Connect(responses::ConnectResponse),
	CreateInvoice(responses::CreateinvoiceResponse),
	Datastore(responses::DatastoreResponse),
	DatastoreUsage(responses::DatastoreusageResponse),
	CreateOnion(responses::CreateonionResponse),
	DelDatastore(responses::DeldatastoreResponse),
	DelInvoice(responses::DelinvoiceResponse),
	Invoice(responses::InvoiceResponse),
	ListDatastore(responses::ListdatastoreResponse),
	ListInvoices(responses::ListinvoicesResponse),
	SendOnion(responses::SendonionResponse),
	ListSendPays(responses::ListsendpaysResponse),
	ListTransactions(responses::ListtransactionsResponse),
	Pay(responses::PayResponse),
	ListNodes(responses::ListnodesResponse),
	WaitAnyInvoice(responses::WaitanyinvoiceResponse),
	WaitInvoice(responses::WaitinvoiceResponse),
	WaitSendPay(responses::WaitsendpayResponse),
	NewAddr(responses::NewaddrResponse),
	Withdraw(responses::WithdrawResponse),
	KeySend(responses::KeysendResponse),
	FundPsbt(responses::FundpsbtResponse),
	SendPsbt(responses::SendpsbtResponse),
	SignPsbt(responses::SignpsbtResponse),
	UtxoPsbt(responses::UtxopsbtResponse),
	TxDiscard(responses::TxdiscardResponse),
	TxPrepare(responses::TxprepareResponse),
	TxSend(responses::TxsendResponse),
	ListPeerChannels(responses::ListpeerchannelsResponse),
	ListClosedChannels(responses::ListclosedchannelsResponse),
	DecodePay(responses::DecodepayResponse),
	Decode(responses::DecodeResponse),
	Disconnect(responses::DisconnectResponse),
	Feerates(responses::FeeratesResponse),
	FetchInvoice(responses::FetchinvoiceResponse),
	FundChannel(responses::FundchannelResponse),
	GetRoute(responses::GetrouteResponse),
	ListForwards(responses::ListforwardsResponse),
	ListOffers(responses::ListoffersResponse),
	ListPays(responses::ListpaysResponse),
	ListHtlcs(responses::ListhtlcsResponse),
	Offer(responses::OfferResponse),
	Ping(responses::PingResponse),
	SendCustomMsg(responses::SendcustommsgResponse),
	SetChannel(responses::SetchannelResponse),
	SignInvoice(responses::SigninvoiceResponse),
	SignMessage(responses::SignmessageResponse),
	WaitBlockHeight(responses::WaitblockheightResponse),
	Wait(responses::WaitResponse),
	Stop(responses::StopResponse),
	PreApproveKeysend(responses::PreapprovekeysendResponse),
	PreApproveInvoice(responses::PreapproveinvoiceResponse),
	StaticBackup(responses::StaticbackupResponse),
	BkprListIncome(responses::BkprlistincomeResponse),
}


pub trait IntoRequest: Into<Request> {
    type Response: TryFrom<Response, Error = TryFromResponseError>;
}

pub trait TypedRequest {
    type Response;

    fn method(&self) -> &str;
}

#[derive(Debug)]
pub struct TryFromResponseError;

pub mod requests {
    #[allow(unused_imports)]
    use crate::primitives::*;
    #[allow(unused_imports)]
    use serde::{{Deserialize, Serialize}};
    use core::fmt::Debug;
    use super::{IntoRequest, Request, TypedRequest};
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetinfoRequest {
	}

	impl From<GetinfoRequest> for Request {
	    fn from(r: GetinfoRequest) -> Self {
	        Request::Getinfo(r)
	    }
	}

	impl IntoRequest for GetinfoRequest {
	    type Response = super::responses::GetinfoResponse;
	}

	impl TypedRequest for GetinfoRequest {
	    type Response = super::responses::GetinfoResponse;

	    fn method(&self) -> &str {
	        "getinfo"
	    }
	}
	/// ['Supplying level will show log entries related to that peer at the given log level.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListpeersLevel {
	    #[serde(rename = "io")]
	    IO,
	    #[serde(rename = "debug")]
	    DEBUG,
	    #[serde(rename = "info")]
	    INFO,
	    #[serde(rename = "unusual")]
	    UNUSUAL,
	}

	impl TryFrom<i32> for ListpeersLevel {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListpeersLevel, anyhow::Error> {
	        match c {
	    0 => Ok(ListpeersLevel::IO),
	    1 => Ok(ListpeersLevel::DEBUG),
	    2 => Ok(ListpeersLevel::INFO),
	    3 => Ok(ListpeersLevel::UNUSUAL),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListpeersLevel", o)),
	        }
	    }
	}

	impl ToString for ListpeersLevel {
	    fn to_string(&self) -> String {
	        match self {
	            ListpeersLevel::IO => "IO",
	            ListpeersLevel::DEBUG => "DEBUG",
	            ListpeersLevel::INFO => "INFO",
	            ListpeersLevel::UNUSUAL => "UNUSUAL",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeersRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub id: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub level: Option<ListpeersLevel>,
	}

	impl From<ListpeersRequest> for Request {
	    fn from(r: ListpeersRequest) -> Self {
	        Request::ListPeers(r)
	    }
	}

	impl IntoRequest for ListpeersRequest {
	    type Response = super::responses::ListpeersResponse;
	}

	impl TypedRequest for ListpeersRequest {
	    type Response = super::responses::ListpeersResponse;

	    fn method(&self) -> &str {
	        "listpeers"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListfundsRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub spent: Option<bool>,
	}

	impl From<ListfundsRequest> for Request {
	    fn from(r: ListfundsRequest) -> Self {
	        Request::ListFunds(r)
	    }
	}

	impl IntoRequest for ListfundsRequest {
	    type Response = super::responses::ListfundsResponse;
	}

	impl TypedRequest for ListfundsRequest {
	    type Response = super::responses::ListfundsResponse;

	    fn method(&self) -> &str {
	        "listfunds"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendpayRoute {
	    pub id: PublicKey,
	    pub channel: ShortChannelId,
	    pub delay: u32,
	    pub amount_msat: Amount,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendpayRequest {
	    pub route: Vec<SendpayRoute>,
	    pub payment_hash: Sha256,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_secret: Option<Secret>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub localinvreqid: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub groupid: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_metadata: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	}

	impl From<SendpayRequest> for Request {
	    fn from(r: SendpayRequest) -> Self {
	        Request::SendPay(r)
	    }
	}

	impl IntoRequest for SendpayRequest {
	    type Response = super::responses::SendpayResponse;
	}

	impl TypedRequest for SendpayRequest {
	    type Response = super::responses::SendpayResponse;

	    fn method(&self) -> &str {
	        "sendpay"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListchannelsRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub short_channel_id: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub source: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	}

	impl From<ListchannelsRequest> for Request {
	    fn from(r: ListchannelsRequest) -> Self {
	        Request::ListChannels(r)
	    }
	}

	impl IntoRequest for ListchannelsRequest {
	    type Response = super::responses::ListchannelsResponse;
	}

	impl TypedRequest for ListchannelsRequest {
	    type Response = super::responses::ListchannelsResponse;

	    fn method(&self) -> &str {
	        "listchannels"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AddgossipRequest {
	    pub message: String,
	}

	impl From<AddgossipRequest> for Request {
	    fn from(r: AddgossipRequest) -> Self {
	        Request::AddGossip(r)
	    }
	}

	impl IntoRequest for AddgossipRequest {
	    type Response = super::responses::AddgossipResponse;
	}

	impl TypedRequest for AddgossipRequest {
	    type Response = super::responses::AddgossipResponse;

	    fn method(&self) -> &str {
	        "addgossip"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AutocleaninvoiceRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub expired_by: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub cycle_seconds: Option<u64>,
	}

	impl From<AutocleaninvoiceRequest> for Request {
	    fn from(r: AutocleaninvoiceRequest) -> Self {
	        Request::AutoCleanInvoice(r)
	    }
	}

	impl IntoRequest for AutocleaninvoiceRequest {
	    type Response = super::responses::AutocleaninvoiceResponse;
	}

	impl TypedRequest for AutocleaninvoiceRequest {
	    type Response = super::responses::AutocleaninvoiceResponse;

	    fn method(&self) -> &str {
	        "autocleaninvoice"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CheckmessageRequest {
	    pub message: String,
	    pub zbase: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub pubkey: Option<PublicKey>,
	}

	impl From<CheckmessageRequest> for Request {
	    fn from(r: CheckmessageRequest) -> Self {
	        Request::CheckMessage(r)
	    }
	}

	impl IntoRequest for CheckmessageRequest {
	    type Response = super::responses::CheckmessageResponse;
	}

	impl TypedRequest for CheckmessageRequest {
	    type Response = super::responses::CheckmessageResponse;

	    fn method(&self) -> &str {
	        "checkmessage"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CloseRequest {
	    pub id: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub unilateraltimeout: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_negotiation_step: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub wrong_funding: Option<Outpoint>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub force_lease_closed: Option<bool>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub feerange: Option<Vec<Feerate>>,
	}

	impl From<CloseRequest> for Request {
	    fn from(r: CloseRequest) -> Self {
	        Request::Close(r)
	    }
	}

	impl IntoRequest for CloseRequest {
	    type Response = super::responses::CloseResponse;
	}

	impl TypedRequest for CloseRequest {
	    type Response = super::responses::CloseResponse;

	    fn method(&self) -> &str {
	        "close"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ConnectRequest {
	    pub id: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub host: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub port: Option<u16>,
	}

	impl From<ConnectRequest> for Request {
	    fn from(r: ConnectRequest) -> Self {
	        Request::Connect(r)
	    }
	}

	impl IntoRequest for ConnectRequest {
	    type Response = super::responses::ConnectResponse;
	}

	impl TypedRequest for ConnectRequest {
	    type Response = super::responses::ConnectResponse;

	    fn method(&self) -> &str {
	        "connect"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CreateinvoiceRequest {
	    pub invstring: String,
	    pub label: String,
	    pub preimage: String,
	}

	impl From<CreateinvoiceRequest> for Request {
	    fn from(r: CreateinvoiceRequest) -> Self {
	        Request::CreateInvoice(r)
	    }
	}

	impl IntoRequest for CreateinvoiceRequest {
	    type Response = super::responses::CreateinvoiceResponse;
	}

	impl TypedRequest for CreateinvoiceRequest {
	    type Response = super::responses::CreateinvoiceResponse;

	    fn method(&self) -> &str {
	        "createinvoice"
	    }
	}
	/// ['Write mode to determine how the record is updated:', '    * `must-create`: fails if it already exists.', "    * `must-replace`: fails if it doesn't already exist.", '    * `create-or-replace`: never fails.', "    * `must-append`: must already exist, append this to what's already there.", '    * `create-or-append`: append if anything is there, otherwise create.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum DatastoreMode {
	    #[serde(rename = "must-create")]
	    MUST_CREATE,
	    #[serde(rename = "must-replace")]
	    MUST_REPLACE,
	    #[serde(rename = "create-or-replace")]
	    CREATE_OR_REPLACE,
	    #[serde(rename = "must-append")]
	    MUST_APPEND,
	    #[serde(rename = "create-or-append")]
	    CREATE_OR_APPEND,
	}

	impl TryFrom<i32> for DatastoreMode {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<DatastoreMode, anyhow::Error> {
	        match c {
	    0 => Ok(DatastoreMode::MUST_CREATE),
	    1 => Ok(DatastoreMode::MUST_REPLACE),
	    2 => Ok(DatastoreMode::CREATE_OR_REPLACE),
	    3 => Ok(DatastoreMode::MUST_APPEND),
	    4 => Ok(DatastoreMode::CREATE_OR_APPEND),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum DatastoreMode", o)),
	        }
	    }
	}

	impl ToString for DatastoreMode {
	    fn to_string(&self) -> String {
	        match self {
	            DatastoreMode::MUST_CREATE => "MUST_CREATE",
	            DatastoreMode::MUST_REPLACE => "MUST_REPLACE",
	            DatastoreMode::CREATE_OR_REPLACE => "CREATE_OR_REPLACE",
	            DatastoreMode::MUST_APPEND => "MUST_APPEND",
	            DatastoreMode::CREATE_OR_APPEND => "CREATE_OR_APPEND",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DatastoreRequest {
	    pub key: Vec<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub string: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub hex: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub mode: Option<DatastoreMode>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub generation: Option<u64>,
	}

	impl From<DatastoreRequest> for Request {
	    fn from(r: DatastoreRequest) -> Self {
	        Request::Datastore(r)
	    }
	}

	impl IntoRequest for DatastoreRequest {
	    type Response = super::responses::DatastoreResponse;
	}

	impl TypedRequest for DatastoreRequest {
	    type Response = super::responses::DatastoreResponse;

	    fn method(&self) -> &str {
	        "datastore"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DatastoreusageRequest {
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub key: Option<Vec<String>>,
	}

	impl From<DatastoreusageRequest> for Request {
	    fn from(r: DatastoreusageRequest) -> Self {
	        Request::DatastoreUsage(r)
	    }
	}

	impl IntoRequest for DatastoreusageRequest {
	    type Response = super::responses::DatastoreusageResponse;
	}

	impl TypedRequest for DatastoreusageRequest {
	    type Response = super::responses::DatastoreusageResponse;

	    fn method(&self) -> &str {
	        "datastoreusage"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CreateonionHops {
	    pub pubkey: PublicKey,
	    pub payload: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CreateonionRequest {
	    pub hops: Vec<CreateonionHops>,
	    pub assocdata: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub session_key: Option<Secret>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub onion_size: Option<u16>,
	}

	impl From<CreateonionRequest> for Request {
	    fn from(r: CreateonionRequest) -> Self {
	        Request::CreateOnion(r)
	    }
	}

	impl IntoRequest for CreateonionRequest {
	    type Response = super::responses::CreateonionResponse;
	}

	impl TypedRequest for CreateonionRequest {
	    type Response = super::responses::CreateonionResponse;

	    fn method(&self) -> &str {
	        "createonion"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DeldatastoreRequest {
	    pub key: Vec<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub generation: Option<u64>,
	}

	impl From<DeldatastoreRequest> for Request {
	    fn from(r: DeldatastoreRequest) -> Self {
	        Request::DelDatastore(r)
	    }
	}

	impl IntoRequest for DeldatastoreRequest {
	    type Response = super::responses::DeldatastoreResponse;
	}

	impl TypedRequest for DeldatastoreRequest {
	    type Response = super::responses::DeldatastoreResponse;

	    fn method(&self) -> &str {
	        "deldatastore"
	    }
	}
	/// ['Label of the invoice to be deleted. The caller should be particularly aware of the error case caused by the *status* changing just before this command is invoked!']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum DelinvoiceStatus {
	    #[serde(rename = "paid")]
	    PAID,
	    #[serde(rename = "expired")]
	    EXPIRED,
	    #[serde(rename = "unpaid")]
	    UNPAID,
	}

	impl TryFrom<i32> for DelinvoiceStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<DelinvoiceStatus, anyhow::Error> {
	        match c {
	    0 => Ok(DelinvoiceStatus::PAID),
	    1 => Ok(DelinvoiceStatus::EXPIRED),
	    2 => Ok(DelinvoiceStatus::UNPAID),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum DelinvoiceStatus", o)),
	        }
	    }
	}

	impl ToString for DelinvoiceStatus {
	    fn to_string(&self) -> String {
	        match self {
	            DelinvoiceStatus::PAID => "PAID",
	            DelinvoiceStatus::EXPIRED => "EXPIRED",
	            DelinvoiceStatus::UNPAID => "UNPAID",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DelinvoiceRequest {
	    pub label: String,
	    // Path `DelInvoice.status`
	    pub status: DelinvoiceStatus,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub desconly: Option<bool>,
	}

	impl From<DelinvoiceRequest> for Request {
	    fn from(r: DelinvoiceRequest) -> Self {
	        Request::DelInvoice(r)
	    }
	}

	impl IntoRequest for DelinvoiceRequest {
	    type Response = super::responses::DelinvoiceResponse;
	}

	impl TypedRequest for DelinvoiceRequest {
	    type Response = super::responses::DelinvoiceResponse;

	    fn method(&self) -> &str {
	        "delinvoice"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct InvoiceRequest {
	    pub amount_msat: AmountOrAny,
	    pub label: String,
	    pub description: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub expiry: Option<u64>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub fallbacks: Option<Vec<String>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub preimage: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub cltv: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub deschashonly: Option<bool>,
	}

	impl From<InvoiceRequest> for Request {
	    fn from(r: InvoiceRequest) -> Self {
	        Request::Invoice(r)
	    }
	}

	impl IntoRequest for InvoiceRequest {
	    type Response = super::responses::InvoiceResponse;
	}

	impl TypedRequest for InvoiceRequest {
	    type Response = super::responses::InvoiceResponse;

	    fn method(&self) -> &str {
	        "invoice"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListdatastoreRequest {
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub key: Option<Vec<String>>,
	}

	impl From<ListdatastoreRequest> for Request {
	    fn from(r: ListdatastoreRequest) -> Self {
	        Request::ListDatastore(r)
	    }
	}

	impl IntoRequest for ListdatastoreRequest {
	    type Response = super::responses::ListdatastoreResponse;
	}

	impl TypedRequest for ListdatastoreRequest {
	    type Response = super::responses::ListdatastoreResponse;

	    fn method(&self) -> &str {
	        "listdatastore"
	    }
	}
	/// ['If neither *in_channel* nor *out_channel* is specified, it controls ordering.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListinvoicesIndex {
	    #[serde(rename = "created")]
	    CREATED,
	    #[serde(rename = "updated")]
	    UPDATED,
	}

	impl TryFrom<i32> for ListinvoicesIndex {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListinvoicesIndex, anyhow::Error> {
	        match c {
	    0 => Ok(ListinvoicesIndex::CREATED),
	    1 => Ok(ListinvoicesIndex::UPDATED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListinvoicesIndex", o)),
	        }
	    }
	}

	impl ToString for ListinvoicesIndex {
	    fn to_string(&self) -> String {
	        match self {
	            ListinvoicesIndex::CREATED => "CREATED",
	            ListinvoicesIndex::UPDATED => "UPDATED",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListinvoicesRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invstring: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_hash: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_id: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub index: Option<ListinvoicesIndex>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub start: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub limit: Option<u32>,
	}

	impl From<ListinvoicesRequest> for Request {
	    fn from(r: ListinvoicesRequest) -> Self {
	        Request::ListInvoices(r)
	    }
	}

	impl IntoRequest for ListinvoicesRequest {
	    type Response = super::responses::ListinvoicesResponse;
	}

	impl TypedRequest for ListinvoicesRequest {
	    type Response = super::responses::ListinvoicesResponse;

	    fn method(&self) -> &str {
	        "listinvoices"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendonionFirst_hop {
	    pub id: PublicKey,
	    pub amount_msat: Amount,
	    pub delay: u16,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendonionRequest {
	    pub onion: String,
	    pub first_hop: SendonionFirst_hop,
	    pub payment_hash: Sha256,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub shared_secrets: Option<Vec<Secret>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u16>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub localinvreqid: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub groupid: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	}

	impl From<SendonionRequest> for Request {
	    fn from(r: SendonionRequest) -> Self {
	        Request::SendOnion(r)
	    }
	}

	impl IntoRequest for SendonionRequest {
	    type Response = super::responses::SendonionResponse;
	}

	impl TypedRequest for SendonionRequest {
	    type Response = super::responses::SendonionResponse;

	    fn method(&self) -> &str {
	        "sendonion"
	    }
	}
	/// ['Whether the invoice has been paid, pending, or failed.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListsendpaysStatus {
	    #[serde(rename = "pending")]
	    PENDING,
	    #[serde(rename = "complete")]
	    COMPLETE,
	    #[serde(rename = "failed")]
	    FAILED,
	}

	impl TryFrom<i32> for ListsendpaysStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListsendpaysStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListsendpaysStatus::PENDING),
	    1 => Ok(ListsendpaysStatus::COMPLETE),
	    2 => Ok(ListsendpaysStatus::FAILED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListsendpaysStatus", o)),
	        }
	    }
	}

	impl ToString for ListsendpaysStatus {
	    fn to_string(&self) -> String {
	        match self {
	            ListsendpaysStatus::PENDING => "PENDING",
	            ListsendpaysStatus::COMPLETE => "COMPLETE",
	            ListsendpaysStatus::FAILED => "FAILED",
	        }.to_string()
	    }
	}

	/// ['If neither bolt11 or payment_hash is specified, `index` controls ordering, by `created` (default) or `updated`.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListsendpaysIndex {
	    #[serde(rename = "created")]
	    CREATED,
	    #[serde(rename = "updated")]
	    UPDATED,
	}

	impl TryFrom<i32> for ListsendpaysIndex {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListsendpaysIndex, anyhow::Error> {
	        match c {
	    0 => Ok(ListsendpaysIndex::CREATED),
	    1 => Ok(ListsendpaysIndex::UPDATED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListsendpaysIndex", o)),
	        }
	    }
	}

	impl ToString for ListsendpaysIndex {
	    fn to_string(&self) -> String {
	        match self {
	            ListsendpaysIndex::CREATED => "CREATED",
	            ListsendpaysIndex::UPDATED => "UPDATED",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListsendpaysRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_hash: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub status: Option<ListsendpaysStatus>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub index: Option<ListsendpaysIndex>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub start: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub limit: Option<u32>,
	}

	impl From<ListsendpaysRequest> for Request {
	    fn from(r: ListsendpaysRequest) -> Self {
	        Request::ListSendPays(r)
	    }
	}

	impl IntoRequest for ListsendpaysRequest {
	    type Response = super::responses::ListsendpaysResponse;
	}

	impl TypedRequest for ListsendpaysRequest {
	    type Response = super::responses::ListsendpaysResponse;

	    fn method(&self) -> &str {
	        "listsendpays"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListtransactionsRequest {
	}

	impl From<ListtransactionsRequest> for Request {
	    fn from(r: ListtransactionsRequest) -> Self {
	        Request::ListTransactions(r)
	    }
	}

	impl IntoRequest for ListtransactionsRequest {
	    type Response = super::responses::ListtransactionsResponse;
	}

	impl TypedRequest for ListtransactionsRequest {
	    type Response = super::responses::ListtransactionsResponse;

	    fn method(&self) -> &str {
	        "listtransactions"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct PayRequest {
	    pub bolt11: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub riskfactor: Option<f64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub maxfeepercent: Option<f64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub retry_for: Option<u16>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub maxdelay: Option<u16>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub exemptfee: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub localinvreqid: Option<String>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub exclude: Option<Vec<String>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub maxfee: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub partial_msat: Option<Amount>,
	}

	impl From<PayRequest> for Request {
	    fn from(r: PayRequest) -> Self {
	        Request::Pay(r)
	    }
	}

	impl IntoRequest for PayRequest {
	    type Response = super::responses::PayResponse;
	}

	impl TypedRequest for PayRequest {
	    type Response = super::responses::PayResponse;

	    fn method(&self) -> &str {
	        "pay"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListnodesRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub id: Option<PublicKey>,
	}

	impl From<ListnodesRequest> for Request {
	    fn from(r: ListnodesRequest) -> Self {
	        Request::ListNodes(r)
	    }
	}

	impl IntoRequest for ListnodesRequest {
	    type Response = super::responses::ListnodesResponse;
	}

	impl TypedRequest for ListnodesRequest {
	    type Response = super::responses::ListnodesResponse;

	    fn method(&self) -> &str {
	        "listnodes"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitanyinvoiceRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub lastpay_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub timeout: Option<u64>,
	}

	impl From<WaitanyinvoiceRequest> for Request {
	    fn from(r: WaitanyinvoiceRequest) -> Self {
	        Request::WaitAnyInvoice(r)
	    }
	}

	impl IntoRequest for WaitanyinvoiceRequest {
	    type Response = super::responses::WaitanyinvoiceResponse;
	}

	impl TypedRequest for WaitanyinvoiceRequest {
	    type Response = super::responses::WaitanyinvoiceResponse;

	    fn method(&self) -> &str {
	        "waitanyinvoice"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitinvoiceRequest {
	    pub label: String,
	}

	impl From<WaitinvoiceRequest> for Request {
	    fn from(r: WaitinvoiceRequest) -> Self {
	        Request::WaitInvoice(r)
	    }
	}

	impl IntoRequest for WaitinvoiceRequest {
	    type Response = super::responses::WaitinvoiceResponse;
	}

	impl TypedRequest for WaitinvoiceRequest {
	    type Response = super::responses::WaitinvoiceResponse;

	    fn method(&self) -> &str {
	        "waitinvoice"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitsendpayRequest {
	    pub payment_hash: Sha256,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub timeout: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub groupid: Option<u64>,
	}

	impl From<WaitsendpayRequest> for Request {
	    fn from(r: WaitsendpayRequest) -> Self {
	        Request::WaitSendPay(r)
	    }
	}

	impl IntoRequest for WaitsendpayRequest {
	    type Response = super::responses::WaitsendpayResponse;
	}

	impl TypedRequest for WaitsendpayRequest {
	    type Response = super::responses::WaitsendpayResponse;

	    fn method(&self) -> &str {
	        "waitsendpay"
	    }
	}
	/// ['It specifies the type of address wanted; currently *bech32* (e.g. `tb1qu9j4lg5f9rgjyfhvfd905vw46eg39czmktxqgg` on bitcoin testnet or `bc1qwqdg6squsna38e46795at95yu9atm8azzmyvckulcc7kytlcckxswvvzej` on bitcoin mainnet), or *p2tr* taproot addresses. The special value *all* generates all known address types for the same underlying key.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum NewaddrAddresstype {
	    #[serde(rename = "bech32")]
	    BECH32,
	    #[serde(rename = "p2tr")]
	    P2TR,
	    #[serde(rename = "all")]
	    ALL,
	}

	impl TryFrom<i32> for NewaddrAddresstype {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<NewaddrAddresstype, anyhow::Error> {
	        match c {
	    0 => Ok(NewaddrAddresstype::BECH32),
	    1 => Ok(NewaddrAddresstype::P2TR),
	    2 => Ok(NewaddrAddresstype::ALL),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum NewaddrAddresstype", o)),
	        }
	    }
	}

	impl ToString for NewaddrAddresstype {
	    fn to_string(&self) -> String {
	        match self {
	            NewaddrAddresstype::BECH32 => "BECH32",
	            NewaddrAddresstype::P2TR => "P2TR",
	            NewaddrAddresstype::ALL => "ALL",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct NewaddrRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub addresstype: Option<NewaddrAddresstype>,
	}

	impl From<NewaddrRequest> for Request {
	    fn from(r: NewaddrRequest) -> Self {
	        Request::NewAddr(r)
	    }
	}

	impl IntoRequest for NewaddrRequest {
	    type Response = super::responses::NewaddrResponse;
	}

	impl TypedRequest for NewaddrRequest {
	    type Response = super::responses::NewaddrResponse;

	    fn method(&self) -> &str {
	        "newaddr"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WithdrawRequest {
	    pub destination: String,
	    pub satoshi: AmountOrAll,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feerate: Option<Feerate>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub minconf: Option<u16>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub utxos: Option<Vec<Outpoint>>,
	}

	impl From<WithdrawRequest> for Request {
	    fn from(r: WithdrawRequest) -> Self {
	        Request::Withdraw(r)
	    }
	}

	impl IntoRequest for WithdrawRequest {
	    type Response = super::responses::WithdrawResponse;
	}

	impl TypedRequest for WithdrawRequest {
	    type Response = super::responses::WithdrawResponse;

	    fn method(&self) -> &str {
	        "withdraw"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct KeysendRequest {
	    pub destination: PublicKey,
	    pub amount_msat: Amount,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub maxfeepercent: Option<f64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub retry_for: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub maxdelay: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub exemptfee: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub routehints: Option<RoutehintList>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub extratlvs: Option<TlvStream>,
	}

	impl From<KeysendRequest> for Request {
	    fn from(r: KeysendRequest) -> Self {
	        Request::KeySend(r)
	    }
	}

	impl IntoRequest for KeysendRequest {
	    type Response = super::responses::KeysendResponse;
	}

	impl TypedRequest for KeysendRequest {
	    type Response = super::responses::KeysendResponse;

	    fn method(&self) -> &str {
	        "keysend"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FundpsbtRequest {
	    pub satoshi: AmountOrAll,
	    pub feerate: Feerate,
	    pub startweight: u32,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub minconf: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub reserve: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub locktime: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub min_witness_weight: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub excess_as_change: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub nonwrapped: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub opening_anchor_channel: Option<bool>,
	}

	impl From<FundpsbtRequest> for Request {
	    fn from(r: FundpsbtRequest) -> Self {
	        Request::FundPsbt(r)
	    }
	}

	impl IntoRequest for FundpsbtRequest {
	    type Response = super::responses::FundpsbtResponse;
	}

	impl TypedRequest for FundpsbtRequest {
	    type Response = super::responses::FundpsbtResponse;

	    fn method(&self) -> &str {
	        "fundpsbt"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendpsbtRequest {
	    pub psbt: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub reserve: Option<u32>,
	}

	impl From<SendpsbtRequest> for Request {
	    fn from(r: SendpsbtRequest) -> Self {
	        Request::SendPsbt(r)
	    }
	}

	impl IntoRequest for SendpsbtRequest {
	    type Response = super::responses::SendpsbtResponse;
	}

	impl TypedRequest for SendpsbtRequest {
	    type Response = super::responses::SendpsbtResponse;

	    fn method(&self) -> &str {
	        "sendpsbt"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SignpsbtRequest {
	    pub psbt: String,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub signonly: Option<Vec<u32>>,
	}

	impl From<SignpsbtRequest> for Request {
	    fn from(r: SignpsbtRequest) -> Self {
	        Request::SignPsbt(r)
	    }
	}

	impl IntoRequest for SignpsbtRequest {
	    type Response = super::responses::SignpsbtResponse;
	}

	impl TypedRequest for SignpsbtRequest {
	    type Response = super::responses::SignpsbtResponse;

	    fn method(&self) -> &str {
	        "signpsbt"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct UtxopsbtRequest {
	    pub satoshi: AmountOrAll,
	    pub feerate: Feerate,
	    pub startweight: u32,
	    pub utxos: Vec<Outpoint>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub reserve: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub reservedok: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub locktime: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub min_witness_weight: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub excess_as_change: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub opening_anchor_channel: Option<bool>,
	}

	impl From<UtxopsbtRequest> for Request {
	    fn from(r: UtxopsbtRequest) -> Self {
	        Request::UtxoPsbt(r)
	    }
	}

	impl IntoRequest for UtxopsbtRequest {
	    type Response = super::responses::UtxopsbtResponse;
	}

	impl TypedRequest for UtxopsbtRequest {
	    type Response = super::responses::UtxopsbtResponse;

	    fn method(&self) -> &str {
	        "utxopsbt"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct TxdiscardRequest {
	    pub txid: String,
	}

	impl From<TxdiscardRequest> for Request {
	    fn from(r: TxdiscardRequest) -> Self {
	        Request::TxDiscard(r)
	    }
	}

	impl IntoRequest for TxdiscardRequest {
	    type Response = super::responses::TxdiscardResponse;
	}

	impl TypedRequest for TxdiscardRequest {
	    type Response = super::responses::TxdiscardResponse;

	    fn method(&self) -> &str {
	        "txdiscard"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct TxprepareRequest {
	    pub outputs: Vec<OutputDesc>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feerate: Option<Feerate>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub minconf: Option<u32>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub utxos: Option<Vec<Outpoint>>,
	}

	impl From<TxprepareRequest> for Request {
	    fn from(r: TxprepareRequest) -> Self {
	        Request::TxPrepare(r)
	    }
	}

	impl IntoRequest for TxprepareRequest {
	    type Response = super::responses::TxprepareResponse;
	}

	impl TypedRequest for TxprepareRequest {
	    type Response = super::responses::TxprepareResponse;

	    fn method(&self) -> &str {
	        "txprepare"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct TxsendRequest {
	    pub txid: String,
	}

	impl From<TxsendRequest> for Request {
	    fn from(r: TxsendRequest) -> Self {
	        Request::TxSend(r)
	    }
	}

	impl IntoRequest for TxsendRequest {
	    type Response = super::responses::TxsendResponse;
	}

	impl TypedRequest for TxsendRequest {
	    type Response = super::responses::TxsendResponse;

	    fn method(&self) -> &str {
	        "txsend"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeerchannelsRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub id: Option<PublicKey>,
	}

	impl From<ListpeerchannelsRequest> for Request {
	    fn from(r: ListpeerchannelsRequest) -> Self {
	        Request::ListPeerChannels(r)
	    }
	}

	impl IntoRequest for ListpeerchannelsRequest {
	    type Response = super::responses::ListpeerchannelsResponse;
	}

	impl TypedRequest for ListpeerchannelsRequest {
	    type Response = super::responses::ListpeerchannelsResponse;

	    fn method(&self) -> &str {
	        "listpeerchannels"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListclosedchannelsRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub id: Option<PublicKey>,
	}

	impl From<ListclosedchannelsRequest> for Request {
	    fn from(r: ListclosedchannelsRequest) -> Self {
	        Request::ListClosedChannels(r)
	    }
	}

	impl IntoRequest for ListclosedchannelsRequest {
	    type Response = super::responses::ListclosedchannelsResponse;
	}

	impl TypedRequest for ListclosedchannelsRequest {
	    type Response = super::responses::ListclosedchannelsResponse;

	    fn method(&self) -> &str {
	        "listclosedchannels"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodepayRequest {
	    pub bolt11: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	}

	impl From<DecodepayRequest> for Request {
	    fn from(r: DecodepayRequest) -> Self {
	        Request::DecodePay(r)
	    }
	}

	impl IntoRequest for DecodepayRequest {
	    type Response = super::responses::DecodepayResponse;
	}

	impl TypedRequest for DecodepayRequest {
	    type Response = super::responses::DecodepayResponse;

	    fn method(&self) -> &str {
	        "decodepay"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeRequest {
	    pub string: String,
	}

	impl From<DecodeRequest> for Request {
	    fn from(r: DecodeRequest) -> Self {
	        Request::Decode(r)
	    }
	}

	impl IntoRequest for DecodeRequest {
	    type Response = super::responses::DecodeResponse;
	}

	impl TypedRequest for DecodeRequest {
	    type Response = super::responses::DecodeResponse;

	    fn method(&self) -> &str {
	        "decode"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DisconnectRequest {
	    pub id: PublicKey,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub force: Option<bool>,
	}

	impl From<DisconnectRequest> for Request {
	    fn from(r: DisconnectRequest) -> Self {
	        Request::Disconnect(r)
	    }
	}

	impl IntoRequest for DisconnectRequest {
	    type Response = super::responses::DisconnectResponse;
	}

	impl TypedRequest for DisconnectRequest {
	    type Response = super::responses::DisconnectResponse;

	    fn method(&self) -> &str {
	        "disconnect"
	    }
	}
	/// ['Fee rate style to use. This can be:', '    *perkw* - provide feerate in units of satoshis per 1000 weight (e.g. the minimum fee is usually `253perkw`).', '    *perkb* - provide feerate in units of satoshis per 1000 virtual bytes (eg. the minimum fee is usually `1000perkb`).']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum FeeratesStyle {
	    #[serde(rename = "perkb")]
	    PERKB,
	    #[serde(rename = "perkw")]
	    PERKW,
	}

	impl TryFrom<i32> for FeeratesStyle {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<FeeratesStyle, anyhow::Error> {
	        match c {
	    0 => Ok(FeeratesStyle::PERKB),
	    1 => Ok(FeeratesStyle::PERKW),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum FeeratesStyle", o)),
	        }
	    }
	}

	impl ToString for FeeratesStyle {
	    fn to_string(&self) -> String {
	        match self {
	            FeeratesStyle::PERKB => "PERKB",
	            FeeratesStyle::PERKW => "PERKW",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FeeratesRequest {
	    // Path `Feerates.style`
	    pub style: FeeratesStyle,
	}

	impl From<FeeratesRequest> for Request {
	    fn from(r: FeeratesRequest) -> Self {
	        Request::Feerates(r)
	    }
	}

	impl IntoRequest for FeeratesRequest {
	    type Response = super::responses::FeeratesResponse;
	}

	impl TypedRequest for FeeratesRequest {
	    type Response = super::responses::FeeratesResponse;

	    fn method(&self) -> &str {
	        "feerates"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FetchinvoiceRequest {
	    pub offer: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub quantity: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub recurrence_counter: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub recurrence_start: Option<f64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub recurrence_label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub timeout: Option<f64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payer_note: Option<String>,
	}

	impl From<FetchinvoiceRequest> for Request {
	    fn from(r: FetchinvoiceRequest) -> Self {
	        Request::FetchInvoice(r)
	    }
	}

	impl IntoRequest for FetchinvoiceRequest {
	    type Response = super::responses::FetchinvoiceResponse;
	}

	impl TypedRequest for FetchinvoiceRequest {
	    type Response = super::responses::FetchinvoiceResponse;

	    fn method(&self) -> &str {
	        "fetchinvoice"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FundchannelRequest {
	    pub id: PublicKey,
	    pub amount: AmountOrAll,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feerate: Option<Feerate>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub announce: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub minconf: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub push_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub close_to: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub request_amt: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub compact_lease: Option<String>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub utxos: Option<Vec<Outpoint>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub mindepth: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub reserve: Option<Amount>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub channel_type: Option<Vec<u32>>,
	}

	impl From<FundchannelRequest> for Request {
	    fn from(r: FundchannelRequest) -> Self {
	        Request::FundChannel(r)
	    }
	}

	impl IntoRequest for FundchannelRequest {
	    type Response = super::responses::FundchannelResponse;
	}

	impl TypedRequest for FundchannelRequest {
	    type Response = super::responses::FundchannelResponse;

	    fn method(&self) -> &str {
	        "fundchannel"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetrouteRequest {
	    pub id: PublicKey,
	    pub amount_msat: Amount,
	    pub riskfactor: u64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub cltv: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fromid: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fuzzpercent: Option<u32>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub exclude: Option<Vec<String>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub maxhops: Option<u32>,
	}

	impl From<GetrouteRequest> for Request {
	    fn from(r: GetrouteRequest) -> Self {
	        Request::GetRoute(r)
	    }
	}

	impl IntoRequest for GetrouteRequest {
	    type Response = super::responses::GetrouteResponse;
	}

	impl TypedRequest for GetrouteRequest {
	    type Response = super::responses::GetrouteResponse;

	    fn method(&self) -> &str {
	        "getroute"
	    }
	}
	/// ['If specified, then only the forwards with the given status are returned.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListforwardsStatus {
	    #[serde(rename = "offered")]
	    OFFERED,
	    #[serde(rename = "settled")]
	    SETTLED,
	    #[serde(rename = "local_failed")]
	    LOCAL_FAILED,
	    #[serde(rename = "failed")]
	    FAILED,
	}

	impl TryFrom<i32> for ListforwardsStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListforwardsStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListforwardsStatus::OFFERED),
	    1 => Ok(ListforwardsStatus::SETTLED),
	    2 => Ok(ListforwardsStatus::LOCAL_FAILED),
	    3 => Ok(ListforwardsStatus::FAILED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListforwardsStatus", o)),
	        }
	    }
	}

	impl ToString for ListforwardsStatus {
	    fn to_string(&self) -> String {
	        match self {
	            ListforwardsStatus::OFFERED => "OFFERED",
	            ListforwardsStatus::SETTLED => "SETTLED",
	            ListforwardsStatus::LOCAL_FAILED => "LOCAL_FAILED",
	            ListforwardsStatus::FAILED => "FAILED",
	        }.to_string()
	    }
	}

	/// ['If neither *in_channel* nor *out_channel* is specified, it controls ordering.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListforwardsIndex {
	    #[serde(rename = "created")]
	    CREATED,
	    #[serde(rename = "updated")]
	    UPDATED,
	}

	impl TryFrom<i32> for ListforwardsIndex {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListforwardsIndex, anyhow::Error> {
	        match c {
	    0 => Ok(ListforwardsIndex::CREATED),
	    1 => Ok(ListforwardsIndex::UPDATED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListforwardsIndex", o)),
	        }
	    }
	}

	impl ToString for ListforwardsIndex {
	    fn to_string(&self) -> String {
	        match self {
	            ListforwardsIndex::CREATED => "CREATED",
	            ListforwardsIndex::UPDATED => "UPDATED",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListforwardsRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub status: Option<ListforwardsStatus>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub in_channel: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_channel: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub index: Option<ListforwardsIndex>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub start: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub limit: Option<u32>,
	}

	impl From<ListforwardsRequest> for Request {
	    fn from(r: ListforwardsRequest) -> Self {
	        Request::ListForwards(r)
	    }
	}

	impl IntoRequest for ListforwardsRequest {
	    type Response = super::responses::ListforwardsResponse;
	}

	impl TypedRequest for ListforwardsRequest {
	    type Response = super::responses::ListforwardsResponse;

	    fn method(&self) -> &str {
	        "listforwards"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListoffersRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_id: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub active_only: Option<bool>,
	}

	impl From<ListoffersRequest> for Request {
	    fn from(r: ListoffersRequest) -> Self {
	        Request::ListOffers(r)
	    }
	}

	impl IntoRequest for ListoffersRequest {
	    type Response = super::responses::ListoffersResponse;
	}

	impl TypedRequest for ListoffersRequest {
	    type Response = super::responses::ListoffersResponse;

	    fn method(&self) -> &str {
	        "listoffers"
	    }
	}
	/// ['To filter the payment by status.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListpaysStatus {
	    #[serde(rename = "pending")]
	    PENDING,
	    #[serde(rename = "complete")]
	    COMPLETE,
	    #[serde(rename = "failed")]
	    FAILED,
	}

	impl TryFrom<i32> for ListpaysStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListpaysStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListpaysStatus::PENDING),
	    1 => Ok(ListpaysStatus::COMPLETE),
	    2 => Ok(ListpaysStatus::FAILED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListpaysStatus", o)),
	        }
	    }
	}

	impl ToString for ListpaysStatus {
	    fn to_string(&self) -> String {
	        match self {
	            ListpaysStatus::PENDING => "PENDING",
	            ListpaysStatus::COMPLETE => "COMPLETE",
	            ListpaysStatus::FAILED => "FAILED",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpaysRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_hash: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub status: Option<ListpaysStatus>,
	}

	impl From<ListpaysRequest> for Request {
	    fn from(r: ListpaysRequest) -> Self {
	        Request::ListPays(r)
	    }
	}

	impl IntoRequest for ListpaysRequest {
	    type Response = super::responses::ListpaysResponse;
	}

	impl TypedRequest for ListpaysRequest {
	    type Response = super::responses::ListpaysResponse;

	    fn method(&self) -> &str {
	        "listpays"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListhtlcsRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub id: Option<String>,
	}

	impl From<ListhtlcsRequest> for Request {
	    fn from(r: ListhtlcsRequest) -> Self {
	        Request::ListHtlcs(r)
	    }
	}

	impl IntoRequest for ListhtlcsRequest {
	    type Response = super::responses::ListhtlcsResponse;
	}

	impl TypedRequest for ListhtlcsRequest {
	    type Response = super::responses::ListhtlcsResponse;

	    fn method(&self) -> &str {
	        "listhtlcs"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct OfferRequest {
	    pub amount: String,
	    pub description: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub issuer: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub quantity_max: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub absolute_expiry: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub recurrence: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub recurrence_base: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub recurrence_paywindow: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub recurrence_limit: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub single_use: Option<bool>,
	}

	impl From<OfferRequest> for Request {
	    fn from(r: OfferRequest) -> Self {
	        Request::Offer(r)
	    }
	}

	impl IntoRequest for OfferRequest {
	    type Response = super::responses::OfferResponse;
	}

	impl TypedRequest for OfferRequest {
	    type Response = super::responses::OfferResponse;

	    fn method(&self) -> &str {
	        "offer"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct PingRequest {
	    pub id: PublicKey,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub len: Option<u16>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub pongbytes: Option<u16>,
	}

	impl From<PingRequest> for Request {
	    fn from(r: PingRequest) -> Self {
	        Request::Ping(r)
	    }
	}

	impl IntoRequest for PingRequest {
	    type Response = super::responses::PingResponse;
	}

	impl TypedRequest for PingRequest {
	    type Response = super::responses::PingResponse;

	    fn method(&self) -> &str {
	        "ping"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendcustommsgRequest {
	    pub node_id: PublicKey,
	    pub msg: String,
	}

	impl From<SendcustommsgRequest> for Request {
	    fn from(r: SendcustommsgRequest) -> Self {
	        Request::SendCustomMsg(r)
	    }
	}

	impl IntoRequest for SendcustommsgRequest {
	    type Response = super::responses::SendcustommsgResponse;
	}

	impl TypedRequest for SendcustommsgRequest {
	    type Response = super::responses::SendcustommsgResponse;

	    fn method(&self) -> &str {
	        "sendcustommsg"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SetchannelRequest {
	    pub id: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feebase: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feeppm: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub htlcmin: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub htlcmax: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub enforcedelay: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub ignorefeelimits: Option<bool>,
	}

	impl From<SetchannelRequest> for Request {
	    fn from(r: SetchannelRequest) -> Self {
	        Request::SetChannel(r)
	    }
	}

	impl IntoRequest for SetchannelRequest {
	    type Response = super::responses::SetchannelResponse;
	}

	impl TypedRequest for SetchannelRequest {
	    type Response = super::responses::SetchannelResponse;

	    fn method(&self) -> &str {
	        "setchannel"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SigninvoiceRequest {
	    pub invstring: String,
	}

	impl From<SigninvoiceRequest> for Request {
	    fn from(r: SigninvoiceRequest) -> Self {
	        Request::SignInvoice(r)
	    }
	}

	impl IntoRequest for SigninvoiceRequest {
	    type Response = super::responses::SigninvoiceResponse;
	}

	impl TypedRequest for SigninvoiceRequest {
	    type Response = super::responses::SigninvoiceResponse;

	    fn method(&self) -> &str {
	        "signinvoice"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SignmessageRequest {
	    pub message: String,
	}

	impl From<SignmessageRequest> for Request {
	    fn from(r: SignmessageRequest) -> Self {
	        Request::SignMessage(r)
	    }
	}

	impl IntoRequest for SignmessageRequest {
	    type Response = super::responses::SignmessageResponse;
	}

	impl TypedRequest for SignmessageRequest {
	    type Response = super::responses::SignmessageResponse;

	    fn method(&self) -> &str {
	        "signmessage"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitblockheightRequest {
	    pub blockheight: u32,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub timeout: Option<u32>,
	}

	impl From<WaitblockheightRequest> for Request {
	    fn from(r: WaitblockheightRequest) -> Self {
	        Request::WaitBlockHeight(r)
	    }
	}

	impl IntoRequest for WaitblockheightRequest {
	    type Response = super::responses::WaitblockheightResponse;
	}

	impl TypedRequest for WaitblockheightRequest {
	    type Response = super::responses::WaitblockheightResponse;

	    fn method(&self) -> &str {
	        "waitblockheight"
	    }
	}
	/// ['The subsystem to get the next index value from.', '  `invoices`: corresponding to `listinvoices` (added in *v23.08*).', '  `sendpays`: corresponding to `listsendpays` (added in *v23.11*).', '  `forwards`: corresponding to `listforwards` (added in *v23.11*).']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum WaitSubsystem {
	    #[serde(rename = "invoices")]
	    INVOICES,
	    #[serde(rename = "forwards")]
	    FORWARDS,
	    #[serde(rename = "sendpays")]
	    SENDPAYS,
	}

	impl TryFrom<i32> for WaitSubsystem {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<WaitSubsystem, anyhow::Error> {
	        match c {
	    0 => Ok(WaitSubsystem::INVOICES),
	    1 => Ok(WaitSubsystem::FORWARDS),
	    2 => Ok(WaitSubsystem::SENDPAYS),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum WaitSubsystem", o)),
	        }
	    }
	}

	impl ToString for WaitSubsystem {
	    fn to_string(&self) -> String {
	        match self {
	            WaitSubsystem::INVOICES => "INVOICES",
	            WaitSubsystem::FORWARDS => "FORWARDS",
	            WaitSubsystem::SENDPAYS => "SENDPAYS",
	        }.to_string()
	    }
	}

	/// ['The name of the index to get the next value for.', '  `created` is incremented by one for every new object.', '  `updated` is incremented by one every time an object is changed.', '  `deleted` is incremented by one every time an object is deleted.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum WaitIndexname {
	    #[serde(rename = "created")]
	    CREATED,
	    #[serde(rename = "updated")]
	    UPDATED,
	    #[serde(rename = "deleted")]
	    DELETED,
	}

	impl TryFrom<i32> for WaitIndexname {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<WaitIndexname, anyhow::Error> {
	        match c {
	    0 => Ok(WaitIndexname::CREATED),
	    1 => Ok(WaitIndexname::UPDATED),
	    2 => Ok(WaitIndexname::DELETED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum WaitIndexname", o)),
	        }
	    }
	}

	impl ToString for WaitIndexname {
	    fn to_string(&self) -> String {
	        match self {
	            WaitIndexname::CREATED => "CREATED",
	            WaitIndexname::UPDATED => "UPDATED",
	            WaitIndexname::DELETED => "DELETED",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitRequest {
	    // Path `Wait.subsystem`
	    pub subsystem: WaitSubsystem,
	    // Path `Wait.indexname`
	    pub indexname: WaitIndexname,
	    pub nextvalue: u64,
	}

	impl From<WaitRequest> for Request {
	    fn from(r: WaitRequest) -> Self {
	        Request::Wait(r)
	    }
	}

	impl IntoRequest for WaitRequest {
	    type Response = super::responses::WaitResponse;
	}

	impl TypedRequest for WaitRequest {
	    type Response = super::responses::WaitResponse;

	    fn method(&self) -> &str {
	        "wait"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct StopRequest {
	}

	impl From<StopRequest> for Request {
	    fn from(r: StopRequest) -> Self {
	        Request::Stop(r)
	    }
	}

	impl IntoRequest for StopRequest {
	    type Response = super::responses::StopResponse;
	}

	impl TypedRequest for StopRequest {
	    type Response = super::responses::StopResponse;

	    fn method(&self) -> &str {
	        "stop"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct PreapprovekeysendRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_hash: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	}

	impl From<PreapprovekeysendRequest> for Request {
	    fn from(r: PreapprovekeysendRequest) -> Self {
	        Request::PreApproveKeysend(r)
	    }
	}

	impl IntoRequest for PreapprovekeysendRequest {
	    type Response = super::responses::PreapprovekeysendResponse;
	}

	impl TypedRequest for PreapprovekeysendRequest {
	    type Response = super::responses::PreapprovekeysendResponse;

	    fn method(&self) -> &str {
	        "preapprovekeysend"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct PreapproveinvoiceRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	}

	impl From<PreapproveinvoiceRequest> for Request {
	    fn from(r: PreapproveinvoiceRequest) -> Self {
	        Request::PreApproveInvoice(r)
	    }
	}

	impl IntoRequest for PreapproveinvoiceRequest {
	    type Response = super::responses::PreapproveinvoiceResponse;
	}

	impl TypedRequest for PreapproveinvoiceRequest {
	    type Response = super::responses::PreapproveinvoiceResponse;

	    fn method(&self) -> &str {
	        "preapproveinvoice"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct StaticbackupRequest {
	}

	impl From<StaticbackupRequest> for Request {
	    fn from(r: StaticbackupRequest) -> Self {
	        Request::StaticBackup(r)
	    }
	}

	impl IntoRequest for StaticbackupRequest {
	    type Response = super::responses::StaticbackupResponse;
	}

	impl TypedRequest for StaticbackupRequest {
	    type Response = super::responses::StaticbackupResponse;

	    fn method(&self) -> &str {
	        "staticbackup"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct BkprlistincomeRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub consolidate_fees: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub start_time: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub end_time: Option<u32>,
	}

	impl From<BkprlistincomeRequest> for Request {
	    fn from(r: BkprlistincomeRequest) -> Self {
	        Request::BkprListIncome(r)
	    }
	}

	impl IntoRequest for BkprlistincomeRequest {
	    type Response = super::responses::BkprlistincomeResponse;
	}

	impl TypedRequest for BkprlistincomeRequest {
	    type Response = super::responses::BkprlistincomeResponse;

	    fn method(&self) -> &str {
	        "bkprlistincome"
	    }
	}
}


pub mod responses {
    #[allow(unused_imports)]
    use crate::primitives::*;
    #[allow(unused_imports)]
    use serde::{{Deserialize, Serialize}};
    use super::{TryFromResponseError, Response};

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetinfoOur_features {
	    pub init: String,
	    pub node: String,
	    pub channel: String,
	    pub invoice: String,
	}

	/// ['Type of connection (until 23.08, `websocket` was also allowed).']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum GetinfoAddressType {
	    #[serde(rename = "dns")]
	    DNS,
	    #[serde(rename = "ipv4")]
	    IPV4,
	    #[serde(rename = "ipv6")]
	    IPV6,
	    #[serde(rename = "torv2")]
	    TORV2,
	    #[serde(rename = "torv3")]
	    TORV3,
	}

	impl TryFrom<i32> for GetinfoAddressType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<GetinfoAddressType, anyhow::Error> {
	        match c {
	    0 => Ok(GetinfoAddressType::DNS),
	    1 => Ok(GetinfoAddressType::IPV4),
	    2 => Ok(GetinfoAddressType::IPV6),
	    3 => Ok(GetinfoAddressType::TORV2),
	    4 => Ok(GetinfoAddressType::TORV3),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum GetinfoAddressType", o)),
	        }
	    }
	}

	impl ToString for GetinfoAddressType {
	    fn to_string(&self) -> String {
	        match self {
	            GetinfoAddressType::DNS => "DNS",
	            GetinfoAddressType::IPV4 => "IPV4",
	            GetinfoAddressType::IPV6 => "IPV6",
	            GetinfoAddressType::TORV2 => "TORV2",
	            GetinfoAddressType::TORV3 => "TORV3",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetinfoAddress {
	    // Path `Getinfo.address[].type`
	    #[serde(rename = "type")]
	    pub item_type: GetinfoAddressType,
	    pub port: u16,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub address: Option<String>,
	}

	/// ['Type of connection.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum GetinfoBindingType {
	    #[serde(rename = "local socket")]
	    LOCAL_SOCKET,
	    #[serde(rename = "websocket")]
	    WEBSOCKET,
	    #[serde(rename = "ipv4")]
	    IPV4,
	    #[serde(rename = "ipv6")]
	    IPV6,
	    #[serde(rename = "torv2")]
	    TORV2,
	    #[serde(rename = "torv3")]
	    TORV3,
	}

	impl TryFrom<i32> for GetinfoBindingType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<GetinfoBindingType, anyhow::Error> {
	        match c {
	    0 => Ok(GetinfoBindingType::LOCAL_SOCKET),
	    1 => Ok(GetinfoBindingType::WEBSOCKET),
	    2 => Ok(GetinfoBindingType::IPV4),
	    3 => Ok(GetinfoBindingType::IPV6),
	    4 => Ok(GetinfoBindingType::TORV2),
	    5 => Ok(GetinfoBindingType::TORV3),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum GetinfoBindingType", o)),
	        }
	    }
	}

	impl ToString for GetinfoBindingType {
	    fn to_string(&self) -> String {
	        match self {
	            GetinfoBindingType::LOCAL_SOCKET => "LOCAL_SOCKET",
	            GetinfoBindingType::WEBSOCKET => "WEBSOCKET",
	            GetinfoBindingType::IPV4 => "IPV4",
	            GetinfoBindingType::IPV6 => "IPV6",
	            GetinfoBindingType::TORV2 => "TORV2",
	            GetinfoBindingType::TORV3 => "TORV3",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetinfoBinding {
	    // Path `Getinfo.binding[].type`
	    #[serde(rename = "type")]
	    pub item_type: GetinfoBindingType,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub address: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub port: Option<u16>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub socket: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetinfoResponse {
	    pub id: PublicKey,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub alias: Option<String>,
	    pub color: String,
	    pub num_peers: u32,
	    pub num_pending_channels: u32,
	    pub num_active_channels: u32,
	    pub num_inactive_channels: u32,
	    pub version: String,
	    #[serde(rename = "lightning-dir")]
	    pub lightning_dir: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub our_features: Option<GetinfoOur_features>,
	    pub blockheight: u32,
	    pub network: String,
	    pub fees_collected_msat: Amount,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub address: Option<Vec<GetinfoAddress>>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub binding: Option<Vec<GetinfoBinding>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_bitcoind_sync: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_lightningd_sync: Option<String>,
	}

	impl TryFrom<Response> for GetinfoResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Getinfo(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListpeersPeersLogType {
	    #[serde(rename = "SKIPPED")]
	    SKIPPED,
	    #[serde(rename = "BROKEN")]
	    BROKEN,
	    #[serde(rename = "UNUSUAL")]
	    UNUSUAL,
	    #[serde(rename = "INFO")]
	    INFO,
	    #[serde(rename = "DEBUG")]
	    DEBUG,
	    #[serde(rename = "IO_IN")]
	    IO_IN,
	    #[serde(rename = "IO_OUT")]
	    IO_OUT,
	}

	impl TryFrom<i32> for ListpeersPeersLogType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListpeersPeersLogType, anyhow::Error> {
	        match c {
	    0 => Ok(ListpeersPeersLogType::SKIPPED),
	    1 => Ok(ListpeersPeersLogType::BROKEN),
	    2 => Ok(ListpeersPeersLogType::UNUSUAL),
	    3 => Ok(ListpeersPeersLogType::INFO),
	    4 => Ok(ListpeersPeersLogType::DEBUG),
	    5 => Ok(ListpeersPeersLogType::IO_IN),
	    6 => Ok(ListpeersPeersLogType::IO_OUT),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListpeersPeersLogType", o)),
	        }
	    }
	}

	impl ToString for ListpeersPeersLogType {
	    fn to_string(&self) -> String {
	        match self {
	            ListpeersPeersLogType::SKIPPED => "SKIPPED",
	            ListpeersPeersLogType::BROKEN => "BROKEN",
	            ListpeersPeersLogType::UNUSUAL => "UNUSUAL",
	            ListpeersPeersLogType::INFO => "INFO",
	            ListpeersPeersLogType::DEBUG => "DEBUG",
	            ListpeersPeersLogType::IO_IN => "IO_IN",
	            ListpeersPeersLogType::IO_OUT => "IO_OUT",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeersPeersLog {
	    // Path `ListPeers.peers[].log[].type`
	    #[serde(rename = "type")]
	    pub item_type: ListpeersPeersLogType,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub num_skipped: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub time: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub source: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub log: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub node_id: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub data: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeersPeers {
	    pub id: PublicKey,
	    pub connected: bool,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub num_channels: Option<u32>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub log: Option<Vec<ListpeersPeersLog>>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub netaddr: Option<Vec<String>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub remote_addr: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub features: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeersResponse {
	    pub peers: Vec<ListpeersPeers>,
	}

	impl TryFrom<Response> for ListpeersResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListPeers(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListfundsOutputsStatus {
	    #[serde(rename = "unconfirmed")]
	    UNCONFIRMED,
	    #[serde(rename = "confirmed")]
	    CONFIRMED,
	    #[serde(rename = "spent")]
	    SPENT,
	    #[serde(rename = "immature")]
	    IMMATURE,
	}

	impl TryFrom<i32> for ListfundsOutputsStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListfundsOutputsStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListfundsOutputsStatus::UNCONFIRMED),
	    1 => Ok(ListfundsOutputsStatus::CONFIRMED),
	    2 => Ok(ListfundsOutputsStatus::SPENT),
	    3 => Ok(ListfundsOutputsStatus::IMMATURE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListfundsOutputsStatus", o)),
	        }
	    }
	}

	impl ToString for ListfundsOutputsStatus {
	    fn to_string(&self) -> String {
	        match self {
	            ListfundsOutputsStatus::UNCONFIRMED => "UNCONFIRMED",
	            ListfundsOutputsStatus::CONFIRMED => "CONFIRMED",
	            ListfundsOutputsStatus::SPENT => "SPENT",
	            ListfundsOutputsStatus::IMMATURE => "IMMATURE",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListfundsOutputs {
	    pub txid: String,
	    pub output: u32,
	    pub amount_msat: Amount,
	    pub scriptpubkey: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub address: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub redeemscript: Option<String>,
	    // Path `ListFunds.outputs[].status`
	    pub status: ListfundsOutputsStatus,
	    pub reserved: bool,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub blockheight: Option<u32>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListfundsChannels {
	    pub peer_id: PublicKey,
	    pub our_amount_msat: Amount,
	    pub amount_msat: Amount,
	    pub funding_txid: String,
	    pub funding_output: u32,
	    pub connected: bool,
	    // Path `ListFunds.channels[].state`
	    pub state: ChannelState,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub channel_id: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub short_channel_id: Option<ShortChannelId>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListfundsResponse {
	    pub outputs: Vec<ListfundsOutputs>,
	    pub channels: Vec<ListfundsChannels>,
	}

	impl TryFrom<Response> for ListfundsResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListFunds(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Status of the payment (could be complete if already sent previously).']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum SendpayStatus {
	    #[serde(rename = "pending")]
	    PENDING,
	    #[serde(rename = "complete")]
	    COMPLETE,
	}

	impl TryFrom<i32> for SendpayStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<SendpayStatus, anyhow::Error> {
	        match c {
	    0 => Ok(SendpayStatus::PENDING),
	    1 => Ok(SendpayStatus::COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum SendpayStatus", o)),
	        }
	    }
	}

	impl ToString for SendpayStatus {
	    fn to_string(&self) -> String {
	        match self {
	            SendpayStatus::PENDING => "PENDING",
	            SendpayStatus::COMPLETE => "COMPLETE",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendpayResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub updated_index: Option<u64>,
	    pub id: u64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub groupid: Option<u64>,
	    pub payment_hash: Sha256,
	    // Path `SendPay.status`
	    pub status: SendpayStatus,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    pub created_at: u64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub completed_at: Option<u64>,
	    pub amount_sent_msat: Amount,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub message: Option<String>,
	}

	impl TryFrom<Response> for SendpayResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SendPay(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListchannelsChannels {
	    pub source: PublicKey,
	    pub destination: PublicKey,
	    pub short_channel_id: ShortChannelId,
	    pub direction: u32,
	    pub public: bool,
	    pub amount_msat: Amount,
	    pub message_flags: u8,
	    pub channel_flags: u8,
	    pub active: bool,
	    pub last_update: u32,
	    pub base_fee_millisatoshi: u32,
	    pub fee_per_millionth: u32,
	    pub delay: u32,
	    pub htlc_minimum_msat: Amount,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub htlc_maximum_msat: Option<Amount>,
	    pub features: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListchannelsResponse {
	    pub channels: Vec<ListchannelsChannels>,
	}

	impl TryFrom<Response> for ListchannelsResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListChannels(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AddgossipResponse {
	}

	impl TryFrom<Response> for AddgossipResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::AddGossip(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AutocleaninvoiceResponse {
	    pub enabled: bool,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub expired_by: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub cycle_seconds: Option<u64>,
	}

	impl TryFrom<Response> for AutocleaninvoiceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::AutoCleanInvoice(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CheckmessageResponse {
	    pub verified: bool,
	    pub pubkey: PublicKey,
	}

	impl TryFrom<Response> for CheckmessageResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::CheckMessage(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Whether we successfully negotiated a mutual close, closed without them, or discarded not-yet-opened channel.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum CloseType {
	    #[serde(rename = "mutual")]
	    MUTUAL,
	    #[serde(rename = "unilateral")]
	    UNILATERAL,
	    #[serde(rename = "unopened")]
	    UNOPENED,
	}

	impl TryFrom<i32> for CloseType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<CloseType, anyhow::Error> {
	        match c {
	    0 => Ok(CloseType::MUTUAL),
	    1 => Ok(CloseType::UNILATERAL),
	    2 => Ok(CloseType::UNOPENED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum CloseType", o)),
	        }
	    }
	}

	impl ToString for CloseType {
	    fn to_string(&self) -> String {
	        match self {
	            CloseType::MUTUAL => "MUTUAL",
	            CloseType::UNILATERAL => "UNILATERAL",
	            CloseType::UNOPENED => "UNOPENED",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CloseResponse {
	    // Path `Close.type`
	    #[serde(rename = "type")]
	    pub item_type: CloseType,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub tx: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub txid: Option<String>,
	}

	impl TryFrom<Response> for CloseResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Close(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Whether they initiated connection or we did.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ConnectDirection {
	    #[serde(rename = "in")]
	    IN,
	    #[serde(rename = "out")]
	    OUT,
	}

	impl TryFrom<i32> for ConnectDirection {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ConnectDirection, anyhow::Error> {
	        match c {
	    0 => Ok(ConnectDirection::IN),
	    1 => Ok(ConnectDirection::OUT),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ConnectDirection", o)),
	        }
	    }
	}

	impl ToString for ConnectDirection {
	    fn to_string(&self) -> String {
	        match self {
	            ConnectDirection::IN => "IN",
	            ConnectDirection::OUT => "OUT",
	        }.to_string()
	    }
	}

	/// ['Type of connection (*torv2*/*torv3* only if **direction** is *out*).']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ConnectAddressType {
	    #[serde(rename = "local socket")]
	    LOCAL_SOCKET,
	    #[serde(rename = "ipv4")]
	    IPV4,
	    #[serde(rename = "ipv6")]
	    IPV6,
	    #[serde(rename = "torv2")]
	    TORV2,
	    #[serde(rename = "torv3")]
	    TORV3,
	}

	impl TryFrom<i32> for ConnectAddressType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ConnectAddressType, anyhow::Error> {
	        match c {
	    0 => Ok(ConnectAddressType::LOCAL_SOCKET),
	    1 => Ok(ConnectAddressType::IPV4),
	    2 => Ok(ConnectAddressType::IPV6),
	    3 => Ok(ConnectAddressType::TORV2),
	    4 => Ok(ConnectAddressType::TORV3),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ConnectAddressType", o)),
	        }
	    }
	}

	impl ToString for ConnectAddressType {
	    fn to_string(&self) -> String {
	        match self {
	            ConnectAddressType::LOCAL_SOCKET => "LOCAL_SOCKET",
	            ConnectAddressType::IPV4 => "IPV4",
	            ConnectAddressType::IPV6 => "IPV6",
	            ConnectAddressType::TORV2 => "TORV2",
	            ConnectAddressType::TORV3 => "TORV3",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ConnectAddress {
	    // Path `Connect.address.type`
	    #[serde(rename = "type")]
	    pub item_type: ConnectAddressType,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub socket: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub address: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub port: Option<u16>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ConnectResponse {
	    pub id: PublicKey,
	    pub features: String,
	    // Path `Connect.direction`
	    pub direction: ConnectDirection,
	    pub address: ConnectAddress,
	}

	impl TryFrom<Response> for ConnectResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Connect(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Whether it has been paid, or can no longer be paid.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum CreateinvoiceStatus {
	    #[serde(rename = "paid")]
	    PAID,
	    #[serde(rename = "expired")]
	    EXPIRED,
	    #[serde(rename = "unpaid")]
	    UNPAID,
	}

	impl TryFrom<i32> for CreateinvoiceStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<CreateinvoiceStatus, anyhow::Error> {
	        match c {
	    0 => Ok(CreateinvoiceStatus::PAID),
	    1 => Ok(CreateinvoiceStatus::EXPIRED),
	    2 => Ok(CreateinvoiceStatus::UNPAID),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum CreateinvoiceStatus", o)),
	        }
	    }
	}

	impl ToString for CreateinvoiceStatus {
	    fn to_string(&self) -> String {
	        match self {
	            CreateinvoiceStatus::PAID => "PAID",
	            CreateinvoiceStatus::EXPIRED => "EXPIRED",
	            CreateinvoiceStatus::UNPAID => "UNPAID",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CreateinvoicePaid_outpoint {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub txid: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub outnum: Option<u32>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CreateinvoiceResponse {
	    pub label: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    pub payment_hash: Sha256,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    // Path `CreateInvoice.status`
	    pub status: CreateinvoiceStatus,
	    pub description: String,
	    pub expires_at: u64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub pay_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_received_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub paid_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub paid_outpoint: Option<CreateinvoicePaid_outpoint>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub local_offer_id: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_payer_note: Option<String>,
	}

	impl TryFrom<Response> for CreateinvoiceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::CreateInvoice(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DatastoreResponse {
	    pub key: Vec<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub generation: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub hex: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub string: Option<String>,
	}

	impl TryFrom<Response> for DatastoreResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Datastore(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DatastoreusageDatastoreusage {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub key: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub total_bytes: Option<u64>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DatastoreusageResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub datastoreusage: Option<DatastoreusageDatastoreusage>,
	}

	impl TryFrom<Response> for DatastoreusageResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::DatastoreUsage(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CreateonionResponse {
	    pub onion: String,
	    pub shared_secrets: Vec<Secret>,
	}

	impl TryFrom<Response> for CreateonionResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::CreateOnion(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DeldatastoreResponse {
	    pub key: Vec<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub generation: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub hex: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub string: Option<String>,
	}

	impl TryFrom<Response> for DeldatastoreResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::DelDatastore(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['State of invoice.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum DelinvoiceStatus {
	    #[serde(rename = "paid")]
	    PAID,
	    #[serde(rename = "expired")]
	    EXPIRED,
	    #[serde(rename = "unpaid")]
	    UNPAID,
	}

	impl TryFrom<i32> for DelinvoiceStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<DelinvoiceStatus, anyhow::Error> {
	        match c {
	    0 => Ok(DelinvoiceStatus::PAID),
	    1 => Ok(DelinvoiceStatus::EXPIRED),
	    2 => Ok(DelinvoiceStatus::UNPAID),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum DelinvoiceStatus", o)),
	        }
	    }
	}

	impl ToString for DelinvoiceStatus {
	    fn to_string(&self) -> String {
	        match self {
	            DelinvoiceStatus::PAID => "PAID",
	            DelinvoiceStatus::EXPIRED => "EXPIRED",
	            DelinvoiceStatus::UNPAID => "UNPAID",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DelinvoiceResponse {
	    pub label: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    pub payment_hash: Sha256,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub updated_index: Option<u64>,
	    // Path `DelInvoice.status`
	    pub status: DelinvoiceStatus,
	    pub expires_at: u64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub local_offer_id: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_payer_note: Option<String>,
	}

	impl TryFrom<Response> for DelinvoiceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::DelInvoice(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct InvoiceResponse {
	    pub bolt11: String,
	    pub payment_hash: Sha256,
	    pub payment_secret: Secret,
	    pub expires_at: u64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_capacity: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_offline: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_deadends: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_private_unused: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_mpp: Option<String>,
	}

	impl TryFrom<Response> for InvoiceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Invoice(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListdatastoreDatastore {
	    pub key: Vec<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub generation: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub hex: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub string: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListdatastoreResponse {
	    pub datastore: Vec<ListdatastoreDatastore>,
	}

	impl TryFrom<Response> for ListdatastoreResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListDatastore(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ["Whether it's paid, unpaid or unpayable."]
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListinvoicesInvoicesStatus {
	    #[serde(rename = "unpaid")]
	    UNPAID,
	    #[serde(rename = "paid")]
	    PAID,
	    #[serde(rename = "expired")]
	    EXPIRED,
	}

	impl TryFrom<i32> for ListinvoicesInvoicesStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListinvoicesInvoicesStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListinvoicesInvoicesStatus::UNPAID),
	    1 => Ok(ListinvoicesInvoicesStatus::PAID),
	    2 => Ok(ListinvoicesInvoicesStatus::EXPIRED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListinvoicesInvoicesStatus", o)),
	        }
	    }
	}

	impl ToString for ListinvoicesInvoicesStatus {
	    fn to_string(&self) -> String {
	        match self {
	            ListinvoicesInvoicesStatus::UNPAID => "UNPAID",
	            ListinvoicesInvoicesStatus::PAID => "PAID",
	            ListinvoicesInvoicesStatus::EXPIRED => "EXPIRED",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListinvoicesInvoicesPaid_outpoint {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub txid: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub outnum: Option<u32>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListinvoicesInvoices {
	    pub label: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    pub payment_hash: Sha256,
	    // Path `ListInvoices.invoices[].status`
	    pub status: ListinvoicesInvoicesStatus,
	    pub expires_at: u64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub local_offer_id: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_payer_note: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub updated_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub pay_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_received_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub paid_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub paid_outpoint: Option<ListinvoicesInvoicesPaid_outpoint>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListinvoicesResponse {
	    pub invoices: Vec<ListinvoicesInvoices>,
	}

	impl TryFrom<Response> for ListinvoicesResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListInvoices(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Status of the payment (could be complete if already sent previously).']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum SendonionStatus {
	    #[serde(rename = "pending")]
	    PENDING,
	    #[serde(rename = "complete")]
	    COMPLETE,
	}

	impl TryFrom<i32> for SendonionStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<SendonionStatus, anyhow::Error> {
	        match c {
	    0 => Ok(SendonionStatus::PENDING),
	    1 => Ok(SendonionStatus::COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum SendonionStatus", o)),
	        }
	    }
	}

	impl ToString for SendonionStatus {
	    fn to_string(&self) -> String {
	        match self {
	            SendonionStatus::PENDING => "PENDING",
	            SendonionStatus::COMPLETE => "COMPLETE",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendonionResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_index: Option<u64>,
	    pub id: u64,
	    pub payment_hash: Sha256,
	    // Path `SendOnion.status`
	    pub status: SendonionStatus,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    pub created_at: u64,
	    pub amount_sent_msat: Amount,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub updated_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub message: Option<String>,
	}

	impl TryFrom<Response> for SendonionResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SendOnion(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Status of the payment.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListsendpaysPaymentsStatus {
	    #[serde(rename = "pending")]
	    PENDING,
	    #[serde(rename = "failed")]
	    FAILED,
	    #[serde(rename = "complete")]
	    COMPLETE,
	}

	impl TryFrom<i32> for ListsendpaysPaymentsStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListsendpaysPaymentsStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListsendpaysPaymentsStatus::PENDING),
	    1 => Ok(ListsendpaysPaymentsStatus::FAILED),
	    2 => Ok(ListsendpaysPaymentsStatus::COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListsendpaysPaymentsStatus", o)),
	        }
	    }
	}

	impl ToString for ListsendpaysPaymentsStatus {
	    fn to_string(&self) -> String {
	        match self {
	            ListsendpaysPaymentsStatus::PENDING => "PENDING",
	            ListsendpaysPaymentsStatus::FAILED => "FAILED",
	            ListsendpaysPaymentsStatus::COMPLETE => "COMPLETE",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListsendpaysPayments {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_index: Option<u64>,
	    pub id: u64,
	    pub groupid: u64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u64>,
	    pub payment_hash: Sha256,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub updated_index: Option<u64>,
	    // Path `ListSendPays.payments[].status`
	    pub status: ListsendpaysPaymentsStatus,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    pub created_at: u64,
	    pub amount_sent_msat: Amount,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub completed_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub erroronion: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListsendpaysResponse {
	    pub payments: Vec<ListsendpaysPayments>,
	}

	impl TryFrom<Response> for ListsendpaysResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListSendPays(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListtransactionsTransactionsInputs {
	    pub txid: String,
	    pub index: u32,
	    pub sequence: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListtransactionsTransactionsOutputs {
	    pub index: u32,
	    pub amount_msat: Amount,
	    #[serde(rename = "scriptPubKey")]
	    pub script_pub_key: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListtransactionsTransactions {
	    pub hash: String,
	    pub rawtx: String,
	    pub blockheight: u32,
	    pub txindex: u32,
	    pub locktime: u32,
	    pub version: u32,
	    pub inputs: Vec<ListtransactionsTransactionsInputs>,
	    pub outputs: Vec<ListtransactionsTransactionsOutputs>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListtransactionsResponse {
	    pub transactions: Vec<ListtransactionsTransactions>,
	}

	impl TryFrom<Response> for ListtransactionsResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListTransactions(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Status of payment.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum PayStatus {
	    #[serde(rename = "complete")]
	    COMPLETE,
	    #[serde(rename = "pending")]
	    PENDING,
	    #[serde(rename = "failed")]
	    FAILED,
	}

	impl TryFrom<i32> for PayStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<PayStatus, anyhow::Error> {
	        match c {
	    0 => Ok(PayStatus::COMPLETE),
	    1 => Ok(PayStatus::PENDING),
	    2 => Ok(PayStatus::FAILED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum PayStatus", o)),
	        }
	    }
	}

	impl ToString for PayStatus {
	    fn to_string(&self) -> String {
	        match self {
	            PayStatus::COMPLETE => "COMPLETE",
	            PayStatus::PENDING => "PENDING",
	            PayStatus::FAILED => "FAILED",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct PayResponse {
	    pub payment_preimage: Secret,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    pub payment_hash: Sha256,
	    pub created_at: f64,
	    pub parts: u32,
	    pub amount_msat: Amount,
	    pub amount_sent_msat: Amount,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_partial_completion: Option<String>,
	    // Path `Pay.status`
	    pub status: PayStatus,
	}

	impl TryFrom<Response> for PayResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Pay(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Type of connection (until 23.08, `websocket` was also allowed).']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListnodesNodesAddressesType {
	    #[serde(rename = "dns")]
	    DNS,
	    #[serde(rename = "ipv4")]
	    IPV4,
	    #[serde(rename = "ipv6")]
	    IPV6,
	    #[serde(rename = "torv2")]
	    TORV2,
	    #[serde(rename = "torv3")]
	    TORV3,
	}

	impl TryFrom<i32> for ListnodesNodesAddressesType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListnodesNodesAddressesType, anyhow::Error> {
	        match c {
	    0 => Ok(ListnodesNodesAddressesType::DNS),
	    1 => Ok(ListnodesNodesAddressesType::IPV4),
	    2 => Ok(ListnodesNodesAddressesType::IPV6),
	    3 => Ok(ListnodesNodesAddressesType::TORV2),
	    4 => Ok(ListnodesNodesAddressesType::TORV3),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListnodesNodesAddressesType", o)),
	        }
	    }
	}

	impl ToString for ListnodesNodesAddressesType {
	    fn to_string(&self) -> String {
	        match self {
	            ListnodesNodesAddressesType::DNS => "DNS",
	            ListnodesNodesAddressesType::IPV4 => "IPV4",
	            ListnodesNodesAddressesType::IPV6 => "IPV6",
	            ListnodesNodesAddressesType::TORV2 => "TORV2",
	            ListnodesNodesAddressesType::TORV3 => "TORV3",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListnodesNodesAddresses {
	    // Path `ListNodes.nodes[].addresses[].type`
	    #[serde(rename = "type")]
	    pub item_type: ListnodesNodesAddressesType,
	    pub port: u16,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub address: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListnodesNodes {
	    pub nodeid: PublicKey,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub last_timestamp: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub alias: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub color: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub features: Option<String>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub addresses: Option<Vec<ListnodesNodesAddresses>>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListnodesResponse {
	    pub nodes: Vec<ListnodesNodes>,
	}

	impl TryFrom<Response> for ListnodesResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListNodes(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ["Whether it's paid or expired."]
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum WaitanyinvoiceStatus {
	    #[serde(rename = "paid")]
	    PAID,
	    #[serde(rename = "expired")]
	    EXPIRED,
	}

	impl TryFrom<i32> for WaitanyinvoiceStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<WaitanyinvoiceStatus, anyhow::Error> {
	        match c {
	    0 => Ok(WaitanyinvoiceStatus::PAID),
	    1 => Ok(WaitanyinvoiceStatus::EXPIRED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum WaitanyinvoiceStatus", o)),
	        }
	    }
	}

	impl ToString for WaitanyinvoiceStatus {
	    fn to_string(&self) -> String {
	        match self {
	            WaitanyinvoiceStatus::PAID => "PAID",
	            WaitanyinvoiceStatus::EXPIRED => "EXPIRED",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitanyinvoicePaid_outpoint {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub txid: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub outnum: Option<u32>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitanyinvoiceResponse {
	    pub label: String,
	    pub description: String,
	    pub payment_hash: Sha256,
	    // Path `WaitAnyInvoice.status`
	    pub status: WaitanyinvoiceStatus,
	    pub expires_at: u64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub updated_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub pay_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_received_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub paid_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub paid_outpoint: Option<WaitanyinvoicePaid_outpoint>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	}

	impl TryFrom<Response> for WaitanyinvoiceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::WaitAnyInvoice(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ["Whether it's paid or expired."]
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum WaitinvoiceStatus {
	    #[serde(rename = "paid")]
	    PAID,
	    #[serde(rename = "expired")]
	    EXPIRED,
	}

	impl TryFrom<i32> for WaitinvoiceStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<WaitinvoiceStatus, anyhow::Error> {
	        match c {
	    0 => Ok(WaitinvoiceStatus::PAID),
	    1 => Ok(WaitinvoiceStatus::EXPIRED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum WaitinvoiceStatus", o)),
	        }
	    }
	}

	impl ToString for WaitinvoiceStatus {
	    fn to_string(&self) -> String {
	        match self {
	            WaitinvoiceStatus::PAID => "PAID",
	            WaitinvoiceStatus::EXPIRED => "EXPIRED",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitinvoicePaid_outpoint {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub txid: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub outnum: Option<u32>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitinvoiceResponse {
	    pub label: String,
	    pub description: String,
	    pub payment_hash: Sha256,
	    // Path `WaitInvoice.status`
	    pub status: WaitinvoiceStatus,
	    pub expires_at: u64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub updated_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub pay_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_received_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub paid_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub paid_outpoint: Option<WaitinvoicePaid_outpoint>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	}

	impl TryFrom<Response> for WaitinvoiceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::WaitInvoice(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Status of the payment.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum WaitsendpayStatus {
	    #[serde(rename = "complete")]
	    COMPLETE,
	}

	impl TryFrom<i32> for WaitsendpayStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<WaitsendpayStatus, anyhow::Error> {
	        match c {
	    0 => Ok(WaitsendpayStatus::COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum WaitsendpayStatus", o)),
	        }
	    }
	}

	impl ToString for WaitsendpayStatus {
	    fn to_string(&self) -> String {
	        match self {
	            WaitsendpayStatus::COMPLETE => "COMPLETE",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitsendpayResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_index: Option<u64>,
	    pub id: u64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub groupid: Option<u64>,
	    pub payment_hash: Sha256,
	    // Path `WaitSendPay.status`
	    pub status: WaitsendpayStatus,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    pub created_at: u64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub updated_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub completed_at: Option<f64>,
	    pub amount_sent_msat: Amount,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	}

	impl TryFrom<Response> for WaitsendpayResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::WaitSendPay(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct NewaddrResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub p2tr: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bech32: Option<String>,
	}

	impl TryFrom<Response> for NewaddrResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::NewAddr(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WithdrawResponse {
	    pub tx: String,
	    pub txid: String,
	    pub psbt: String,
	}

	impl TryFrom<Response> for WithdrawResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Withdraw(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Status of payment.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum KeysendStatus {
	    #[serde(rename = "complete")]
	    COMPLETE,
	}

	impl TryFrom<i32> for KeysendStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<KeysendStatus, anyhow::Error> {
	        match c {
	    0 => Ok(KeysendStatus::COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum KeysendStatus", o)),
	        }
	    }
	}

	impl ToString for KeysendStatus {
	    fn to_string(&self) -> String {
	        match self {
	            KeysendStatus::COMPLETE => "COMPLETE",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct KeysendResponse {
	    pub payment_preimage: Secret,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    pub payment_hash: Sha256,
	    pub created_at: f64,
	    pub parts: u32,
	    pub amount_msat: Amount,
	    pub amount_sent_msat: Amount,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_partial_completion: Option<String>,
	    // Path `KeySend.status`
	    pub status: KeysendStatus,
	}

	impl TryFrom<Response> for KeysendResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::KeySend(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FundpsbtReservations {
	    pub txid: String,
	    pub vout: u32,
	    pub was_reserved: bool,
	    pub reserved: bool,
	    pub reserved_to_block: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FundpsbtResponse {
	    pub psbt: String,
	    pub feerate_per_kw: u32,
	    pub estimated_final_weight: u32,
	    pub excess_msat: Amount,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub change_outnum: Option<u32>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub reservations: Option<Vec<FundpsbtReservations>>,
	}

	impl TryFrom<Response> for FundpsbtResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::FundPsbt(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendpsbtResponse {
	    pub tx: String,
	    pub txid: String,
	}

	impl TryFrom<Response> for SendpsbtResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SendPsbt(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SignpsbtResponse {
	    pub signed_psbt: String,
	}

	impl TryFrom<Response> for SignpsbtResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SignPsbt(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct UtxopsbtReservations {
	    pub txid: String,
	    pub vout: u32,
	    pub was_reserved: bool,
	    pub reserved: bool,
	    pub reserved_to_block: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct UtxopsbtResponse {
	    pub psbt: String,
	    pub feerate_per_kw: u32,
	    pub estimated_final_weight: u32,
	    pub excess_msat: Amount,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub change_outnum: Option<u32>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub reservations: Option<Vec<UtxopsbtReservations>>,
	}

	impl TryFrom<Response> for UtxopsbtResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::UtxoPsbt(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct TxdiscardResponse {
	    pub unsigned_tx: String,
	    pub txid: String,
	}

	impl TryFrom<Response> for TxdiscardResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::TxDiscard(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct TxprepareResponse {
	    pub psbt: String,
	    pub unsigned_tx: String,
	    pub txid: String,
	}

	impl TryFrom<Response> for TxprepareResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::TxPrepare(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct TxsendResponse {
	    pub psbt: String,
	    pub tx: String,
	    pub txid: String,
	}

	impl TryFrom<Response> for TxsendResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::TxSend(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['The channel state, in particular `CHANNELD_NORMAL` means the channel can be used normally.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListpeerchannelsChannelsState {
	    #[serde(rename = "OPENINGD")]
	    OPENINGD,
	    #[serde(rename = "CHANNELD_AWAITING_LOCKIN")]
	    CHANNELD_AWAITING_LOCKIN,
	    #[serde(rename = "CHANNELD_NORMAL")]
	    CHANNELD_NORMAL,
	    #[serde(rename = "CHANNELD_SHUTTING_DOWN")]
	    CHANNELD_SHUTTING_DOWN,
	    #[serde(rename = "CLOSINGD_SIGEXCHANGE")]
	    CLOSINGD_SIGEXCHANGE,
	    #[serde(rename = "CLOSINGD_COMPLETE")]
	    CLOSINGD_COMPLETE,
	    #[serde(rename = "AWAITING_UNILATERAL")]
	    AWAITING_UNILATERAL,
	    #[serde(rename = "FUNDING_SPEND_SEEN")]
	    FUNDING_SPEND_SEEN,
	    #[serde(rename = "ONCHAIN")]
	    ONCHAIN,
	    #[serde(rename = "DUALOPEND_OPEN_INIT")]
	    DUALOPEND_OPEN_INIT,
	    #[serde(rename = "DUALOPEND_AWAITING_LOCKIN")]
	    DUALOPEND_AWAITING_LOCKIN,
	    #[serde(rename = "CHANNELD_AWAITING_SPLICE")]
	    CHANNELD_AWAITING_SPLICE,
	    #[serde(rename = "DUALOPEND_OPEN_COMMITTED")]
	    DUALOPEND_OPEN_COMMITTED,
	    #[serde(rename = "DUALOPEND_OPEN_COMMIT_READY")]
	    DUALOPEND_OPEN_COMMIT_READY,
	}

	impl TryFrom<i32> for ListpeerchannelsChannelsState {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListpeerchannelsChannelsState, anyhow::Error> {
	        match c {
	    0 => Ok(ListpeerchannelsChannelsState::OPENINGD),
	    1 => Ok(ListpeerchannelsChannelsState::CHANNELD_AWAITING_LOCKIN),
	    2 => Ok(ListpeerchannelsChannelsState::CHANNELD_NORMAL),
	    3 => Ok(ListpeerchannelsChannelsState::CHANNELD_SHUTTING_DOWN),
	    4 => Ok(ListpeerchannelsChannelsState::CLOSINGD_SIGEXCHANGE),
	    5 => Ok(ListpeerchannelsChannelsState::CLOSINGD_COMPLETE),
	    6 => Ok(ListpeerchannelsChannelsState::AWAITING_UNILATERAL),
	    7 => Ok(ListpeerchannelsChannelsState::FUNDING_SPEND_SEEN),
	    8 => Ok(ListpeerchannelsChannelsState::ONCHAIN),
	    9 => Ok(ListpeerchannelsChannelsState::DUALOPEND_OPEN_INIT),
	    10 => Ok(ListpeerchannelsChannelsState::DUALOPEND_AWAITING_LOCKIN),
	    11 => Ok(ListpeerchannelsChannelsState::CHANNELD_AWAITING_SPLICE),
	    12 => Ok(ListpeerchannelsChannelsState::DUALOPEND_OPEN_COMMITTED),
	    13 => Ok(ListpeerchannelsChannelsState::DUALOPEND_OPEN_COMMIT_READY),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListpeerchannelsChannelsState", o)),
	        }
	    }
	}

	impl ToString for ListpeerchannelsChannelsState {
	    fn to_string(&self) -> String {
	        match self {
	            ListpeerchannelsChannelsState::OPENINGD => "OPENINGD",
	            ListpeerchannelsChannelsState::CHANNELD_AWAITING_LOCKIN => "CHANNELD_AWAITING_LOCKIN",
	            ListpeerchannelsChannelsState::CHANNELD_NORMAL => "CHANNELD_NORMAL",
	            ListpeerchannelsChannelsState::CHANNELD_SHUTTING_DOWN => "CHANNELD_SHUTTING_DOWN",
	            ListpeerchannelsChannelsState::CLOSINGD_SIGEXCHANGE => "CLOSINGD_SIGEXCHANGE",
	            ListpeerchannelsChannelsState::CLOSINGD_COMPLETE => "CLOSINGD_COMPLETE",
	            ListpeerchannelsChannelsState::AWAITING_UNILATERAL => "AWAITING_UNILATERAL",
	            ListpeerchannelsChannelsState::FUNDING_SPEND_SEEN => "FUNDING_SPEND_SEEN",
	            ListpeerchannelsChannelsState::ONCHAIN => "ONCHAIN",
	            ListpeerchannelsChannelsState::DUALOPEND_OPEN_INIT => "DUALOPEND_OPEN_INIT",
	            ListpeerchannelsChannelsState::DUALOPEND_AWAITING_LOCKIN => "DUALOPEND_AWAITING_LOCKIN",
	            ListpeerchannelsChannelsState::CHANNELD_AWAITING_SPLICE => "CHANNELD_AWAITING_SPLICE",
	            ListpeerchannelsChannelsState::DUALOPEND_OPEN_COMMITTED => "DUALOPEND_OPEN_COMMITTED",
	            ListpeerchannelsChannelsState::DUALOPEND_OPEN_COMMIT_READY => "DUALOPEND_OPEN_COMMIT_READY",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeerchannelsChannelsUpdatesLocal {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub htlc_minimum_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub htlc_maximum_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub cltv_expiry_delta: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_base_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_proportional_millionths: Option<u32>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeerchannelsChannelsUpdatesRemote {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub htlc_minimum_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub htlc_maximum_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub cltv_expiry_delta: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_base_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_proportional_millionths: Option<u32>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeerchannelsChannelsUpdates {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub local: Option<ListpeerchannelsChannelsUpdatesLocal>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub remote: Option<ListpeerchannelsChannelsUpdatesRemote>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeerchannelsChannelsFeerate {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub perkw: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub perkb: Option<u32>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeerchannelsChannelsInflight {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_txid: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_outnum: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feerate: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub total_funding_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub splice_amount: Option<i64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub our_funding_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub scratch_txid: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeerchannelsChannelsFunding {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub pushed_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub local_funds_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub remote_funds_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_paid_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_rcvd_msat: Option<Amount>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeerchannelsChannelsAlias {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub local: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub remote: Option<ShortChannelId>,
	}

	/// ['Whether it came from peer, or is going to peer.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListpeerchannelsChannelsHtlcsDirection {
	    #[serde(rename = "in")]
	    IN,
	    #[serde(rename = "out")]
	    OUT,
	}

	impl TryFrom<i32> for ListpeerchannelsChannelsHtlcsDirection {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListpeerchannelsChannelsHtlcsDirection, anyhow::Error> {
	        match c {
	    0 => Ok(ListpeerchannelsChannelsHtlcsDirection::IN),
	    1 => Ok(ListpeerchannelsChannelsHtlcsDirection::OUT),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListpeerchannelsChannelsHtlcsDirection", o)),
	        }
	    }
	}

	impl ToString for ListpeerchannelsChannelsHtlcsDirection {
	    fn to_string(&self) -> String {
	        match self {
	            ListpeerchannelsChannelsHtlcsDirection::IN => "IN",
	            ListpeerchannelsChannelsHtlcsDirection::OUT => "OUT",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeerchannelsChannelsHtlcs {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub direction: Option<ListpeerchannelsChannelsHtlcsDirection>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub id: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub expiry: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_hash: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub local_trimmed: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub status: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub state: Option<HtlcState>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeerchannelsChannels {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub peer_id: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub peer_connected: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub reestablished: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub state: Option<ListpeerchannelsChannelsState>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub scratch_txid: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub updates: Option<ListpeerchannelsChannelsUpdates>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub ignore_fee_limits: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub lost_state: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feerate: Option<ListpeerchannelsChannelsFeerate>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub owner: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub short_channel_id: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub channel_id: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_txid: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_outnum: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub initial_feerate: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub last_feerate: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub next_feerate: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub next_fee_step: Option<u32>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub inflight: Option<Vec<ListpeerchannelsChannelsInflight>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub close_to: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub private: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub opener: Option<ChannelSide>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub closer: Option<ChannelSide>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding: Option<ListpeerchannelsChannelsFunding>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub to_us_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub min_to_us_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub max_to_us_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub total_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_base_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_proportional_millionths: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub dust_limit_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub max_total_htlc_in_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub their_reserve_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub our_reserve_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub spendable_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub receivable_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub minimum_htlc_in_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub minimum_htlc_out_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub maximum_htlc_out_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub their_to_self_delay: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub our_to_self_delay: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub max_accepted_htlcs: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub alias: Option<ListpeerchannelsChannelsAlias>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub status: Option<Vec<String>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub in_payments_offered: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub in_offered_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub in_payments_fulfilled: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub in_fulfilled_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_payments_offered: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_offered_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_payments_fulfilled: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_fulfilled_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub last_stable_connection: Option<u64>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub htlcs: Option<Vec<ListpeerchannelsChannelsHtlcs>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub close_to_addr: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeerchannelsResponse {
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub channels: Option<Vec<ListpeerchannelsChannels>>,
	}

	impl TryFrom<Response> for ListpeerchannelsResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListPeerChannels(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListclosedchannelsClosedchannelsAlias {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub local: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub remote: Option<ShortChannelId>,
	}

	/// ['What caused the channel to close.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListclosedchannelsClosedchannelsClose_cause {
	    #[serde(rename = "unknown")]
	    UNKNOWN,
	    #[serde(rename = "local")]
	    LOCAL,
	    #[serde(rename = "user")]
	    USER,
	    #[serde(rename = "remote")]
	    REMOTE,
	    #[serde(rename = "protocol")]
	    PROTOCOL,
	    #[serde(rename = "onchain")]
	    ONCHAIN,
	}

	impl TryFrom<i32> for ListclosedchannelsClosedchannelsClose_cause {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListclosedchannelsClosedchannelsClose_cause, anyhow::Error> {
	        match c {
	    0 => Ok(ListclosedchannelsClosedchannelsClose_cause::UNKNOWN),
	    1 => Ok(ListclosedchannelsClosedchannelsClose_cause::LOCAL),
	    2 => Ok(ListclosedchannelsClosedchannelsClose_cause::USER),
	    3 => Ok(ListclosedchannelsClosedchannelsClose_cause::REMOTE),
	    4 => Ok(ListclosedchannelsClosedchannelsClose_cause::PROTOCOL),
	    5 => Ok(ListclosedchannelsClosedchannelsClose_cause::ONCHAIN),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListclosedchannelsClosedchannelsClose_cause", o)),
	        }
	    }
	}

	impl ToString for ListclosedchannelsClosedchannelsClose_cause {
	    fn to_string(&self) -> String {
	        match self {
	            ListclosedchannelsClosedchannelsClose_cause::UNKNOWN => "UNKNOWN",
	            ListclosedchannelsClosedchannelsClose_cause::LOCAL => "LOCAL",
	            ListclosedchannelsClosedchannelsClose_cause::USER => "USER",
	            ListclosedchannelsClosedchannelsClose_cause::REMOTE => "REMOTE",
	            ListclosedchannelsClosedchannelsClose_cause::PROTOCOL => "PROTOCOL",
	            ListclosedchannelsClosedchannelsClose_cause::ONCHAIN => "ONCHAIN",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListclosedchannelsClosedchannels {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub peer_id: Option<PublicKey>,
	    pub channel_id: Sha256,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub short_channel_id: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub alias: Option<ListclosedchannelsClosedchannelsAlias>,
	    // Path `ListClosedChannels.closedchannels[].opener`
	    pub opener: ChannelSide,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub closer: Option<ChannelSide>,
	    pub private: bool,
	    pub total_local_commitments: u64,
	    pub total_remote_commitments: u64,
	    pub total_htlcs_sent: u64,
	    pub funding_txid: String,
	    pub funding_outnum: u32,
	    pub leased: bool,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_fee_paid_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_fee_rcvd_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_pushed_msat: Option<Amount>,
	    pub total_msat: Amount,
	    pub final_to_us_msat: Amount,
	    pub min_to_us_msat: Amount,
	    pub max_to_us_msat: Amount,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub last_commitment_txid: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub last_commitment_fee_msat: Option<Amount>,
	    // Path `ListClosedChannels.closedchannels[].close_cause`
	    pub close_cause: ListclosedchannelsClosedchannelsClose_cause,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub last_stable_connection: Option<u64>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListclosedchannelsResponse {
	    pub closedchannels: Vec<ListclosedchannelsClosedchannels>,
	}

	impl TryFrom<Response> for ListclosedchannelsResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListClosedChannels(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['The address type (if known).']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum DecodepayFallbacksType {
	    #[serde(rename = "P2PKH")]
	    P2PKH,
	    #[serde(rename = "P2SH")]
	    P2SH,
	    #[serde(rename = "P2WPKH")]
	    P2WPKH,
	    #[serde(rename = "P2WSH")]
	    P2WSH,
	    #[serde(rename = "P2TR")]
	    P2TR,
	}

	impl TryFrom<i32> for DecodepayFallbacksType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<DecodepayFallbacksType, anyhow::Error> {
	        match c {
	    0 => Ok(DecodepayFallbacksType::P2PKH),
	    1 => Ok(DecodepayFallbacksType::P2SH),
	    2 => Ok(DecodepayFallbacksType::P2WPKH),
	    3 => Ok(DecodepayFallbacksType::P2WSH),
	    4 => Ok(DecodepayFallbacksType::P2TR),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum DecodepayFallbacksType", o)),
	        }
	    }
	}

	impl ToString for DecodepayFallbacksType {
	    fn to_string(&self) -> String {
	        match self {
	            DecodepayFallbacksType::P2PKH => "P2PKH",
	            DecodepayFallbacksType::P2SH => "P2SH",
	            DecodepayFallbacksType::P2WPKH => "P2WPKH",
	            DecodepayFallbacksType::P2WSH => "P2WSH",
	            DecodepayFallbacksType::P2TR => "P2TR",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodepayFallbacks {
	    // Path `DecodePay.fallbacks[].type`
	    #[serde(rename = "type")]
	    pub item_type: DecodepayFallbacksType,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub addr: Option<String>,
	    pub hex: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodepayExtra {
	    pub tag: String,
	    pub data: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodepayResponse {
	    pub currency: String,
	    pub created_at: u64,
	    pub expiry: u64,
	    pub payee: PublicKey,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    pub payment_hash: Sha256,
	    pub signature: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description_hash: Option<Sha256>,
	    pub min_final_cltv_expiry: u32,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_secret: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub features: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_metadata: Option<String>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub fallbacks: Option<Vec<DecodepayFallbacks>>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub extra: Option<Vec<DecodepayExtra>>,
	}

	impl TryFrom<Response> for DecodepayResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::DecodePay(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['What kind of object it decoded to.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum DecodeType {
	    #[serde(rename = "bolt12 offer")]
	    BOLT12_OFFER,
	    #[serde(rename = "bolt12 invoice")]
	    BOLT12_INVOICE,
	    #[serde(rename = "bolt12 invoice_request")]
	    BOLT12_INVOICE_REQUEST,
	    #[serde(rename = "bolt11 invoice")]
	    BOLT11_INVOICE,
	    #[serde(rename = "rune")]
	    RUNE,
	    #[serde(rename = "emergency recover")]
	    EMERGENCY_RECOVER,
	}

	impl TryFrom<i32> for DecodeType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<DecodeType, anyhow::Error> {
	        match c {
	    0 => Ok(DecodeType::BOLT12_OFFER),
	    1 => Ok(DecodeType::BOLT12_INVOICE),
	    2 => Ok(DecodeType::BOLT12_INVOICE_REQUEST),
	    3 => Ok(DecodeType::BOLT11_INVOICE),
	    4 => Ok(DecodeType::RUNE),
	    5 => Ok(DecodeType::EMERGENCY_RECOVER),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum DecodeType", o)),
	        }
	    }
	}

	impl ToString for DecodeType {
	    fn to_string(&self) -> String {
	        match self {
	            DecodeType::BOLT12_OFFER => "BOLT12_OFFER",
	            DecodeType::BOLT12_INVOICE => "BOLT12_INVOICE",
	            DecodeType::BOLT12_INVOICE_REQUEST => "BOLT12_INVOICE_REQUEST",
	            DecodeType::BOLT11_INVOICE => "BOLT11_INVOICE",
	            DecodeType::RUNE => "RUNE",
	            DecodeType::EMERGENCY_RECOVER => "EMERGENCY_RECOVER",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeOffer_paths {
	    pub first_node_id: PublicKey,
	    pub blinding: PublicKey,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeInvoice_fallbacks {
	    pub version: u8,
	    pub hex: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub address: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeFallbacks {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_invoice_fallbacks_version_invalid: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeExtra {
	    pub tag: String,
	    pub data: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeRestrictions {
	    pub alternatives: Vec<String>,
	    pub summary: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeResponse {
	    // Path `Decode.type`
	    #[serde(rename = "type")]
	    pub item_type: DecodeType,
	    pub valid: bool,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_id: Option<String>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub offer_chains: Option<Vec<Sha256>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_metadata: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_currency: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_unknown_offer_currency: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub currency_minor_unit: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_amount: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_issuer: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_features: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_absolute_expiry: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_quantity_max: Option<u64>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub offer_paths: Option<Vec<DecodeOffer_paths>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_node_id: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_offer_node_id: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_invalid_offer_description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_offer_description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_invalid_offer_currency: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_invalid_offer_issuer: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_metadata: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_payer_id: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_chain: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_features: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_quantity: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_payer_note: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_recurrence_counter: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_recurrence_start: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invreq_metadata: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invreq_payer_id: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_invalid_invreq_payer_note: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invoice_request_signature: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_invalid_invoice_request_signature: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invoice_created_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invoice_relative_expiry: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invoice_payment_hash: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invoice_amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub invoice_fallbacks: Option<Vec<DecodeInvoice_fallbacks>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invoice_features: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invoice_node_id: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invoice_recurrence_basetime: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invoice_paths: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invoice_blindedpay: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invoice_created_at: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invoice_payment_hash: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invoice_amount: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invoice_recurrence_basetime: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invoice_node_id: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invoice_signature: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_invalid_invoice_signature: Option<String>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub fallbacks: Option<Vec<DecodeFallbacks>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub expiry: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payee: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_hash: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description_hash: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub min_final_cltv_expiry: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_secret: Option<Secret>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_metadata: Option<String>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub extra: Option<Vec<DecodeExtra>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub unique_id: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub version: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub string: Option<String>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub restrictions: Option<Vec<DecodeRestrictions>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_rune_invalid_utf8: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub hex: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub decrypted: Option<String>,
	}

	impl TryFrom<Response> for DecodeResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Decode(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DisconnectResponse {
	}

	impl TryFrom<Response> for DisconnectResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Disconnect(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FeeratesPerkbEstimates {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub blockcount: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feerate: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub smoothed_feerate: Option<u32>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FeeratesPerkb {
	    pub min_acceptable: u32,
	    pub max_acceptable: u32,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub floor: Option<u32>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub estimates: Option<Vec<FeeratesPerkbEstimates>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub opening: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub mutual_close: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub unilateral_close: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub unilateral_anchor_close: Option<u32>,
	    #[deprecated]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub delayed_to_us: Option<u32>,
	    #[deprecated]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub htlc_resolution: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub penalty: Option<u32>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FeeratesPerkwEstimates {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub blockcount: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feerate: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub smoothed_feerate: Option<u32>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FeeratesPerkw {
	    pub min_acceptable: u32,
	    pub max_acceptable: u32,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub floor: Option<u32>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub estimates: Option<Vec<FeeratesPerkwEstimates>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub opening: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub mutual_close: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub unilateral_close: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub unilateral_anchor_close: Option<u32>,
	    #[deprecated]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub delayed_to_us: Option<u32>,
	    #[deprecated]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub htlc_resolution: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub penalty: Option<u32>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FeeratesOnchain_fee_estimates {
	    pub opening_channel_satoshis: u64,
	    pub mutual_close_satoshis: u64,
	    pub unilateral_close_satoshis: u64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub unilateral_close_nonanchor_satoshis: Option<u64>,
	    pub htlc_timeout_satoshis: u64,
	    pub htlc_success_satoshis: u64,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FeeratesResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_feerates: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub perkb: Option<FeeratesPerkb>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub perkw: Option<FeeratesPerkw>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub onchain_fee_estimates: Option<FeeratesOnchain_fee_estimates>,
	}

	impl TryFrom<Response> for FeeratesResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Feerates(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FetchinvoiceChanges {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description_appended: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub vendor_removed: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub vendor: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FetchinvoiceNext_period {
	    pub counter: u64,
	    pub starttime: u64,
	    pub endtime: u64,
	    pub paywindow_start: u64,
	    pub paywindow_end: u64,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FetchinvoiceResponse {
	    pub invoice: String,
	    pub changes: FetchinvoiceChanges,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub next_period: Option<FetchinvoiceNext_period>,
	}

	impl TryFrom<Response> for FetchinvoiceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::FetchInvoice(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FundchannelChannel_type {
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub bits: Option<Vec<u32>>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub names: Option<Vec<ChannelTypeName>>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FundchannelResponse {
	    pub tx: String,
	    pub txid: String,
	    pub outnum: u32,
	    pub channel_id: Sha256,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub channel_type: Option<FundchannelChannel_type>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub close_to: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub mindepth: Option<u32>,
	}

	impl TryFrom<Response> for FundchannelResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::FundChannel(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['The features understood by the destination node.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum GetrouteRouteStyle {
	    #[serde(rename = "tlv")]
	    TLV,
	}

	impl TryFrom<i32> for GetrouteRouteStyle {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<GetrouteRouteStyle, anyhow::Error> {
	        match c {
	    0 => Ok(GetrouteRouteStyle::TLV),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum GetrouteRouteStyle", o)),
	        }
	    }
	}

	impl ToString for GetrouteRouteStyle {
	    fn to_string(&self) -> String {
	        match self {
	            GetrouteRouteStyle::TLV => "TLV",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetrouteRoute {
	    pub id: PublicKey,
	    pub channel: ShortChannelId,
	    pub direction: u32,
	    pub amount_msat: Amount,
	    pub delay: u32,
	    // Path `GetRoute.route[].style`
	    pub style: GetrouteRouteStyle,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetrouteResponse {
	    pub route: Vec<GetrouteRoute>,
	}

	impl TryFrom<Response> for GetrouteResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::GetRoute(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Still ongoing, completed, failed locally, or failed after forwarding.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListforwardsForwardsStatus {
	    #[serde(rename = "offered")]
	    OFFERED,
	    #[serde(rename = "settled")]
	    SETTLED,
	    #[serde(rename = "local_failed")]
	    LOCAL_FAILED,
	    #[serde(rename = "failed")]
	    FAILED,
	}

	impl TryFrom<i32> for ListforwardsForwardsStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListforwardsForwardsStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListforwardsForwardsStatus::OFFERED),
	    1 => Ok(ListforwardsForwardsStatus::SETTLED),
	    2 => Ok(ListforwardsForwardsStatus::LOCAL_FAILED),
	    3 => Ok(ListforwardsForwardsStatus::FAILED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListforwardsForwardsStatus", o)),
	        }
	    }
	}

	impl ToString for ListforwardsForwardsStatus {
	    fn to_string(&self) -> String {
	        match self {
	            ListforwardsForwardsStatus::OFFERED => "OFFERED",
	            ListforwardsForwardsStatus::SETTLED => "SETTLED",
	            ListforwardsForwardsStatus::LOCAL_FAILED => "LOCAL_FAILED",
	            ListforwardsForwardsStatus::FAILED => "FAILED",
	        }.to_string()
	    }
	}

	/// ['Either a legacy onion format or a modern tlv format.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListforwardsForwardsStyle {
	    #[serde(rename = "legacy")]
	    LEGACY,
	    #[serde(rename = "tlv")]
	    TLV,
	}

	impl TryFrom<i32> for ListforwardsForwardsStyle {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListforwardsForwardsStyle, anyhow::Error> {
	        match c {
	    0 => Ok(ListforwardsForwardsStyle::LEGACY),
	    1 => Ok(ListforwardsForwardsStyle::TLV),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListforwardsForwardsStyle", o)),
	        }
	    }
	}

	impl ToString for ListforwardsForwardsStyle {
	    fn to_string(&self) -> String {
	        match self {
	            ListforwardsForwardsStyle::LEGACY => "LEGACY",
	            ListforwardsForwardsStyle::TLV => "TLV",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListforwardsForwards {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_index: Option<u64>,
	    pub in_channel: ShortChannelId,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub in_htlc_id: Option<u64>,
	    pub in_msat: Amount,
	    // Path `ListForwards.forwards[].status`
	    pub status: ListforwardsForwardsStatus,
	    pub received_time: f64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_channel: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_htlc_id: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub updated_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub style: Option<ListforwardsForwardsStyle>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_msat: Option<Amount>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListforwardsResponse {
	    pub forwards: Vec<ListforwardsForwards>,
	}

	impl TryFrom<Response> for ListforwardsResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListForwards(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListoffersOffers {
	    pub offer_id: Sha256,
	    pub active: bool,
	    pub single_use: bool,
	    pub bolt12: String,
	    pub used: bool,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListoffersResponse {
	    pub offers: Vec<ListoffersOffers>,
	}

	impl TryFrom<Response> for ListoffersResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListOffers(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Status of the payment.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListpaysPaysStatus {
	    #[serde(rename = "pending")]
	    PENDING,
	    #[serde(rename = "failed")]
	    FAILED,
	    #[serde(rename = "complete")]
	    COMPLETE,
	}

	impl TryFrom<i32> for ListpaysPaysStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListpaysPaysStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListpaysPaysStatus::PENDING),
	    1 => Ok(ListpaysPaysStatus::FAILED),
	    2 => Ok(ListpaysPaysStatus::COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListpaysPaysStatus", o)),
	        }
	    }
	}

	impl ToString for ListpaysPaysStatus {
	    fn to_string(&self) -> String {
	        match self {
	            ListpaysPaysStatus::PENDING => "PENDING",
	            ListpaysPaysStatus::FAILED => "FAILED",
	            ListpaysPaysStatus::COMPLETE => "COMPLETE",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpaysPays {
	    pub payment_hash: Sha256,
	    // Path `ListPays.pays[].status`
	    pub status: ListpaysPaysStatus,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    pub created_at: u64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub completed_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_sent_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub preimage: Option<Secret>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub number_of_parts: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub erroronion: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpaysResponse {
	    pub pays: Vec<ListpaysPays>,
	}

	impl TryFrom<Response> for ListpaysResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListPays(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Out if we offered this to the peer, in if they offered it.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListhtlcsHtlcsDirection {
	    #[serde(rename = "out")]
	    OUT,
	    #[serde(rename = "in")]
	    IN,
	}

	impl TryFrom<i32> for ListhtlcsHtlcsDirection {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListhtlcsHtlcsDirection, anyhow::Error> {
	        match c {
	    0 => Ok(ListhtlcsHtlcsDirection::OUT),
	    1 => Ok(ListhtlcsHtlcsDirection::IN),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListhtlcsHtlcsDirection", o)),
	        }
	    }
	}

	impl ToString for ListhtlcsHtlcsDirection {
	    fn to_string(&self) -> String {
	        match self {
	            ListhtlcsHtlcsDirection::OUT => "OUT",
	            ListhtlcsHtlcsDirection::IN => "IN",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListhtlcsHtlcs {
	    pub short_channel_id: ShortChannelId,
	    pub id: u64,
	    pub expiry: u32,
	    pub amount_msat: Amount,
	    // Path `ListHtlcs.htlcs[].direction`
	    pub direction: ListhtlcsHtlcsDirection,
	    pub payment_hash: Sha256,
	    // Path `ListHtlcs.htlcs[].state`
	    pub state: HtlcState,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListhtlcsResponse {
	    pub htlcs: Vec<ListhtlcsHtlcs>,
	}

	impl TryFrom<Response> for ListhtlcsResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListHtlcs(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct OfferResponse {
	    pub offer_id: Sha256,
	    pub active: bool,
	    pub single_use: bool,
	    pub bolt12: String,
	    pub used: bool,
	    pub created: bool,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	}

	impl TryFrom<Response> for OfferResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Offer(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct PingResponse {
	    pub totlen: u16,
	}

	impl TryFrom<Response> for PingResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Ping(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendcustommsgResponse {
	    pub status: String,
	}

	impl TryFrom<Response> for SendcustommsgResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SendCustomMsg(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SetchannelChannels {
	    pub peer_id: PublicKey,
	    pub channel_id: Sha256,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub short_channel_id: Option<ShortChannelId>,
	    pub fee_base_msat: Amount,
	    pub fee_proportional_millionths: u32,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub ignore_fee_limits: Option<bool>,
	    pub minimum_htlc_out_msat: Amount,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_htlcmin_too_low: Option<String>,
	    pub maximum_htlc_out_msat: Amount,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_htlcmax_too_high: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SetchannelResponse {
	    pub channels: Vec<SetchannelChannels>,
	}

	impl TryFrom<Response> for SetchannelResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SetChannel(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SigninvoiceResponse {
	    pub bolt11: String,
	}

	impl TryFrom<Response> for SigninvoiceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SignInvoice(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SignmessageResponse {
	    pub signature: String,
	    pub recid: String,
	    pub zbase: String,
	}

	impl TryFrom<Response> for SignmessageResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SignMessage(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitblockheightResponse {
	    pub blockheight: u32,
	}

	impl TryFrom<Response> for WaitblockheightResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::WaitBlockHeight(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum WaitSubsystem {
	    #[serde(rename = "invoices")]
	    INVOICES,
	    #[serde(rename = "forwards")]
	    FORWARDS,
	    #[serde(rename = "sendpays")]
	    SENDPAYS,
	}

	impl TryFrom<i32> for WaitSubsystem {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<WaitSubsystem, anyhow::Error> {
	        match c {
	    0 => Ok(WaitSubsystem::INVOICES),
	    1 => Ok(WaitSubsystem::FORWARDS),
	    2 => Ok(WaitSubsystem::SENDPAYS),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum WaitSubsystem", o)),
	        }
	    }
	}

	impl ToString for WaitSubsystem {
	    fn to_string(&self) -> String {
	        match self {
	            WaitSubsystem::INVOICES => "INVOICES",
	            WaitSubsystem::FORWARDS => "FORWARDS",
	            WaitSubsystem::SENDPAYS => "SENDPAYS",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitResponse {
	    // Path `Wait.subsystem`
	    pub subsystem: WaitSubsystem,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub updated: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub deleted: Option<u64>,
	}

	impl TryFrom<Response> for WaitResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Wait(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum StopResult {
	    #[serde(rename = "Shutdown complete")]
	    SHUTDOWN_COMPLETE,
	}

	impl TryFrom<i32> for StopResult {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<StopResult, anyhow::Error> {
	        match c {
	    0 => Ok(StopResult::SHUTDOWN_COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum StopResult", o)),
	        }
	    }
	}

	impl ToString for StopResult {
	    fn to_string(&self) -> String {
	        match self {
	            StopResult::SHUTDOWN_COMPLETE => "SHUTDOWN_COMPLETE",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct StopResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub result: Option<StopResult>,
	}

	impl TryFrom<Response> for StopResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Stop(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct PreapprovekeysendResponse {
	}

	impl TryFrom<Response> for PreapprovekeysendResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::PreApproveKeysend(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct PreapproveinvoiceResponse {
	}

	impl TryFrom<Response> for PreapproveinvoiceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::PreApproveInvoice(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct StaticbackupResponse {
	    pub scb: Vec<String>,
	}

	impl TryFrom<Response> for StaticbackupResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::StaticBackup(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct BkprlistincomeIncome_events {
	    pub account: String,
	    pub tag: String,
	    pub credit_msat: Amount,
	    pub debit_msat: Amount,
	    pub currency: String,
	    pub timestamp: u32,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub outpoint: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub txid: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_id: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct BkprlistincomeResponse {
	    pub income_events: Vec<BkprlistincomeIncome_events>,
	}

	impl TryFrom<Response> for BkprlistincomeResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::BkprListIncome(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

}

