#![allow(non_camel_case_types)]
//
// This file was automatically generated using the following command:
//
// ```bash
// contrib/msggen/msggen/__main__.py generate
// ```
//
// Do not edit this file, it'll be overwritten. Rather edit the schema that
// this file was generated from

//! A collection of models to describe [requests] and [responses].
//!
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(tag = "method", content = "params")]
#[serde(rename_all = "lowercase")]
pub enum Request {
	Getinfo(requests::GetinfoRequest),
	ListPeers(requests::ListpeersRequest),
	ListFunds(requests::ListfundsRequest),
	SendPay(requests::SendpayRequest),
	ListChannels(requests::ListchannelsRequest),
	AddGossip(requests::AddgossipRequest),
	AddPsbtOutput(requests::AddpsbtoutputRequest),
	AutoCleanInvoice(requests::AutocleaninvoiceRequest),
	#[serde(rename = "autoclean-once")]
	AutoCleanOnce(requests::AutocleanonceRequest),
	#[serde(rename = "autoclean-status")]
	AutoCleanStatus(requests::AutocleanstatusRequest),
	CheckMessage(requests::CheckmessageRequest),
	Close(requests::CloseRequest),
	Connect(requests::ConnectRequest),
	CreateInvoice(requests::CreateinvoiceRequest),
	Datastore(requests::DatastoreRequest),
	DatastoreUsage(requests::DatastoreusageRequest),
	CreateOnion(requests::CreateonionRequest),
	DelDatastore(requests::DeldatastoreRequest),
	DelInvoice(requests::DelinvoiceRequest),
	#[serde(rename = "dev-forget-channel")]
	DevForgetChannel(requests::DevforgetchannelRequest),
	EmergencyRecover(requests::EmergencyrecoverRequest),
	Recover(requests::RecoverRequest),
	RecoverChannel(requests::RecoverchannelRequest),
	Invoice(requests::InvoiceRequest),
	InvoiceRequest(requests::InvoicerequestRequest),
	DisableInvoiceRequest(requests::DisableinvoicerequestRequest),
	ListInvoiceRequests(requests::ListinvoicerequestsRequest),
	ListDatastore(requests::ListdatastoreRequest),
	ListInvoices(requests::ListinvoicesRequest),
	SendOnion(requests::SendonionRequest),
	ListSendPays(requests::ListsendpaysRequest),
	ListTransactions(requests::ListtransactionsRequest),
	MakeSecret(requests::MakesecretRequest),
	Pay(requests::PayRequest),
	ListNodes(requests::ListnodesRequest),
	WaitAnyInvoice(requests::WaitanyinvoiceRequest),
	WaitInvoice(requests::WaitinvoiceRequest),
	WaitSendPay(requests::WaitsendpayRequest),
	NewAddr(requests::NewaddrRequest),
	Withdraw(requests::WithdrawRequest),
	KeySend(requests::KeysendRequest),
	FundPsbt(requests::FundpsbtRequest),
	SendPsbt(requests::SendpsbtRequest),
	SignPsbt(requests::SignpsbtRequest),
	UtxoPsbt(requests::UtxopsbtRequest),
	TxDiscard(requests::TxdiscardRequest),
	TxPrepare(requests::TxprepareRequest),
	TxSend(requests::TxsendRequest),
	ListPeerChannels(requests::ListpeerchannelsRequest),
	ListClosedChannels(requests::ListclosedchannelsRequest),
	DecodePay(requests::DecodepayRequest),
	Decode(requests::DecodeRequest),
	DelPay(requests::DelpayRequest),
	DelForward(requests::DelforwardRequest),
	DisableOffer(requests::DisableofferRequest),
	Disconnect(requests::DisconnectRequest),
	Feerates(requests::FeeratesRequest),
	FetchInvoice(requests::FetchinvoiceRequest),
	FundChannel_Cancel(requests::Fundchannel_cancelRequest),
	FundChannel_Complete(requests::Fundchannel_completeRequest),
	FundChannel(requests::FundchannelRequest),
	FundChannel_Start(requests::Fundchannel_startRequest),
	GetLog(requests::GetlogRequest),
	FunderUpdate(requests::FunderupdateRequest),
	GetRoute(requests::GetrouteRequest),
	ListForwards(requests::ListforwardsRequest),
	ListOffers(requests::ListoffersRequest),
	ListPays(requests::ListpaysRequest),
	ListHtlcs(requests::ListhtlcsRequest),
	MultiFundChannel(requests::MultifundchannelRequest),
	MultiWithdraw(requests::MultiwithdrawRequest),
	Offer(requests::OfferRequest),
	OpenChannel_Abort(requests::Openchannel_abortRequest),
	OpenChannel_Bump(requests::Openchannel_bumpRequest),
	OpenChannel_Init(requests::Openchannel_initRequest),
	OpenChannel_Signed(requests::Openchannel_signedRequest),
	OpenChannel_Update(requests::Openchannel_updateRequest),
	Ping(requests::PingRequest),
	Plugin(requests::PluginRequest),
	RenePayStatus(requests::RenepaystatusRequest),
	RenePay(requests::RenepayRequest),
	ReserveInputs(requests::ReserveinputsRequest),
	SendCustomMsg(requests::SendcustommsgRequest),
	SendInvoice(requests::SendinvoiceRequest),
	SendOnionMessage(requests::SendonionmessageRequest),
	SetChannel(requests::SetchannelRequest),
	SetConfig(requests::SetconfigRequest),
	SetPsbtVersion(requests::SetpsbtversionRequest),
	SignInvoice(requests::SigninvoiceRequest),
	SignMessage(requests::SignmessageRequest),
	Splice_Init(requests::Splice_initRequest),
	Splice_Signed(requests::Splice_signedRequest),
	Splice_Update(requests::Splice_updateRequest),
	UnreserveInputs(requests::UnreserveinputsRequest),
	UpgradeWallet(requests::UpgradewalletRequest),
	WaitBlockHeight(requests::WaitblockheightRequest),
	Wait(requests::WaitRequest),
	ListConfigs(requests::ListconfigsRequest),
	Stop(requests::StopRequest),
	Help(requests::HelpRequest),
	PreApproveKeysend(requests::PreapprovekeysendRequest),
	PreApproveInvoice(requests::PreapproveinvoiceRequest),
	StaticBackup(requests::StaticbackupRequest),
	#[serde(rename = "bkpr-channelsapy")]
	BkprChannelsApy(requests::BkprchannelsapyRequest),
	#[serde(rename = "bkpr-dumpincomecsv")]
	BkprDumpIncomeCsv(requests::BkprdumpincomecsvRequest),
	#[serde(rename = "bkpr-inspect")]
	BkprInspect(requests::BkprinspectRequest),
	#[serde(rename = "bkpr-listaccountevents")]
	BkprListAccountEvents(requests::BkprlistaccounteventsRequest),
	#[serde(rename = "bkpr-listbalances")]
	BkprListBalances(requests::BkprlistbalancesRequest),
	#[serde(rename = "bkpr-listincome")]
	BkprListIncome(requests::BkprlistincomeRequest),
	BlacklistRune(requests::BlacklistruneRequest),
	CheckRune(requests::CheckruneRequest),
	CreateRune(requests::CreateruneRequest),
	ShowRunes(requests::ShowrunesRequest),
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(tag = "method", content = "result")]
#[serde(rename_all = "lowercase")]
pub enum Response {
	Getinfo(responses::GetinfoResponse),
	ListPeers(responses::ListpeersResponse),
	ListFunds(responses::ListfundsResponse),
	SendPay(responses::SendpayResponse),
	ListChannels(responses::ListchannelsResponse),
	AddGossip(responses::AddgossipResponse),
	AddPsbtOutput(responses::AddpsbtoutputResponse),
	AutoCleanInvoice(responses::AutocleaninvoiceResponse),
	#[serde(rename = "autoclean-once")]
	AutoCleanOnce(responses::AutocleanonceResponse),
	#[serde(rename = "autoclean-status")]
	AutoCleanStatus(responses::AutocleanstatusResponse),
	CheckMessage(responses::CheckmessageResponse),
	Close(responses::CloseResponse),
	Connect(responses::ConnectResponse),
	CreateInvoice(responses::CreateinvoiceResponse),
	Datastore(responses::DatastoreResponse),
	DatastoreUsage(responses::DatastoreusageResponse),
	CreateOnion(responses::CreateonionResponse),
	DelDatastore(responses::DeldatastoreResponse),
	DelInvoice(responses::DelinvoiceResponse),
	#[serde(rename = "dev-forget-channel")]
	DevForgetChannel(responses::DevforgetchannelResponse),
	EmergencyRecover(responses::EmergencyrecoverResponse),
	Recover(responses::RecoverResponse),
	RecoverChannel(responses::RecoverchannelResponse),
	Invoice(responses::InvoiceResponse),
	InvoiceRequest(responses::InvoicerequestResponse),
	DisableInvoiceRequest(responses::DisableinvoicerequestResponse),
	ListInvoiceRequests(responses::ListinvoicerequestsResponse),
	ListDatastore(responses::ListdatastoreResponse),
	ListInvoices(responses::ListinvoicesResponse),
	SendOnion(responses::SendonionResponse),
	ListSendPays(responses::ListsendpaysResponse),
	ListTransactions(responses::ListtransactionsResponse),
	MakeSecret(responses::MakesecretResponse),
	Pay(responses::PayResponse),
	ListNodes(responses::ListnodesResponse),
	WaitAnyInvoice(responses::WaitanyinvoiceResponse),
	WaitInvoice(responses::WaitinvoiceResponse),
	WaitSendPay(responses::WaitsendpayResponse),
	NewAddr(responses::NewaddrResponse),
	Withdraw(responses::WithdrawResponse),
	KeySend(responses::KeysendResponse),
	FundPsbt(responses::FundpsbtResponse),
	SendPsbt(responses::SendpsbtResponse),
	SignPsbt(responses::SignpsbtResponse),
	UtxoPsbt(responses::UtxopsbtResponse),
	TxDiscard(responses::TxdiscardResponse),
	TxPrepare(responses::TxprepareResponse),
	TxSend(responses::TxsendResponse),
	ListPeerChannels(responses::ListpeerchannelsResponse),
	ListClosedChannels(responses::ListclosedchannelsResponse),
	DecodePay(responses::DecodepayResponse),
	Decode(responses::DecodeResponse),
	DelPay(responses::DelpayResponse),
	DelForward(responses::DelforwardResponse),
	DisableOffer(responses::DisableofferResponse),
	Disconnect(responses::DisconnectResponse),
	Feerates(responses::FeeratesResponse),
	FetchInvoice(responses::FetchinvoiceResponse),
	FundChannel_Cancel(responses::Fundchannel_cancelResponse),
	FundChannel_Complete(responses::Fundchannel_completeResponse),
	FundChannel(responses::FundchannelResponse),
	FundChannel_Start(responses::Fundchannel_startResponse),
	GetLog(responses::GetlogResponse),
	FunderUpdate(responses::FunderupdateResponse),
	GetRoute(responses::GetrouteResponse),
	ListForwards(responses::ListforwardsResponse),
	ListOffers(responses::ListoffersResponse),
	ListPays(responses::ListpaysResponse),
	ListHtlcs(responses::ListhtlcsResponse),
	MultiFundChannel(responses::MultifundchannelResponse),
	MultiWithdraw(responses::MultiwithdrawResponse),
	Offer(responses::OfferResponse),
	OpenChannel_Abort(responses::Openchannel_abortResponse),
	OpenChannel_Bump(responses::Openchannel_bumpResponse),
	OpenChannel_Init(responses::Openchannel_initResponse),
	OpenChannel_Signed(responses::Openchannel_signedResponse),
	OpenChannel_Update(responses::Openchannel_updateResponse),
	Ping(responses::PingResponse),
	Plugin(responses::PluginResponse),
	RenePayStatus(responses::RenepaystatusResponse),
	RenePay(responses::RenepayResponse),
	ReserveInputs(responses::ReserveinputsResponse),
	SendCustomMsg(responses::SendcustommsgResponse),
	SendInvoice(responses::SendinvoiceResponse),
	SendOnionMessage(responses::SendonionmessageResponse),
	SetChannel(responses::SetchannelResponse),
	SetConfig(responses::SetconfigResponse),
	SetPsbtVersion(responses::SetpsbtversionResponse),
	SignInvoice(responses::SigninvoiceResponse),
	SignMessage(responses::SignmessageResponse),
	Splice_Init(responses::Splice_initResponse),
	Splice_Signed(responses::Splice_signedResponse),
	Splice_Update(responses::Splice_updateResponse),
	UnreserveInputs(responses::UnreserveinputsResponse),
	UpgradeWallet(responses::UpgradewalletResponse),
	WaitBlockHeight(responses::WaitblockheightResponse),
	Wait(responses::WaitResponse),
	ListConfigs(responses::ListconfigsResponse),
	Stop(responses::StopResponse),
	Help(responses::HelpResponse),
	PreApproveKeysend(responses::PreapprovekeysendResponse),
	PreApproveInvoice(responses::PreapproveinvoiceResponse),
	StaticBackup(responses::StaticbackupResponse),
	#[serde(rename = "bkpr-channelsapy")]
	BkprChannelsApy(responses::BkprchannelsapyResponse),
	#[serde(rename = "bkpr-dumpincomecsv")]
	BkprDumpIncomeCsv(responses::BkprdumpincomecsvResponse),
	#[serde(rename = "bkpr-inspect")]
	BkprInspect(responses::BkprinspectResponse),
	#[serde(rename = "bkpr-listaccountevents")]
	BkprListAccountEvents(responses::BkprlistaccounteventsResponse),
	#[serde(rename = "bkpr-listbalances")]
	BkprListBalances(responses::BkprlistbalancesResponse),
	#[serde(rename = "bkpr-listincome")]
	BkprListIncome(responses::BkprlistincomeResponse),
	BlacklistRune(responses::BlacklistruneResponse),
	CheckRune(responses::CheckruneResponse),
	CreateRune(responses::CreateruneResponse),
	ShowRunes(responses::ShowrunesResponse),
}


pub trait IntoRequest: Into<Request> {
    type Response: TryFrom<Response, Error = TryFromResponseError>;
}

pub trait TypedRequest {
    type Response;

    fn method(&self) -> &str;
}

#[derive(Debug)]
pub struct TryFromResponseError;

pub mod requests {
    #[allow(unused_imports)]
    use crate::primitives::*;
    #[allow(unused_imports)]
    use serde::{{Deserialize, Serialize}};
    use core::fmt::Debug;
    use super::{IntoRequest, Request, TypedRequest};
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetinfoRequest {
	}

	impl From<GetinfoRequest> for Request {
	    fn from(r: GetinfoRequest) -> Self {
	        Request::Getinfo(r)
	    }
	}

	impl IntoRequest for GetinfoRequest {
	    type Response = super::responses::GetinfoResponse;
	}

	impl TypedRequest for GetinfoRequest {
	    type Response = super::responses::GetinfoResponse;

	    fn method(&self) -> &str {
	        "getinfo"
	    }
	}
	/// ['Supplying level will show log entries related to that peer at the given log level.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListpeersLevel {
	    #[serde(rename = "io")]
	    IO = 0,
	    #[serde(rename = "debug")]
	    DEBUG = 1,
	    #[serde(rename = "info")]
	    INFO = 2,
	    #[serde(rename = "unusual")]
	    UNUSUAL = 3,
	    #[serde(rename = "trace")]
	    TRACE = 4,
	}

	impl TryFrom<i32> for ListpeersLevel {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListpeersLevel, anyhow::Error> {
	        match c {
	    0 => Ok(ListpeersLevel::IO),
	    1 => Ok(ListpeersLevel::DEBUG),
	    2 => Ok(ListpeersLevel::INFO),
	    3 => Ok(ListpeersLevel::UNUSUAL),
	    4 => Ok(ListpeersLevel::TRACE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListpeersLevel", o)),
	        }
	    }
	}

	impl ToString for ListpeersLevel {
	    fn to_string(&self) -> String {
	        match self {
	            ListpeersLevel::IO => "IO",
	            ListpeersLevel::TRACE => "TRACE",
	            ListpeersLevel::DEBUG => "DEBUG",
	            ListpeersLevel::INFO => "INFO",
	            ListpeersLevel::UNUSUAL => "UNUSUAL",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeersRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub id: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub level: Option<ListpeersLevel>,
	}

	impl From<ListpeersRequest> for Request {
	    fn from(r: ListpeersRequest) -> Self {
	        Request::ListPeers(r)
	    }
	}

	impl IntoRequest for ListpeersRequest {
	    type Response = super::responses::ListpeersResponse;
	}

	impl TypedRequest for ListpeersRequest {
	    type Response = super::responses::ListpeersResponse;

	    fn method(&self) -> &str {
	        "listpeers"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListfundsRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub spent: Option<bool>,
	}

	impl From<ListfundsRequest> for Request {
	    fn from(r: ListfundsRequest) -> Self {
	        Request::ListFunds(r)
	    }
	}

	impl IntoRequest for ListfundsRequest {
	    type Response = super::responses::ListfundsResponse;
	}

	impl TypedRequest for ListfundsRequest {
	    type Response = super::responses::ListfundsResponse;

	    fn method(&self) -> &str {
	        "listfunds"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendpayRoute {
	    pub amount_msat: Amount,
	    pub channel: ShortChannelId,
	    pub delay: u32,
	    pub id: PublicKey,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendpayRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub groupid: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub localinvreqid: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_metadata: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_secret: Option<Secret>,
	    pub payment_hash: Sha256,
	    pub route: Vec<SendpayRoute>,
	}

	impl From<SendpayRequest> for Request {
	    fn from(r: SendpayRequest) -> Self {
	        Request::SendPay(r)
	    }
	}

	impl IntoRequest for SendpayRequest {
	    type Response = super::responses::SendpayResponse;
	}

	impl TypedRequest for SendpayRequest {
	    type Response = super::responses::SendpayResponse;

	    fn method(&self) -> &str {
	        "sendpay"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListchannelsRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub short_channel_id: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub source: Option<PublicKey>,
	}

	impl From<ListchannelsRequest> for Request {
	    fn from(r: ListchannelsRequest) -> Self {
	        Request::ListChannels(r)
	    }
	}

	impl IntoRequest for ListchannelsRequest {
	    type Response = super::responses::ListchannelsResponse;
	}

	impl TypedRequest for ListchannelsRequest {
	    type Response = super::responses::ListchannelsResponse;

	    fn method(&self) -> &str {
	        "listchannels"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AddgossipRequest {
	    pub message: String,
	}

	impl From<AddgossipRequest> for Request {
	    fn from(r: AddgossipRequest) -> Self {
	        Request::AddGossip(r)
	    }
	}

	impl IntoRequest for AddgossipRequest {
	    type Response = super::responses::AddgossipResponse;
	}

	impl TypedRequest for AddgossipRequest {
	    type Response = super::responses::AddgossipResponse;

	    fn method(&self) -> &str {
	        "addgossip"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AddpsbtoutputRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub initialpsbt: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub locktime: Option<u32>,
	    pub satoshi: Amount,
	}

	impl From<AddpsbtoutputRequest> for Request {
	    fn from(r: AddpsbtoutputRequest) -> Self {
	        Request::AddPsbtOutput(r)
	    }
	}

	impl IntoRequest for AddpsbtoutputRequest {
	    type Response = super::responses::AddpsbtoutputResponse;
	}

	impl TypedRequest for AddpsbtoutputRequest {
	    type Response = super::responses::AddpsbtoutputResponse;

	    fn method(&self) -> &str {
	        "addpsbtoutput"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AutocleaninvoiceRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub cycle_seconds: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub expired_by: Option<u64>,
	}

	impl From<AutocleaninvoiceRequest> for Request {
	    fn from(r: AutocleaninvoiceRequest) -> Self {
	        Request::AutoCleanInvoice(r)
	    }
	}

	impl IntoRequest for AutocleaninvoiceRequest {
	    type Response = super::responses::AutocleaninvoiceResponse;
	}

	impl TypedRequest for AutocleaninvoiceRequest {
	    type Response = super::responses::AutocleaninvoiceResponse;

	    fn method(&self) -> &str {
	        "autocleaninvoice"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AutocleanonceRequest {
	    // Path `AutoClean-Once.subsystem`
	    pub subsystem: AutocleanSubsystem,
	    pub age: u64,
	}

	impl From<AutocleanonceRequest> for Request {
	    fn from(r: AutocleanonceRequest) -> Self {
	        Request::AutoCleanOnce(r)
	    }
	}

	impl IntoRequest for AutocleanonceRequest {
	    type Response = super::responses::AutocleanonceResponse;
	}

	impl TypedRequest for AutocleanonceRequest {
	    type Response = super::responses::AutocleanonceResponse;

	    fn method(&self) -> &str {
	        "autoclean-once"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AutocleanstatusRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub subsystem: Option<AutocleanSubsystem>,
	}

	impl From<AutocleanstatusRequest> for Request {
	    fn from(r: AutocleanstatusRequest) -> Self {
	        Request::AutoCleanStatus(r)
	    }
	}

	impl IntoRequest for AutocleanstatusRequest {
	    type Response = super::responses::AutocleanstatusResponse;
	}

	impl TypedRequest for AutocleanstatusRequest {
	    type Response = super::responses::AutocleanstatusResponse;

	    fn method(&self) -> &str {
	        "autoclean-status"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CheckmessageRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub pubkey: Option<PublicKey>,
	    pub message: String,
	    pub zbase: String,
	}

	impl From<CheckmessageRequest> for Request {
	    fn from(r: CheckmessageRequest) -> Self {
	        Request::CheckMessage(r)
	    }
	}

	impl IntoRequest for CheckmessageRequest {
	    type Response = super::responses::CheckmessageResponse;
	}

	impl TypedRequest for CheckmessageRequest {
	    type Response = super::responses::CheckmessageResponse;

	    fn method(&self) -> &str {
	        "checkmessage"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CloseRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_negotiation_step: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub force_lease_closed: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub unilateraltimeout: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub wrong_funding: Option<Outpoint>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub feerange: Option<Vec<Feerate>>,
	    pub id: String,
	}

	impl From<CloseRequest> for Request {
	    fn from(r: CloseRequest) -> Self {
	        Request::Close(r)
	    }
	}

	impl IntoRequest for CloseRequest {
	    type Response = super::responses::CloseResponse;
	}

	impl TypedRequest for CloseRequest {
	    type Response = super::responses::CloseResponse;

	    fn method(&self) -> &str {
	        "close"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ConnectRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub host: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub port: Option<u16>,
	    pub id: String,
	}

	impl From<ConnectRequest> for Request {
	    fn from(r: ConnectRequest) -> Self {
	        Request::Connect(r)
	    }
	}

	impl IntoRequest for ConnectRequest {
	    type Response = super::responses::ConnectResponse;
	}

	impl TypedRequest for ConnectRequest {
	    type Response = super::responses::ConnectResponse;

	    fn method(&self) -> &str {
	        "connect"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CreateinvoiceRequest {
	    pub invstring: String,
	    pub label: String,
	    pub preimage: String,
	}

	impl From<CreateinvoiceRequest> for Request {
	    fn from(r: CreateinvoiceRequest) -> Self {
	        Request::CreateInvoice(r)
	    }
	}

	impl IntoRequest for CreateinvoiceRequest {
	    type Response = super::responses::CreateinvoiceResponse;
	}

	impl TypedRequest for CreateinvoiceRequest {
	    type Response = super::responses::CreateinvoiceResponse;

	    fn method(&self) -> &str {
	        "createinvoice"
	    }
	}
	/// ['Write mode to determine how the record is updated:', '    * `must-create`: fails if it already exists.', "    * `must-replace`: fails if it doesn't already exist.", '    * `create-or-replace`: never fails.', "    * `must-append`: must already exist, append this to what's already there.", '    * `create-or-append`: append if anything is there, otherwise create.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum DatastoreMode {
	    #[serde(rename = "must-create")]
	    MUST_CREATE = 0,
	    #[serde(rename = "must-replace")]
	    MUST_REPLACE = 1,
	    #[serde(rename = "create-or-replace")]
	    CREATE_OR_REPLACE = 2,
	    #[serde(rename = "must-append")]
	    MUST_APPEND = 3,
	    #[serde(rename = "create-or-append")]
	    CREATE_OR_APPEND = 4,
	}

	impl TryFrom<i32> for DatastoreMode {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<DatastoreMode, anyhow::Error> {
	        match c {
	    0 => Ok(DatastoreMode::MUST_CREATE),
	    1 => Ok(DatastoreMode::MUST_REPLACE),
	    2 => Ok(DatastoreMode::CREATE_OR_REPLACE),
	    3 => Ok(DatastoreMode::MUST_APPEND),
	    4 => Ok(DatastoreMode::CREATE_OR_APPEND),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum DatastoreMode", o)),
	        }
	    }
	}

	impl ToString for DatastoreMode {
	    fn to_string(&self) -> String {
	        match self {
	            DatastoreMode::MUST_CREATE => "MUST_CREATE",
	            DatastoreMode::MUST_REPLACE => "MUST_REPLACE",
	            DatastoreMode::CREATE_OR_REPLACE => "CREATE_OR_REPLACE",
	            DatastoreMode::MUST_APPEND => "MUST_APPEND",
	            DatastoreMode::CREATE_OR_APPEND => "CREATE_OR_APPEND",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DatastoreRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub generation: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub hex: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub mode: Option<DatastoreMode>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub string: Option<String>,
	    pub key: Vec<String>,
	}

	impl From<DatastoreRequest> for Request {
	    fn from(r: DatastoreRequest) -> Self {
	        Request::Datastore(r)
	    }
	}

	impl IntoRequest for DatastoreRequest {
	    type Response = super::responses::DatastoreResponse;
	}

	impl TypedRequest for DatastoreRequest {
	    type Response = super::responses::DatastoreResponse;

	    fn method(&self) -> &str {
	        "datastore"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DatastoreusageRequest {
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub key: Option<Vec<String>>,
	}

	impl From<DatastoreusageRequest> for Request {
	    fn from(r: DatastoreusageRequest) -> Self {
	        Request::DatastoreUsage(r)
	    }
	}

	impl IntoRequest for DatastoreusageRequest {
	    type Response = super::responses::DatastoreusageResponse;
	}

	impl TypedRequest for DatastoreusageRequest {
	    type Response = super::responses::DatastoreusageResponse;

	    fn method(&self) -> &str {
	        "datastoreusage"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CreateonionHops {
	    pub payload: String,
	    pub pubkey: PublicKey,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CreateonionRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub onion_size: Option<u16>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub session_key: Option<Secret>,
	    pub assocdata: String,
	    pub hops: Vec<CreateonionHops>,
	}

	impl From<CreateonionRequest> for Request {
	    fn from(r: CreateonionRequest) -> Self {
	        Request::CreateOnion(r)
	    }
	}

	impl IntoRequest for CreateonionRequest {
	    type Response = super::responses::CreateonionResponse;
	}

	impl TypedRequest for CreateonionRequest {
	    type Response = super::responses::CreateonionResponse;

	    fn method(&self) -> &str {
	        "createonion"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DeldatastoreRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub generation: Option<u64>,
	    pub key: Vec<String>,
	}

	impl From<DeldatastoreRequest> for Request {
	    fn from(r: DeldatastoreRequest) -> Self {
	        Request::DelDatastore(r)
	    }
	}

	impl IntoRequest for DeldatastoreRequest {
	    type Response = super::responses::DeldatastoreResponse;
	}

	impl TypedRequest for DeldatastoreRequest {
	    type Response = super::responses::DeldatastoreResponse;

	    fn method(&self) -> &str {
	        "deldatastore"
	    }
	}
	/// ['Label of the invoice to be deleted. The caller should be particularly aware of the error case caused by the *status* changing just before this command is invoked!']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum DelinvoiceStatus {
	    #[serde(rename = "paid")]
	    PAID = 0,
	    #[serde(rename = "expired")]
	    EXPIRED = 1,
	    #[serde(rename = "unpaid")]
	    UNPAID = 2,
	}

	impl TryFrom<i32> for DelinvoiceStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<DelinvoiceStatus, anyhow::Error> {
	        match c {
	    0 => Ok(DelinvoiceStatus::PAID),
	    1 => Ok(DelinvoiceStatus::EXPIRED),
	    2 => Ok(DelinvoiceStatus::UNPAID),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum DelinvoiceStatus", o)),
	        }
	    }
	}

	impl ToString for DelinvoiceStatus {
	    fn to_string(&self) -> String {
	        match self {
	            DelinvoiceStatus::PAID => "PAID",
	            DelinvoiceStatus::EXPIRED => "EXPIRED",
	            DelinvoiceStatus::UNPAID => "UNPAID",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DelinvoiceRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub desconly: Option<bool>,
	    // Path `DelInvoice.status`
	    pub status: DelinvoiceStatus,
	    pub label: String,
	}

	impl From<DelinvoiceRequest> for Request {
	    fn from(r: DelinvoiceRequest) -> Self {
	        Request::DelInvoice(r)
	    }
	}

	impl IntoRequest for DelinvoiceRequest {
	    type Response = super::responses::DelinvoiceResponse;
	}

	impl TypedRequest for DelinvoiceRequest {
	    type Response = super::responses::DelinvoiceResponse;

	    fn method(&self) -> &str {
	        "delinvoice"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DevforgetchannelRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub channel_id: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub force: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub short_channel_id: Option<ShortChannelId>,
	    pub id: PublicKey,
	}

	impl From<DevforgetchannelRequest> for Request {
	    fn from(r: DevforgetchannelRequest) -> Self {
	        Request::DevForgetChannel(r)
	    }
	}

	impl IntoRequest for DevforgetchannelRequest {
	    type Response = super::responses::DevforgetchannelResponse;
	}

	impl TypedRequest for DevforgetchannelRequest {
	    type Response = super::responses::DevforgetchannelResponse;

	    fn method(&self) -> &str {
	        "dev-forget-channel"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct EmergencyrecoverRequest {
	}

	impl From<EmergencyrecoverRequest> for Request {
	    fn from(r: EmergencyrecoverRequest) -> Self {
	        Request::EmergencyRecover(r)
	    }
	}

	impl IntoRequest for EmergencyrecoverRequest {
	    type Response = super::responses::EmergencyrecoverResponse;
	}

	impl TypedRequest for EmergencyrecoverRequest {
	    type Response = super::responses::EmergencyrecoverResponse;

	    fn method(&self) -> &str {
	        "emergencyrecover"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct RecoverRequest {
	    pub hsmsecret: String,
	}

	impl From<RecoverRequest> for Request {
	    fn from(r: RecoverRequest) -> Self {
	        Request::Recover(r)
	    }
	}

	impl IntoRequest for RecoverRequest {
	    type Response = super::responses::RecoverResponse;
	}

	impl TypedRequest for RecoverRequest {
	    type Response = super::responses::RecoverResponse;

	    fn method(&self) -> &str {
	        "recover"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct RecoverchannelRequest {
	    pub scb: Vec<String>,
	}

	impl From<RecoverchannelRequest> for Request {
	    fn from(r: RecoverchannelRequest) -> Self {
	        Request::RecoverChannel(r)
	    }
	}

	impl IntoRequest for RecoverchannelRequest {
	    type Response = super::responses::RecoverchannelResponse;
	}

	impl TypedRequest for RecoverchannelRequest {
	    type Response = super::responses::RecoverchannelResponse;

	    fn method(&self) -> &str {
	        "recoverchannel"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct InvoiceRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub cltv: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub deschashonly: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub expiry: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub preimage: Option<String>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub exposeprivatechannels: Option<Vec<ShortChannelId>>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub fallbacks: Option<Vec<String>>,
	    pub amount_msat: AmountOrAny,
	    pub description: String,
	    pub label: String,
	}

	impl From<InvoiceRequest> for Request {
	    fn from(r: InvoiceRequest) -> Self {
	        Request::Invoice(r)
	    }
	}

	impl IntoRequest for InvoiceRequest {
	    type Response = super::responses::InvoiceResponse;
	}

	impl TypedRequest for InvoiceRequest {
	    type Response = super::responses::InvoiceResponse;

	    fn method(&self) -> &str {
	        "invoice"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct InvoicerequestRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub absolute_expiry: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub issuer: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub single_use: Option<bool>,
	    pub amount: Amount,
	    pub description: String,
	}

	impl From<InvoicerequestRequest> for Request {
	    fn from(r: InvoicerequestRequest) -> Self {
	        Request::InvoiceRequest(r)
	    }
	}

	impl IntoRequest for InvoicerequestRequest {
	    type Response = super::responses::InvoicerequestResponse;
	}

	impl TypedRequest for InvoicerequestRequest {
	    type Response = super::responses::InvoicerequestResponse;

	    fn method(&self) -> &str {
	        "invoicerequest"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DisableinvoicerequestRequest {
	    pub invreq_id: String,
	}

	impl From<DisableinvoicerequestRequest> for Request {
	    fn from(r: DisableinvoicerequestRequest) -> Self {
	        Request::DisableInvoiceRequest(r)
	    }
	}

	impl IntoRequest for DisableinvoicerequestRequest {
	    type Response = super::responses::DisableinvoicerequestResponse;
	}

	impl TypedRequest for DisableinvoicerequestRequest {
	    type Response = super::responses::DisableinvoicerequestResponse;

	    fn method(&self) -> &str {
	        "disableinvoicerequest"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListinvoicerequestsRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub active_only: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_id: Option<String>,
	}

	impl From<ListinvoicerequestsRequest> for Request {
	    fn from(r: ListinvoicerequestsRequest) -> Self {
	        Request::ListInvoiceRequests(r)
	    }
	}

	impl IntoRequest for ListinvoicerequestsRequest {
	    type Response = super::responses::ListinvoicerequestsResponse;
	}

	impl TypedRequest for ListinvoicerequestsRequest {
	    type Response = super::responses::ListinvoicerequestsResponse;

	    fn method(&self) -> &str {
	        "listinvoicerequests"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListdatastoreRequest {
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub key: Option<Vec<String>>,
	}

	impl From<ListdatastoreRequest> for Request {
	    fn from(r: ListdatastoreRequest) -> Self {
	        Request::ListDatastore(r)
	    }
	}

	impl IntoRequest for ListdatastoreRequest {
	    type Response = super::responses::ListdatastoreResponse;
	}

	impl TypedRequest for ListdatastoreRequest {
	    type Response = super::responses::ListdatastoreResponse;

	    fn method(&self) -> &str {
	        "listdatastore"
	    }
	}
	/// ['If neither *in_channel* nor *out_channel* is specified, it controls ordering.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListinvoicesIndex {
	    #[serde(rename = "created")]
	    CREATED = 0,
	    #[serde(rename = "updated")]
	    UPDATED = 1,
	}

	impl TryFrom<i32> for ListinvoicesIndex {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListinvoicesIndex, anyhow::Error> {
	        match c {
	    0 => Ok(ListinvoicesIndex::CREATED),
	    1 => Ok(ListinvoicesIndex::UPDATED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListinvoicesIndex", o)),
	        }
	    }
	}

	impl ToString for ListinvoicesIndex {
	    fn to_string(&self) -> String {
	        match self {
	            ListinvoicesIndex::CREATED => "CREATED",
	            ListinvoicesIndex::UPDATED => "UPDATED",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListinvoicesRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub index: Option<ListinvoicesIndex>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invstring: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub limit: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_id: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_hash: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub start: Option<u64>,
	}

	impl From<ListinvoicesRequest> for Request {
	    fn from(r: ListinvoicesRequest) -> Self {
	        Request::ListInvoices(r)
	    }
	}

	impl IntoRequest for ListinvoicesRequest {
	    type Response = super::responses::ListinvoicesResponse;
	}

	impl TypedRequest for ListinvoicesRequest {
	    type Response = super::responses::ListinvoicesResponse;

	    fn method(&self) -> &str {
	        "listinvoices"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendonionFirst_hop {
	    pub amount_msat: Amount,
	    pub delay: u16,
	    pub id: PublicKey,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendonionRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub groupid: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub localinvreqid: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u16>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub shared_secrets: Option<Vec<Secret>>,
	    pub first_hop: SendonionFirst_hop,
	    pub onion: String,
	    pub payment_hash: Sha256,
	}

	impl From<SendonionRequest> for Request {
	    fn from(r: SendonionRequest) -> Self {
	        Request::SendOnion(r)
	    }
	}

	impl IntoRequest for SendonionRequest {
	    type Response = super::responses::SendonionResponse;
	}

	impl TypedRequest for SendonionRequest {
	    type Response = super::responses::SendonionResponse;

	    fn method(&self) -> &str {
	        "sendonion"
	    }
	}
	/// ['If neither bolt11 or payment_hash is specified, `index` controls ordering, by `created` (default) or `updated`.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListsendpaysIndex {
	    #[serde(rename = "created")]
	    CREATED = 0,
	    #[serde(rename = "updated")]
	    UPDATED = 1,
	}

	impl TryFrom<i32> for ListsendpaysIndex {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListsendpaysIndex, anyhow::Error> {
	        match c {
	    0 => Ok(ListsendpaysIndex::CREATED),
	    1 => Ok(ListsendpaysIndex::UPDATED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListsendpaysIndex", o)),
	        }
	    }
	}

	impl ToString for ListsendpaysIndex {
	    fn to_string(&self) -> String {
	        match self {
	            ListsendpaysIndex::CREATED => "CREATED",
	            ListsendpaysIndex::UPDATED => "UPDATED",
	        }.to_string()
	    }
	}

	/// ['Whether the invoice has been paid, pending, or failed.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListsendpaysStatus {
	    #[serde(rename = "pending")]
	    PENDING = 0,
	    #[serde(rename = "complete")]
	    COMPLETE = 1,
	    #[serde(rename = "failed")]
	    FAILED = 2,
	}

	impl TryFrom<i32> for ListsendpaysStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListsendpaysStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListsendpaysStatus::PENDING),
	    1 => Ok(ListsendpaysStatus::COMPLETE),
	    2 => Ok(ListsendpaysStatus::FAILED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListsendpaysStatus", o)),
	        }
	    }
	}

	impl ToString for ListsendpaysStatus {
	    fn to_string(&self) -> String {
	        match self {
	            ListsendpaysStatus::PENDING => "PENDING",
	            ListsendpaysStatus::COMPLETE => "COMPLETE",
	            ListsendpaysStatus::FAILED => "FAILED",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListsendpaysRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub index: Option<ListsendpaysIndex>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub limit: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_hash: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub start: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub status: Option<ListsendpaysStatus>,
	}

	impl From<ListsendpaysRequest> for Request {
	    fn from(r: ListsendpaysRequest) -> Self {
	        Request::ListSendPays(r)
	    }
	}

	impl IntoRequest for ListsendpaysRequest {
	    type Response = super::responses::ListsendpaysResponse;
	}

	impl TypedRequest for ListsendpaysRequest {
	    type Response = super::responses::ListsendpaysResponse;

	    fn method(&self) -> &str {
	        "listsendpays"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListtransactionsRequest {
	}

	impl From<ListtransactionsRequest> for Request {
	    fn from(r: ListtransactionsRequest) -> Self {
	        Request::ListTransactions(r)
	    }
	}

	impl IntoRequest for ListtransactionsRequest {
	    type Response = super::responses::ListtransactionsResponse;
	}

	impl TypedRequest for ListtransactionsRequest {
	    type Response = super::responses::ListtransactionsResponse;

	    fn method(&self) -> &str {
	        "listtransactions"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct MakesecretRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub hex: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub string: Option<String>,
	}

	impl From<MakesecretRequest> for Request {
	    fn from(r: MakesecretRequest) -> Self {
	        Request::MakeSecret(r)
	    }
	}

	impl IntoRequest for MakesecretRequest {
	    type Response = super::responses::MakesecretResponse;
	}

	impl TypedRequest for MakesecretRequest {
	    type Response = super::responses::MakesecretResponse;

	    fn method(&self) -> &str {
	        "makesecret"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct PayRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub exemptfee: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub localinvreqid: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub maxdelay: Option<u16>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub maxfee: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub maxfeepercent: Option<f64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub partial_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub retry_for: Option<u16>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub riskfactor: Option<f64>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub exclude: Option<Vec<String>>,
	    pub bolt11: String,
	}

	impl From<PayRequest> for Request {
	    fn from(r: PayRequest) -> Self {
	        Request::Pay(r)
	    }
	}

	impl IntoRequest for PayRequest {
	    type Response = super::responses::PayResponse;
	}

	impl TypedRequest for PayRequest {
	    type Response = super::responses::PayResponse;

	    fn method(&self) -> &str {
	        "pay"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListnodesRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub id: Option<PublicKey>,
	}

	impl From<ListnodesRequest> for Request {
	    fn from(r: ListnodesRequest) -> Self {
	        Request::ListNodes(r)
	    }
	}

	impl IntoRequest for ListnodesRequest {
	    type Response = super::responses::ListnodesResponse;
	}

	impl TypedRequest for ListnodesRequest {
	    type Response = super::responses::ListnodesResponse;

	    fn method(&self) -> &str {
	        "listnodes"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitanyinvoiceRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub lastpay_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub timeout: Option<u64>,
	}

	impl From<WaitanyinvoiceRequest> for Request {
	    fn from(r: WaitanyinvoiceRequest) -> Self {
	        Request::WaitAnyInvoice(r)
	    }
	}

	impl IntoRequest for WaitanyinvoiceRequest {
	    type Response = super::responses::WaitanyinvoiceResponse;
	}

	impl TypedRequest for WaitanyinvoiceRequest {
	    type Response = super::responses::WaitanyinvoiceResponse;

	    fn method(&self) -> &str {
	        "waitanyinvoice"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitinvoiceRequest {
	    pub label: String,
	}

	impl From<WaitinvoiceRequest> for Request {
	    fn from(r: WaitinvoiceRequest) -> Self {
	        Request::WaitInvoice(r)
	    }
	}

	impl IntoRequest for WaitinvoiceRequest {
	    type Response = super::responses::WaitinvoiceResponse;
	}

	impl TypedRequest for WaitinvoiceRequest {
	    type Response = super::responses::WaitinvoiceResponse;

	    fn method(&self) -> &str {
	        "waitinvoice"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitsendpayRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub groupid: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub timeout: Option<u32>,
	    pub payment_hash: Sha256,
	}

	impl From<WaitsendpayRequest> for Request {
	    fn from(r: WaitsendpayRequest) -> Self {
	        Request::WaitSendPay(r)
	    }
	}

	impl IntoRequest for WaitsendpayRequest {
	    type Response = super::responses::WaitsendpayResponse;
	}

	impl TypedRequest for WaitsendpayRequest {
	    type Response = super::responses::WaitsendpayResponse;

	    fn method(&self) -> &str {
	        "waitsendpay"
	    }
	}
	/// ['It specifies the type of address wanted; currently *bech32* (e.g. `tb1qu9j4lg5f9rgjyfhvfd905vw46eg39czmktxqgg` on bitcoin testnet or `bc1qwqdg6squsna38e46795at95yu9atm8azzmyvckulcc7kytlcckxswvvzej` on bitcoin mainnet), or *p2tr* taproot addresses. The special value *all* generates all known address types for the same underlying key.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum NewaddrAddresstype {
	    #[serde(rename = "bech32")]
	    BECH32 = 0,
	    #[serde(rename = "all")]
	    ALL = 2,
	    #[serde(rename = "p2tr")]
	    P2TR = 3,
	}

	impl TryFrom<i32> for NewaddrAddresstype {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<NewaddrAddresstype, anyhow::Error> {
	        match c {
	    0 => Ok(NewaddrAddresstype::BECH32),
	    2 => Ok(NewaddrAddresstype::ALL),
	    3 => Ok(NewaddrAddresstype::P2TR),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum NewaddrAddresstype", o)),
	        }
	    }
	}

	impl ToString for NewaddrAddresstype {
	    fn to_string(&self) -> String {
	        match self {
	            NewaddrAddresstype::BECH32 => "BECH32",
	            NewaddrAddresstype::P2TR => "P2TR",
	            NewaddrAddresstype::ALL => "ALL",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct NewaddrRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub addresstype: Option<NewaddrAddresstype>,
	}

	impl From<NewaddrRequest> for Request {
	    fn from(r: NewaddrRequest) -> Self {
	        Request::NewAddr(r)
	    }
	}

	impl IntoRequest for NewaddrRequest {
	    type Response = super::responses::NewaddrResponse;
	}

	impl TypedRequest for NewaddrRequest {
	    type Response = super::responses::NewaddrResponse;

	    fn method(&self) -> &str {
	        "newaddr"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WithdrawRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feerate: Option<Feerate>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub minconf: Option<u16>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub utxos: Option<Vec<Outpoint>>,
	    pub destination: String,
	    pub satoshi: AmountOrAll,
	}

	impl From<WithdrawRequest> for Request {
	    fn from(r: WithdrawRequest) -> Self {
	        Request::Withdraw(r)
	    }
	}

	impl IntoRequest for WithdrawRequest {
	    type Response = super::responses::WithdrawResponse;
	}

	impl TypedRequest for WithdrawRequest {
	    type Response = super::responses::WithdrawResponse;

	    fn method(&self) -> &str {
	        "withdraw"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct KeysendRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub exemptfee: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub extratlvs: Option<TlvStream>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub maxdelay: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub maxfeepercent: Option<f64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub retry_for: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub routehints: Option<RoutehintList>,
	    pub amount_msat: Amount,
	    pub destination: PublicKey,
	}

	impl From<KeysendRequest> for Request {
	    fn from(r: KeysendRequest) -> Self {
	        Request::KeySend(r)
	    }
	}

	impl IntoRequest for KeysendRequest {
	    type Response = super::responses::KeysendResponse;
	}

	impl TypedRequest for KeysendRequest {
	    type Response = super::responses::KeysendResponse;

	    fn method(&self) -> &str {
	        "keysend"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FundpsbtRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub excess_as_change: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub locktime: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub min_witness_weight: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub minconf: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub nonwrapped: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub opening_anchor_channel: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub reserve: Option<u32>,
	    pub feerate: Feerate,
	    pub satoshi: AmountOrAll,
	    pub startweight: u32,
	}

	impl From<FundpsbtRequest> for Request {
	    fn from(r: FundpsbtRequest) -> Self {
	        Request::FundPsbt(r)
	    }
	}

	impl IntoRequest for FundpsbtRequest {
	    type Response = super::responses::FundpsbtResponse;
	}

	impl TypedRequest for FundpsbtRequest {
	    type Response = super::responses::FundpsbtResponse;

	    fn method(&self) -> &str {
	        "fundpsbt"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendpsbtRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub reserve: Option<u32>,
	    pub psbt: String,
	}

	impl From<SendpsbtRequest> for Request {
	    fn from(r: SendpsbtRequest) -> Self {
	        Request::SendPsbt(r)
	    }
	}

	impl IntoRequest for SendpsbtRequest {
	    type Response = super::responses::SendpsbtResponse;
	}

	impl TypedRequest for SendpsbtRequest {
	    type Response = super::responses::SendpsbtResponse;

	    fn method(&self) -> &str {
	        "sendpsbt"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SignpsbtRequest {
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub signonly: Option<Vec<u32>>,
	    pub psbt: String,
	}

	impl From<SignpsbtRequest> for Request {
	    fn from(r: SignpsbtRequest) -> Self {
	        Request::SignPsbt(r)
	    }
	}

	impl IntoRequest for SignpsbtRequest {
	    type Response = super::responses::SignpsbtResponse;
	}

	impl TypedRequest for SignpsbtRequest {
	    type Response = super::responses::SignpsbtResponse;

	    fn method(&self) -> &str {
	        "signpsbt"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct UtxopsbtRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub excess_as_change: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub locktime: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub min_witness_weight: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub opening_anchor_channel: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub reserve: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub reservedok: Option<bool>,
	    pub feerate: Feerate,
	    pub satoshi: AmountOrAll,
	    pub startweight: u32,
	    pub utxos: Vec<Outpoint>,
	}

	impl From<UtxopsbtRequest> for Request {
	    fn from(r: UtxopsbtRequest) -> Self {
	        Request::UtxoPsbt(r)
	    }
	}

	impl IntoRequest for UtxopsbtRequest {
	    type Response = super::responses::UtxopsbtResponse;
	}

	impl TypedRequest for UtxopsbtRequest {
	    type Response = super::responses::UtxopsbtResponse;

	    fn method(&self) -> &str {
	        "utxopsbt"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct TxdiscardRequest {
	    pub txid: String,
	}

	impl From<TxdiscardRequest> for Request {
	    fn from(r: TxdiscardRequest) -> Self {
	        Request::TxDiscard(r)
	    }
	}

	impl IntoRequest for TxdiscardRequest {
	    type Response = super::responses::TxdiscardResponse;
	}

	impl TypedRequest for TxdiscardRequest {
	    type Response = super::responses::TxdiscardResponse;

	    fn method(&self) -> &str {
	        "txdiscard"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct TxprepareRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feerate: Option<Feerate>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub minconf: Option<u32>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub utxos: Option<Vec<Outpoint>>,
	    pub outputs: Vec<OutputDesc>,
	}

	impl From<TxprepareRequest> for Request {
	    fn from(r: TxprepareRequest) -> Self {
	        Request::TxPrepare(r)
	    }
	}

	impl IntoRequest for TxprepareRequest {
	    type Response = super::responses::TxprepareResponse;
	}

	impl TypedRequest for TxprepareRequest {
	    type Response = super::responses::TxprepareResponse;

	    fn method(&self) -> &str {
	        "txprepare"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct TxsendRequest {
	    pub txid: String,
	}

	impl From<TxsendRequest> for Request {
	    fn from(r: TxsendRequest) -> Self {
	        Request::TxSend(r)
	    }
	}

	impl IntoRequest for TxsendRequest {
	    type Response = super::responses::TxsendResponse;
	}

	impl TypedRequest for TxsendRequest {
	    type Response = super::responses::TxsendResponse;

	    fn method(&self) -> &str {
	        "txsend"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeerchannelsRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub id: Option<PublicKey>,
	}

	impl From<ListpeerchannelsRequest> for Request {
	    fn from(r: ListpeerchannelsRequest) -> Self {
	        Request::ListPeerChannels(r)
	    }
	}

	impl IntoRequest for ListpeerchannelsRequest {
	    type Response = super::responses::ListpeerchannelsResponse;
	}

	impl TypedRequest for ListpeerchannelsRequest {
	    type Response = super::responses::ListpeerchannelsResponse;

	    fn method(&self) -> &str {
	        "listpeerchannels"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListclosedchannelsRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub id: Option<PublicKey>,
	}

	impl From<ListclosedchannelsRequest> for Request {
	    fn from(r: ListclosedchannelsRequest) -> Self {
	        Request::ListClosedChannels(r)
	    }
	}

	impl IntoRequest for ListclosedchannelsRequest {
	    type Response = super::responses::ListclosedchannelsResponse;
	}

	impl TypedRequest for ListclosedchannelsRequest {
	    type Response = super::responses::ListclosedchannelsResponse;

	    fn method(&self) -> &str {
	        "listclosedchannels"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodepayRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    pub bolt11: String,
	}

	impl From<DecodepayRequest> for Request {
	    fn from(r: DecodepayRequest) -> Self {
	        Request::DecodePay(r)
	    }
	}

	impl IntoRequest for DecodepayRequest {
	    type Response = super::responses::DecodepayResponse;
	}

	impl TypedRequest for DecodepayRequest {
	    type Response = super::responses::DecodepayResponse;

	    fn method(&self) -> &str {
	        "decodepay"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeRequest {
	    pub string: String,
	}

	impl From<DecodeRequest> for Request {
	    fn from(r: DecodeRequest) -> Self {
	        Request::Decode(r)
	    }
	}

	impl IntoRequest for DecodeRequest {
	    type Response = super::responses::DecodeResponse;
	}

	impl TypedRequest for DecodeRequest {
	    type Response = super::responses::DecodeResponse;

	    fn method(&self) -> &str {
	        "decode"
	    }
	}
	/// ['Expected status of the payment. Only deletes if the payment status matches. Deleting a `pending` payment will return an error.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum DelpayStatus {
	    #[serde(rename = "complete")]
	    COMPLETE = 0,
	    #[serde(rename = "failed")]
	    FAILED = 1,
	}

	impl TryFrom<i32> for DelpayStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<DelpayStatus, anyhow::Error> {
	        match c {
	    0 => Ok(DelpayStatus::COMPLETE),
	    1 => Ok(DelpayStatus::FAILED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum DelpayStatus", o)),
	        }
	    }
	}

	impl ToString for DelpayStatus {
	    fn to_string(&self) -> String {
	        match self {
	            DelpayStatus::COMPLETE => "COMPLETE",
	            DelpayStatus::FAILED => "FAILED",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DelpayRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub groupid: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u64>,
	    // Path `DelPay.status`
	    pub status: DelpayStatus,
	    pub payment_hash: Sha256,
	}

	impl From<DelpayRequest> for Request {
	    fn from(r: DelpayRequest) -> Self {
	        Request::DelPay(r)
	    }
	}

	impl IntoRequest for DelpayRequest {
	    type Response = super::responses::DelpayResponse;
	}

	impl TypedRequest for DelpayRequest {
	    type Response = super::responses::DelpayResponse;

	    fn method(&self) -> &str {
	        "delpay"
	    }
	}
	/// ['The status of the forward to delete. You cannot delete forwards which have status *offered* (i.e. are currently active).']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum DelforwardStatus {
	    #[serde(rename = "settled")]
	    SETTLED = 0,
	    #[serde(rename = "local_failed")]
	    LOCAL_FAILED = 1,
	    #[serde(rename = "failed")]
	    FAILED = 2,
	}

	impl TryFrom<i32> for DelforwardStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<DelforwardStatus, anyhow::Error> {
	        match c {
	    0 => Ok(DelforwardStatus::SETTLED),
	    1 => Ok(DelforwardStatus::LOCAL_FAILED),
	    2 => Ok(DelforwardStatus::FAILED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum DelforwardStatus", o)),
	        }
	    }
	}

	impl ToString for DelforwardStatus {
	    fn to_string(&self) -> String {
	        match self {
	            DelforwardStatus::SETTLED => "SETTLED",
	            DelforwardStatus::LOCAL_FAILED => "LOCAL_FAILED",
	            DelforwardStatus::FAILED => "FAILED",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DelforwardRequest {
	    // Path `DelForward.status`
	    pub status: DelforwardStatus,
	    pub in_channel: ShortChannelId,
	    pub in_htlc_id: u64,
	}

	impl From<DelforwardRequest> for Request {
	    fn from(r: DelforwardRequest) -> Self {
	        Request::DelForward(r)
	    }
	}

	impl IntoRequest for DelforwardRequest {
	    type Response = super::responses::DelforwardResponse;
	}

	impl TypedRequest for DelforwardRequest {
	    type Response = super::responses::DelforwardResponse;

	    fn method(&self) -> &str {
	        "delforward"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DisableofferRequest {
	    pub offer_id: Sha256,
	}

	impl From<DisableofferRequest> for Request {
	    fn from(r: DisableofferRequest) -> Self {
	        Request::DisableOffer(r)
	    }
	}

	impl IntoRequest for DisableofferRequest {
	    type Response = super::responses::DisableofferResponse;
	}

	impl TypedRequest for DisableofferRequest {
	    type Response = super::responses::DisableofferResponse;

	    fn method(&self) -> &str {
	        "disableoffer"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DisconnectRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub force: Option<bool>,
	    pub id: PublicKey,
	}

	impl From<DisconnectRequest> for Request {
	    fn from(r: DisconnectRequest) -> Self {
	        Request::Disconnect(r)
	    }
	}

	impl IntoRequest for DisconnectRequest {
	    type Response = super::responses::DisconnectResponse;
	}

	impl TypedRequest for DisconnectRequest {
	    type Response = super::responses::DisconnectResponse;

	    fn method(&self) -> &str {
	        "disconnect"
	    }
	}
	/// ['Fee rate style to use. This can be:', '    *perkw* - provide feerate in units of satoshis per 1000 weight (e.g. the minimum fee is usually `253perkw`).', '    *perkb* - provide feerate in units of satoshis per 1000 virtual bytes (eg. the minimum fee is usually `1000perkb`).']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum FeeratesStyle {
	    #[serde(rename = "perkb")]
	    PERKB = 0,
	    #[serde(rename = "perkw")]
	    PERKW = 1,
	}

	impl TryFrom<i32> for FeeratesStyle {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<FeeratesStyle, anyhow::Error> {
	        match c {
	    0 => Ok(FeeratesStyle::PERKB),
	    1 => Ok(FeeratesStyle::PERKW),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum FeeratesStyle", o)),
	        }
	    }
	}

	impl ToString for FeeratesStyle {
	    fn to_string(&self) -> String {
	        match self {
	            FeeratesStyle::PERKB => "PERKB",
	            FeeratesStyle::PERKW => "PERKW",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FeeratesRequest {
	    // Path `Feerates.style`
	    pub style: FeeratesStyle,
	}

	impl From<FeeratesRequest> for Request {
	    fn from(r: FeeratesRequest) -> Self {
	        Request::Feerates(r)
	    }
	}

	impl IntoRequest for FeeratesRequest {
	    type Response = super::responses::FeeratesResponse;
	}

	impl TypedRequest for FeeratesRequest {
	    type Response = super::responses::FeeratesResponse;

	    fn method(&self) -> &str {
	        "feerates"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FetchinvoiceRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payer_note: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub quantity: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub recurrence_counter: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub recurrence_label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub recurrence_start: Option<f64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub timeout: Option<f64>,
	    pub offer: String,
	}

	impl From<FetchinvoiceRequest> for Request {
	    fn from(r: FetchinvoiceRequest) -> Self {
	        Request::FetchInvoice(r)
	    }
	}

	impl IntoRequest for FetchinvoiceRequest {
	    type Response = super::responses::FetchinvoiceResponse;
	}

	impl TypedRequest for FetchinvoiceRequest {
	    type Response = super::responses::FetchinvoiceResponse;

	    fn method(&self) -> &str {
	        "fetchinvoice"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct Fundchannel_cancelRequest {
	    pub id: PublicKey,
	}

	impl From<Fundchannel_cancelRequest> for Request {
	    fn from(r: Fundchannel_cancelRequest) -> Self {
	        Request::FundChannel_Cancel(r)
	    }
	}

	impl IntoRequest for Fundchannel_cancelRequest {
	    type Response = super::responses::Fundchannel_cancelResponse;
	}

	impl TypedRequest for Fundchannel_cancelRequest {
	    type Response = super::responses::Fundchannel_cancelResponse;

	    fn method(&self) -> &str {
	        "fundchannel_cancel"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct Fundchannel_completeRequest {
	    pub id: PublicKey,
	    pub psbt: String,
	}

	impl From<Fundchannel_completeRequest> for Request {
	    fn from(r: Fundchannel_completeRequest) -> Self {
	        Request::FundChannel_Complete(r)
	    }
	}

	impl IntoRequest for Fundchannel_completeRequest {
	    type Response = super::responses::Fundchannel_completeResponse;
	}

	impl TypedRequest for Fundchannel_completeRequest {
	    type Response = super::responses::Fundchannel_completeResponse;

	    fn method(&self) -> &str {
	        "fundchannel_complete"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FundchannelRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub announce: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub close_to: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub compact_lease: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feerate: Option<Feerate>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub minconf: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub mindepth: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub push_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub request_amt: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub reserve: Option<Amount>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub channel_type: Option<Vec<u32>>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub utxos: Option<Vec<Outpoint>>,
	    pub amount: AmountOrAll,
	    pub id: PublicKey,
	}

	impl From<FundchannelRequest> for Request {
	    fn from(r: FundchannelRequest) -> Self {
	        Request::FundChannel(r)
	    }
	}

	impl IntoRequest for FundchannelRequest {
	    type Response = super::responses::FundchannelResponse;
	}

	impl TypedRequest for FundchannelRequest {
	    type Response = super::responses::FundchannelResponse;

	    fn method(&self) -> &str {
	        "fundchannel"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct Fundchannel_startRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub announce: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub close_to: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feerate: Option<Feerate>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub mindepth: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub push_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub reserve: Option<Amount>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub channel_type: Option<Vec<u32>>,
	    pub amount: Amount,
	    pub id: PublicKey,
	}

	impl From<Fundchannel_startRequest> for Request {
	    fn from(r: Fundchannel_startRequest) -> Self {
	        Request::FundChannel_Start(r)
	    }
	}

	impl IntoRequest for Fundchannel_startRequest {
	    type Response = super::responses::Fundchannel_startResponse;
	}

	impl TypedRequest for Fundchannel_startRequest {
	    type Response = super::responses::Fundchannel_startResponse;

	    fn method(&self) -> &str {
	        "fundchannel_start"
	    }
	}
	/// ['A string that represents the log level.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum GetlogLevel {
	    #[serde(rename = "broken")]
	    BROKEN = 0,
	    #[serde(rename = "unusual")]
	    UNUSUAL = 1,
	    #[serde(rename = "info")]
	    INFO = 2,
	    #[serde(rename = "debug")]
	    DEBUG = 3,
	    #[serde(rename = "io")]
	    IO = 4,
	    #[serde(rename = "trace")]
	    TRACE = 5,
	}

	impl TryFrom<i32> for GetlogLevel {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<GetlogLevel, anyhow::Error> {
	        match c {
	    0 => Ok(GetlogLevel::BROKEN),
	    1 => Ok(GetlogLevel::UNUSUAL),
	    2 => Ok(GetlogLevel::INFO),
	    3 => Ok(GetlogLevel::DEBUG),
	    4 => Ok(GetlogLevel::IO),
	    5 => Ok(GetlogLevel::TRACE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum GetlogLevel", o)),
	        }
	    }
	}

	impl ToString for GetlogLevel {
	    fn to_string(&self) -> String {
	        match self {
	            GetlogLevel::BROKEN => "BROKEN",
	            GetlogLevel::UNUSUAL => "UNUSUAL",
	            GetlogLevel::INFO => "INFO",
	            GetlogLevel::DEBUG => "DEBUG",
	            GetlogLevel::TRACE => "TRACE",
	            GetlogLevel::IO => "IO",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetlogRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub level: Option<GetlogLevel>,
	}

	impl From<GetlogRequest> for Request {
	    fn from(r: GetlogRequest) -> Self {
	        Request::GetLog(r)
	    }
	}

	impl IntoRequest for GetlogRequest {
	    type Response = super::responses::GetlogResponse;
	}

	impl TypedRequest for GetlogRequest {
	    type Response = super::responses::GetlogResponse;

	    fn method(&self) -> &str {
	        "getlog"
	    }
	}
	/// ['Funder plugin will use to decide how much capital to commit to a v2 open channel request.', 'There are three policy options, detailed below:', '    * `match` -- Contribute *policy_mod* percent of their requested funds. Valid *policy_mod* values are 0 to 200. If this is a channel lease request, we match based on their requested funds. If it is not a channel lease request (and *lease_only* is false), then we match their funding amount. Note: any lease match less than 100 will likely fail, as clients will not accept a lease less than their request.', '    * `available` -- Contribute *policy_mod* percent of our available node wallet funds. Valid *policy_mod* values are 0 to 100.', '    * `fixed` -- Contributes a fixed  *policy_mod* sats to v2 channel open requests.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum FunderupdatePolicy {
	    #[serde(rename = "match")]
	    MATCH = 0,
	    #[serde(rename = "available")]
	    AVAILABLE = 1,
	    #[serde(rename = "fixed")]
	    FIXED = 2,
	}

	impl TryFrom<i32> for FunderupdatePolicy {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<FunderupdatePolicy, anyhow::Error> {
	        match c {
	    0 => Ok(FunderupdatePolicy::MATCH),
	    1 => Ok(FunderupdatePolicy::AVAILABLE),
	    2 => Ok(FunderupdatePolicy::FIXED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum FunderupdatePolicy", o)),
	        }
	    }
	}

	impl ToString for FunderupdatePolicy {
	    fn to_string(&self) -> String {
	        match self {
	            FunderupdatePolicy::MATCH => "MATCH",
	            FunderupdatePolicy::AVAILABLE => "AVAILABLE",
	            FunderupdatePolicy::FIXED => "FIXED",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FunderupdateRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub channel_fee_max_base_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub channel_fee_max_proportional_thousandths: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub compact_lease: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fund_probability: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_weight: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fuzz_percent: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub lease_fee_base_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub lease_fee_basis: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub leases_only: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub max_their_funding_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub min_their_funding_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub per_channel_max_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub per_channel_min_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub policy: Option<FunderupdatePolicy>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub policy_mod: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub reserve_tank_msat: Option<Amount>,
	}

	impl From<FunderupdateRequest> for Request {
	    fn from(r: FunderupdateRequest) -> Self {
	        Request::FunderUpdate(r)
	    }
	}

	impl IntoRequest for FunderupdateRequest {
	    type Response = super::responses::FunderupdateResponse;
	}

	impl TypedRequest for FunderupdateRequest {
	    type Response = super::responses::FunderupdateResponse;

	    fn method(&self) -> &str {
	        "funderupdate"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetrouteRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub cltv: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fromid: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fuzzpercent: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub maxhops: Option<u32>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub exclude: Option<Vec<String>>,
	    pub amount_msat: Amount,
	    pub id: PublicKey,
	    pub riskfactor: u64,
	}

	impl From<GetrouteRequest> for Request {
	    fn from(r: GetrouteRequest) -> Self {
	        Request::GetRoute(r)
	    }
	}

	impl IntoRequest for GetrouteRequest {
	    type Response = super::responses::GetrouteResponse;
	}

	impl TypedRequest for GetrouteRequest {
	    type Response = super::responses::GetrouteResponse;

	    fn method(&self) -> &str {
	        "getroute"
	    }
	}
	/// ['If neither *in_channel* nor *out_channel* is specified, it controls ordering.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListforwardsIndex {
	    #[serde(rename = "created")]
	    CREATED = 0,
	    #[serde(rename = "updated")]
	    UPDATED = 1,
	}

	impl TryFrom<i32> for ListforwardsIndex {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListforwardsIndex, anyhow::Error> {
	        match c {
	    0 => Ok(ListforwardsIndex::CREATED),
	    1 => Ok(ListforwardsIndex::UPDATED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListforwardsIndex", o)),
	        }
	    }
	}

	impl ToString for ListforwardsIndex {
	    fn to_string(&self) -> String {
	        match self {
	            ListforwardsIndex::CREATED => "CREATED",
	            ListforwardsIndex::UPDATED => "UPDATED",
	        }.to_string()
	    }
	}

	/// ['If specified, then only the forwards with the given status are returned.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListforwardsStatus {
	    #[serde(rename = "offered")]
	    OFFERED = 0,
	    #[serde(rename = "settled")]
	    SETTLED = 1,
	    #[serde(rename = "local_failed")]
	    LOCAL_FAILED = 2,
	    #[serde(rename = "failed")]
	    FAILED = 3,
	}

	impl TryFrom<i32> for ListforwardsStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListforwardsStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListforwardsStatus::OFFERED),
	    1 => Ok(ListforwardsStatus::SETTLED),
	    2 => Ok(ListforwardsStatus::LOCAL_FAILED),
	    3 => Ok(ListforwardsStatus::FAILED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListforwardsStatus", o)),
	        }
	    }
	}

	impl ToString for ListforwardsStatus {
	    fn to_string(&self) -> String {
	        match self {
	            ListforwardsStatus::OFFERED => "OFFERED",
	            ListforwardsStatus::SETTLED => "SETTLED",
	            ListforwardsStatus::LOCAL_FAILED => "LOCAL_FAILED",
	            ListforwardsStatus::FAILED => "FAILED",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListforwardsRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub in_channel: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub index: Option<ListforwardsIndex>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub limit: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_channel: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub start: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub status: Option<ListforwardsStatus>,
	}

	impl From<ListforwardsRequest> for Request {
	    fn from(r: ListforwardsRequest) -> Self {
	        Request::ListForwards(r)
	    }
	}

	impl IntoRequest for ListforwardsRequest {
	    type Response = super::responses::ListforwardsResponse;
	}

	impl TypedRequest for ListforwardsRequest {
	    type Response = super::responses::ListforwardsResponse;

	    fn method(&self) -> &str {
	        "listforwards"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListoffersRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub active_only: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_id: Option<Sha256>,
	}

	impl From<ListoffersRequest> for Request {
	    fn from(r: ListoffersRequest) -> Self {
	        Request::ListOffers(r)
	    }
	}

	impl IntoRequest for ListoffersRequest {
	    type Response = super::responses::ListoffersResponse;
	}

	impl TypedRequest for ListoffersRequest {
	    type Response = super::responses::ListoffersResponse;

	    fn method(&self) -> &str {
	        "listoffers"
	    }
	}
	/// ['To filter the payment by status.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListpaysStatus {
	    #[serde(rename = "pending")]
	    PENDING = 0,
	    #[serde(rename = "complete")]
	    COMPLETE = 1,
	    #[serde(rename = "failed")]
	    FAILED = 2,
	}

	impl TryFrom<i32> for ListpaysStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListpaysStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListpaysStatus::PENDING),
	    1 => Ok(ListpaysStatus::COMPLETE),
	    2 => Ok(ListpaysStatus::FAILED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListpaysStatus", o)),
	        }
	    }
	}

	impl ToString for ListpaysStatus {
	    fn to_string(&self) -> String {
	        match self {
	            ListpaysStatus::PENDING => "PENDING",
	            ListpaysStatus::COMPLETE => "COMPLETE",
	            ListpaysStatus::FAILED => "FAILED",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpaysRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_hash: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub status: Option<ListpaysStatus>,
	}

	impl From<ListpaysRequest> for Request {
	    fn from(r: ListpaysRequest) -> Self {
	        Request::ListPays(r)
	    }
	}

	impl IntoRequest for ListpaysRequest {
	    type Response = super::responses::ListpaysResponse;
	}

	impl TypedRequest for ListpaysRequest {
	    type Response = super::responses::ListpaysResponse;

	    fn method(&self) -> &str {
	        "listpays"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListhtlcsRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub id: Option<String>,
	}

	impl From<ListhtlcsRequest> for Request {
	    fn from(r: ListhtlcsRequest) -> Self {
	        Request::ListHtlcs(r)
	    }
	}

	impl IntoRequest for ListhtlcsRequest {
	    type Response = super::responses::ListhtlcsResponse;
	}

	impl TypedRequest for ListhtlcsRequest {
	    type Response = super::responses::ListhtlcsResponse;

	    fn method(&self) -> &str {
	        "listhtlcs"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct MultifundchannelDestinations {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub announce: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub close_to: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub compact_lease: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub mindepth: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub push_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub request_amt: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub reserve: Option<Amount>,
	    pub amount: AmountOrAll,
	    pub id: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct MultifundchannelRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub commitment_feerate: Option<Feerate>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feerate: Option<Feerate>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub minchannels: Option<i64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub minconf: Option<i64>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub utxos: Option<Vec<Outpoint>>,
	    pub destinations: Vec<MultifundchannelDestinations>,
	}

	impl From<MultifundchannelRequest> for Request {
	    fn from(r: MultifundchannelRequest) -> Self {
	        Request::MultiFundChannel(r)
	    }
	}

	impl IntoRequest for MultifundchannelRequest {
	    type Response = super::responses::MultifundchannelResponse;
	}

	impl TypedRequest for MultifundchannelRequest {
	    type Response = super::responses::MultifundchannelResponse;

	    fn method(&self) -> &str {
	        "multifundchannel"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct MultiwithdrawRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feerate: Option<Feerate>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub minconf: Option<u32>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub utxos: Option<Vec<Outpoint>>,
	    pub outputs: Vec<OutputDesc>,
	}

	impl From<MultiwithdrawRequest> for Request {
	    fn from(r: MultiwithdrawRequest) -> Self {
	        Request::MultiWithdraw(r)
	    }
	}

	impl IntoRequest for MultiwithdrawRequest {
	    type Response = super::responses::MultiwithdrawResponse;
	}

	impl TypedRequest for MultiwithdrawRequest {
	    type Response = super::responses::MultiwithdrawResponse;

	    fn method(&self) -> &str {
	        "multiwithdraw"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct OfferRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub absolute_expiry: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub issuer: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub quantity_max: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub recurrence: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub recurrence_base: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub recurrence_limit: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub recurrence_paywindow: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub single_use: Option<bool>,
	    pub amount: String,
	    pub description: String,
	}

	impl From<OfferRequest> for Request {
	    fn from(r: OfferRequest) -> Self {
	        Request::Offer(r)
	    }
	}

	impl IntoRequest for OfferRequest {
	    type Response = super::responses::OfferResponse;
	}

	impl TypedRequest for OfferRequest {
	    type Response = super::responses::OfferResponse;

	    fn method(&self) -> &str {
	        "offer"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct Openchannel_abortRequest {
	    pub channel_id: Sha256,
	}

	impl From<Openchannel_abortRequest> for Request {
	    fn from(r: Openchannel_abortRequest) -> Self {
	        Request::OpenChannel_Abort(r)
	    }
	}

	impl IntoRequest for Openchannel_abortRequest {
	    type Response = super::responses::Openchannel_abortResponse;
	}

	impl TypedRequest for Openchannel_abortRequest {
	    type Response = super::responses::Openchannel_abortResponse;

	    fn method(&self) -> &str {
	        "openchannel_abort"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct Openchannel_bumpRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_feerate: Option<Feerate>,
	    pub amount: Amount,
	    pub channel_id: Sha256,
	    pub initialpsbt: String,
	}

	impl From<Openchannel_bumpRequest> for Request {
	    fn from(r: Openchannel_bumpRequest) -> Self {
	        Request::OpenChannel_Bump(r)
	    }
	}

	impl IntoRequest for Openchannel_bumpRequest {
	    type Response = super::responses::Openchannel_bumpResponse;
	}

	impl TypedRequest for Openchannel_bumpRequest {
	    type Response = super::responses::Openchannel_bumpResponse;

	    fn method(&self) -> &str {
	        "openchannel_bump"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct Openchannel_initRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub announce: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub close_to: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub commitment_feerate: Option<Feerate>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub compact_lease: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_feerate: Option<Feerate>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub request_amt: Option<Amount>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub channel_type: Option<Vec<u32>>,
	    pub amount: Amount,
	    pub id: PublicKey,
	    pub initialpsbt: String,
	}

	impl From<Openchannel_initRequest> for Request {
	    fn from(r: Openchannel_initRequest) -> Self {
	        Request::OpenChannel_Init(r)
	    }
	}

	impl IntoRequest for Openchannel_initRequest {
	    type Response = super::responses::Openchannel_initResponse;
	}

	impl TypedRequest for Openchannel_initRequest {
	    type Response = super::responses::Openchannel_initResponse;

	    fn method(&self) -> &str {
	        "openchannel_init"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct Openchannel_signedRequest {
	    pub channel_id: Sha256,
	    pub signed_psbt: String,
	}

	impl From<Openchannel_signedRequest> for Request {
	    fn from(r: Openchannel_signedRequest) -> Self {
	        Request::OpenChannel_Signed(r)
	    }
	}

	impl IntoRequest for Openchannel_signedRequest {
	    type Response = super::responses::Openchannel_signedResponse;
	}

	impl TypedRequest for Openchannel_signedRequest {
	    type Response = super::responses::Openchannel_signedResponse;

	    fn method(&self) -> &str {
	        "openchannel_signed"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct Openchannel_updateRequest {
	    pub channel_id: Sha256,
	    pub psbt: String,
	}

	impl From<Openchannel_updateRequest> for Request {
	    fn from(r: Openchannel_updateRequest) -> Self {
	        Request::OpenChannel_Update(r)
	    }
	}

	impl IntoRequest for Openchannel_updateRequest {
	    type Response = super::responses::Openchannel_updateResponse;
	}

	impl TypedRequest for Openchannel_updateRequest {
	    type Response = super::responses::Openchannel_updateResponse;

	    fn method(&self) -> &str {
	        "openchannel_update"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct PingRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub len: Option<u16>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub pongbytes: Option<u16>,
	    pub id: PublicKey,
	}

	impl From<PingRequest> for Request {
	    fn from(r: PingRequest) -> Self {
	        Request::Ping(r)
	    }
	}

	impl IntoRequest for PingRequest {
	    type Response = super::responses::PingResponse;
	}

	impl TypedRequest for PingRequest {
	    type Response = super::responses::PingResponse;

	    fn method(&self) -> &str {
	        "ping"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct PluginRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub directory: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub plugin: Option<String>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub options: Option<Vec<String>>,
	    // Path `Plugin.subcommand`
	    pub subcommand: PluginSubcommand,
	}

	impl From<PluginRequest> for Request {
	    fn from(r: PluginRequest) -> Self {
	        Request::Plugin(r)
	    }
	}

	impl IntoRequest for PluginRequest {
	    type Response = super::responses::PluginResponse;
	}

	impl TypedRequest for PluginRequest {
	    type Response = super::responses::PluginResponse;

	    fn method(&self) -> &str {
	        "plugin"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct RenepaystatusRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invstring: Option<String>,
	}

	impl From<RenepaystatusRequest> for Request {
	    fn from(r: RenepaystatusRequest) -> Self {
	        Request::RenePayStatus(r)
	    }
	}

	impl IntoRequest for RenepaystatusRequest {
	    type Response = super::responses::RenepaystatusResponse;
	}

	impl TypedRequest for RenepaystatusRequest {
	    type Response = super::responses::RenepaystatusResponse;

	    fn method(&self) -> &str {
	        "renepaystatus"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct RenepayRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub dev_use_shadow: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub maxdelay: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub maxfee: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub retry_for: Option<u32>,
	    pub invstring: String,
	}

	impl From<RenepayRequest> for Request {
	    fn from(r: RenepayRequest) -> Self {
	        Request::RenePay(r)
	    }
	}

	impl IntoRequest for RenepayRequest {
	    type Response = super::responses::RenepayResponse;
	}

	impl TypedRequest for RenepayRequest {
	    type Response = super::responses::RenepayResponse;

	    fn method(&self) -> &str {
	        "renepay"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ReserveinputsRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub exclusive: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub reserve: Option<u32>,
	    pub psbt: String,
	}

	impl From<ReserveinputsRequest> for Request {
	    fn from(r: ReserveinputsRequest) -> Self {
	        Request::ReserveInputs(r)
	    }
	}

	impl IntoRequest for ReserveinputsRequest {
	    type Response = super::responses::ReserveinputsResponse;
	}

	impl TypedRequest for ReserveinputsRequest {
	    type Response = super::responses::ReserveinputsResponse;

	    fn method(&self) -> &str {
	        "reserveinputs"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendcustommsgRequest {
	    pub msg: String,
	    pub node_id: PublicKey,
	}

	impl From<SendcustommsgRequest> for Request {
	    fn from(r: SendcustommsgRequest) -> Self {
	        Request::SendCustomMsg(r)
	    }
	}

	impl IntoRequest for SendcustommsgRequest {
	    type Response = super::responses::SendcustommsgResponse;
	}

	impl TypedRequest for SendcustommsgRequest {
	    type Response = super::responses::SendcustommsgResponse;

	    fn method(&self) -> &str {
	        "sendcustommsg"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendinvoiceRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub quantity: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub timeout: Option<u32>,
	    pub invreq: String,
	    pub label: String,
	}

	impl From<SendinvoiceRequest> for Request {
	    fn from(r: SendinvoiceRequest) -> Self {
	        Request::SendInvoice(r)
	    }
	}

	impl IntoRequest for SendinvoiceRequest {
	    type Response = super::responses::SendinvoiceResponse;
	}

	impl TypedRequest for SendinvoiceRequest {
	    type Response = super::responses::SendinvoiceResponse;

	    fn method(&self) -> &str {
	        "sendinvoice"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendonionmessageHops {
	    pub node: PublicKey,
	    pub tlv: u8,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendonionmessageRequest {
	    pub blinding: PublicKey,
	    pub first_id: PublicKey,
	    pub hops: Vec<SendonionmessageHops>,
	}

	impl From<SendonionmessageRequest> for Request {
	    fn from(r: SendonionmessageRequest) -> Self {
	        Request::SendOnionMessage(r)
	    }
	}

	impl IntoRequest for SendonionmessageRequest {
	    type Response = super::responses::SendonionmessageResponse;
	}

	impl TypedRequest for SendonionmessageRequest {
	    type Response = super::responses::SendonionmessageResponse;

	    fn method(&self) -> &str {
	        "sendonionmessage"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SetchannelRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub enforcedelay: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feebase: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feeppm: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub htlcmax: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub htlcmin: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub ignorefeelimits: Option<bool>,
	    pub id: String,
	}

	impl From<SetchannelRequest> for Request {
	    fn from(r: SetchannelRequest) -> Self {
	        Request::SetChannel(r)
	    }
	}

	impl IntoRequest for SetchannelRequest {
	    type Response = super::responses::SetchannelResponse;
	}

	impl TypedRequest for SetchannelRequest {
	    type Response = super::responses::SetchannelResponse;

	    fn method(&self) -> &str {
	        "setchannel"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SetconfigRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub val: Option<String>,
	    pub config: String,
	}

	impl From<SetconfigRequest> for Request {
	    fn from(r: SetconfigRequest) -> Self {
	        Request::SetConfig(r)
	    }
	}

	impl IntoRequest for SetconfigRequest {
	    type Response = super::responses::SetconfigResponse;
	}

	impl TypedRequest for SetconfigRequest {
	    type Response = super::responses::SetconfigResponse;

	    fn method(&self) -> &str {
	        "setconfig"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SetpsbtversionRequest {
	    pub psbt: String,
	    pub version: u32,
	}

	impl From<SetpsbtversionRequest> for Request {
	    fn from(r: SetpsbtversionRequest) -> Self {
	        Request::SetPsbtVersion(r)
	    }
	}

	impl IntoRequest for SetpsbtversionRequest {
	    type Response = super::responses::SetpsbtversionResponse;
	}

	impl TypedRequest for SetpsbtversionRequest {
	    type Response = super::responses::SetpsbtversionResponse;

	    fn method(&self) -> &str {
	        "setpsbtversion"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SigninvoiceRequest {
	    pub invstring: String,
	}

	impl From<SigninvoiceRequest> for Request {
	    fn from(r: SigninvoiceRequest) -> Self {
	        Request::SignInvoice(r)
	    }
	}

	impl IntoRequest for SigninvoiceRequest {
	    type Response = super::responses::SigninvoiceResponse;
	}

	impl TypedRequest for SigninvoiceRequest {
	    type Response = super::responses::SigninvoiceResponse;

	    fn method(&self) -> &str {
	        "signinvoice"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SignmessageRequest {
	    pub message: String,
	}

	impl From<SignmessageRequest> for Request {
	    fn from(r: SignmessageRequest) -> Self {
	        Request::SignMessage(r)
	    }
	}

	impl IntoRequest for SignmessageRequest {
	    type Response = super::responses::SignmessageResponse;
	}

	impl TypedRequest for SignmessageRequest {
	    type Response = super::responses::SignmessageResponse;

	    fn method(&self) -> &str {
	        "signmessage"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct Splice_initRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feerate_per_kw: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub force_feerate: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub initialpsbt: Option<String>,
	    pub channel_id: Sha256,
	    pub relative_amount: i64,
	}

	impl From<Splice_initRequest> for Request {
	    fn from(r: Splice_initRequest) -> Self {
	        Request::Splice_Init(r)
	    }
	}

	impl IntoRequest for Splice_initRequest {
	    type Response = super::responses::Splice_initResponse;
	}

	impl TypedRequest for Splice_initRequest {
	    type Response = super::responses::Splice_initResponse;

	    fn method(&self) -> &str {
	        "splice_init"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct Splice_signedRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub sign_first: Option<bool>,
	    pub channel_id: Sha256,
	    pub psbt: String,
	}

	impl From<Splice_signedRequest> for Request {
	    fn from(r: Splice_signedRequest) -> Self {
	        Request::Splice_Signed(r)
	    }
	}

	impl IntoRequest for Splice_signedRequest {
	    type Response = super::responses::Splice_signedResponse;
	}

	impl TypedRequest for Splice_signedRequest {
	    type Response = super::responses::Splice_signedResponse;

	    fn method(&self) -> &str {
	        "splice_signed"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct Splice_updateRequest {
	    pub channel_id: Sha256,
	    pub psbt: String,
	}

	impl From<Splice_updateRequest> for Request {
	    fn from(r: Splice_updateRequest) -> Self {
	        Request::Splice_Update(r)
	    }
	}

	impl IntoRequest for Splice_updateRequest {
	    type Response = super::responses::Splice_updateResponse;
	}

	impl TypedRequest for Splice_updateRequest {
	    type Response = super::responses::Splice_updateResponse;

	    fn method(&self) -> &str {
	        "splice_update"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct UnreserveinputsRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub reserve: Option<u32>,
	    pub psbt: String,
	}

	impl From<UnreserveinputsRequest> for Request {
	    fn from(r: UnreserveinputsRequest) -> Self {
	        Request::UnreserveInputs(r)
	    }
	}

	impl IntoRequest for UnreserveinputsRequest {
	    type Response = super::responses::UnreserveinputsResponse;
	}

	impl TypedRequest for UnreserveinputsRequest {
	    type Response = super::responses::UnreserveinputsResponse;

	    fn method(&self) -> &str {
	        "unreserveinputs"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct UpgradewalletRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feerate: Option<Feerate>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub reservedok: Option<bool>,
	}

	impl From<UpgradewalletRequest> for Request {
	    fn from(r: UpgradewalletRequest) -> Self {
	        Request::UpgradeWallet(r)
	    }
	}

	impl IntoRequest for UpgradewalletRequest {
	    type Response = super::responses::UpgradewalletResponse;
	}

	impl TypedRequest for UpgradewalletRequest {
	    type Response = super::responses::UpgradewalletResponse;

	    fn method(&self) -> &str {
	        "upgradewallet"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitblockheightRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub timeout: Option<u32>,
	    pub blockheight: u32,
	}

	impl From<WaitblockheightRequest> for Request {
	    fn from(r: WaitblockheightRequest) -> Self {
	        Request::WaitBlockHeight(r)
	    }
	}

	impl IntoRequest for WaitblockheightRequest {
	    type Response = super::responses::WaitblockheightResponse;
	}

	impl TypedRequest for WaitblockheightRequest {
	    type Response = super::responses::WaitblockheightResponse;

	    fn method(&self) -> &str {
	        "waitblockheight"
	    }
	}
	/// ['The name of the index to get the next value for.', '  `created` is incremented by one for every new object.', '  `updated` is incremented by one every time an object is changed.', '  `deleted` is incremented by one every time an object is deleted.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum WaitIndexname {
	    #[serde(rename = "created")]
	    CREATED = 0,
	    #[serde(rename = "updated")]
	    UPDATED = 1,
	    #[serde(rename = "deleted")]
	    DELETED = 2,
	}

	impl TryFrom<i32> for WaitIndexname {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<WaitIndexname, anyhow::Error> {
	        match c {
	    0 => Ok(WaitIndexname::CREATED),
	    1 => Ok(WaitIndexname::UPDATED),
	    2 => Ok(WaitIndexname::DELETED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum WaitIndexname", o)),
	        }
	    }
	}

	impl ToString for WaitIndexname {
	    fn to_string(&self) -> String {
	        match self {
	            WaitIndexname::CREATED => "CREATED",
	            WaitIndexname::UPDATED => "UPDATED",
	            WaitIndexname::DELETED => "DELETED",
	        }.to_string()
	    }
	}

	/// ['The subsystem to get the next index value from.', '  `invoices`: corresponding to `listinvoices` (added in *v23.08*).', '  `sendpays`: corresponding to `listsendpays` (added in *v23.11*).', '  `forwards`: corresponding to `listforwards` (added in *v23.11*).']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum WaitSubsystem {
	    #[serde(rename = "invoices")]
	    INVOICES = 0,
	    #[serde(rename = "forwards")]
	    FORWARDS = 1,
	    #[serde(rename = "sendpays")]
	    SENDPAYS = 2,
	}

	impl TryFrom<i32> for WaitSubsystem {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<WaitSubsystem, anyhow::Error> {
	        match c {
	    0 => Ok(WaitSubsystem::INVOICES),
	    1 => Ok(WaitSubsystem::FORWARDS),
	    2 => Ok(WaitSubsystem::SENDPAYS),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum WaitSubsystem", o)),
	        }
	    }
	}

	impl ToString for WaitSubsystem {
	    fn to_string(&self) -> String {
	        match self {
	            WaitSubsystem::INVOICES => "INVOICES",
	            WaitSubsystem::FORWARDS => "FORWARDS",
	            WaitSubsystem::SENDPAYS => "SENDPAYS",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitRequest {
	    // Path `Wait.indexname`
	    pub indexname: WaitIndexname,
	    // Path `Wait.subsystem`
	    pub subsystem: WaitSubsystem,
	    pub nextvalue: u64,
	}

	impl From<WaitRequest> for Request {
	    fn from(r: WaitRequest) -> Self {
	        Request::Wait(r)
	    }
	}

	impl IntoRequest for WaitRequest {
	    type Response = super::responses::WaitResponse;
	}

	impl TypedRequest for WaitRequest {
	    type Response = super::responses::WaitResponse;

	    fn method(&self) -> &str {
	        "wait"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub config: Option<String>,
	}

	impl From<ListconfigsRequest> for Request {
	    fn from(r: ListconfigsRequest) -> Self {
	        Request::ListConfigs(r)
	    }
	}

	impl IntoRequest for ListconfigsRequest {
	    type Response = super::responses::ListconfigsResponse;
	}

	impl TypedRequest for ListconfigsRequest {
	    type Response = super::responses::ListconfigsResponse;

	    fn method(&self) -> &str {
	        "listconfigs"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct StopRequest {
	}

	impl From<StopRequest> for Request {
	    fn from(r: StopRequest) -> Self {
	        Request::Stop(r)
	    }
	}

	impl IntoRequest for StopRequest {
	    type Response = super::responses::StopResponse;
	}

	impl TypedRequest for StopRequest {
	    type Response = super::responses::StopResponse;

	    fn method(&self) -> &str {
	        "stop"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct HelpRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub command: Option<String>,
	}

	impl From<HelpRequest> for Request {
	    fn from(r: HelpRequest) -> Self {
	        Request::Help(r)
	    }
	}

	impl IntoRequest for HelpRequest {
	    type Response = super::responses::HelpResponse;
	}

	impl TypedRequest for HelpRequest {
	    type Response = super::responses::HelpResponse;

	    fn method(&self) -> &str {
	        "help"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct PreapprovekeysendRequest {
	    pub amount_msat: Amount,
	    pub destination: PublicKey,
	    pub payment_hash: String,
	}

	impl From<PreapprovekeysendRequest> for Request {
	    fn from(r: PreapprovekeysendRequest) -> Self {
	        Request::PreApproveKeysend(r)
	    }
	}

	impl IntoRequest for PreapprovekeysendRequest {
	    type Response = super::responses::PreapprovekeysendResponse;
	}

	impl TypedRequest for PreapprovekeysendRequest {
	    type Response = super::responses::PreapprovekeysendResponse;

	    fn method(&self) -> &str {
	        "preapprovekeysend"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct PreapproveinvoiceRequest {
	    pub bolt11: String,
	}

	impl From<PreapproveinvoiceRequest> for Request {
	    fn from(r: PreapproveinvoiceRequest) -> Self {
	        Request::PreApproveInvoice(r)
	    }
	}

	impl IntoRequest for PreapproveinvoiceRequest {
	    type Response = super::responses::PreapproveinvoiceResponse;
	}

	impl TypedRequest for PreapproveinvoiceRequest {
	    type Response = super::responses::PreapproveinvoiceResponse;

	    fn method(&self) -> &str {
	        "preapproveinvoice"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct StaticbackupRequest {
	}

	impl From<StaticbackupRequest> for Request {
	    fn from(r: StaticbackupRequest) -> Self {
	        Request::StaticBackup(r)
	    }
	}

	impl IntoRequest for StaticbackupRequest {
	    type Response = super::responses::StaticbackupResponse;
	}

	impl TypedRequest for StaticbackupRequest {
	    type Response = super::responses::StaticbackupResponse;

	    fn method(&self) -> &str {
	        "staticbackup"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct BkprchannelsapyRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub end_time: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub start_time: Option<u64>,
	}

	impl From<BkprchannelsapyRequest> for Request {
	    fn from(r: BkprchannelsapyRequest) -> Self {
	        Request::BkprChannelsApy(r)
	    }
	}

	impl IntoRequest for BkprchannelsapyRequest {
	    type Response = super::responses::BkprchannelsapyResponse;
	}

	impl TypedRequest for BkprchannelsapyRequest {
	    type Response = super::responses::BkprchannelsapyResponse;

	    fn method(&self) -> &str {
	        "bkpr-channelsapy"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct BkprdumpincomecsvRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub consolidate_fees: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub csv_file: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub end_time: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub start_time: Option<u64>,
	    pub csv_format: String,
	}

	impl From<BkprdumpincomecsvRequest> for Request {
	    fn from(r: BkprdumpincomecsvRequest) -> Self {
	        Request::BkprDumpIncomeCsv(r)
	    }
	}

	impl IntoRequest for BkprdumpincomecsvRequest {
	    type Response = super::responses::BkprdumpincomecsvResponse;
	}

	impl TypedRequest for BkprdumpincomecsvRequest {
	    type Response = super::responses::BkprdumpincomecsvResponse;

	    fn method(&self) -> &str {
	        "bkpr-dumpincomecsv"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct BkprinspectRequest {
	    pub account: String,
	}

	impl From<BkprinspectRequest> for Request {
	    fn from(r: BkprinspectRequest) -> Self {
	        Request::BkprInspect(r)
	    }
	}

	impl IntoRequest for BkprinspectRequest {
	    type Response = super::responses::BkprinspectResponse;
	}

	impl TypedRequest for BkprinspectRequest {
	    type Response = super::responses::BkprinspectResponse;

	    fn method(&self) -> &str {
	        "bkpr-inspect"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct BkprlistaccounteventsRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub account: Option<String>,
	}

	impl From<BkprlistaccounteventsRequest> for Request {
	    fn from(r: BkprlistaccounteventsRequest) -> Self {
	        Request::BkprListAccountEvents(r)
	    }
	}

	impl IntoRequest for BkprlistaccounteventsRequest {
	    type Response = super::responses::BkprlistaccounteventsResponse;
	}

	impl TypedRequest for BkprlistaccounteventsRequest {
	    type Response = super::responses::BkprlistaccounteventsResponse;

	    fn method(&self) -> &str {
	        "bkpr-listaccountevents"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct BkprlistbalancesRequest {
	}

	impl From<BkprlistbalancesRequest> for Request {
	    fn from(r: BkprlistbalancesRequest) -> Self {
	        Request::BkprListBalances(r)
	    }
	}

	impl IntoRequest for BkprlistbalancesRequest {
	    type Response = super::responses::BkprlistbalancesResponse;
	}

	impl TypedRequest for BkprlistbalancesRequest {
	    type Response = super::responses::BkprlistbalancesResponse;

	    fn method(&self) -> &str {
	        "bkpr-listbalances"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct BkprlistincomeRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub consolidate_fees: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub end_time: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub start_time: Option<u32>,
	}

	impl From<BkprlistincomeRequest> for Request {
	    fn from(r: BkprlistincomeRequest) -> Self {
	        Request::BkprListIncome(r)
	    }
	}

	impl IntoRequest for BkprlistincomeRequest {
	    type Response = super::responses::BkprlistincomeResponse;
	}

	impl TypedRequest for BkprlistincomeRequest {
	    type Response = super::responses::BkprlistincomeResponse;

	    fn method(&self) -> &str {
	        "bkpr-listincome"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct BlacklistruneRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub end: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub start: Option<u64>,
	}

	impl From<BlacklistruneRequest> for Request {
	    fn from(r: BlacklistruneRequest) -> Self {
	        Request::BlacklistRune(r)
	    }
	}

	impl IntoRequest for BlacklistruneRequest {
	    type Response = super::responses::BlacklistruneResponse;
	}

	impl TypedRequest for BlacklistruneRequest {
	    type Response = super::responses::BlacklistruneResponse;

	    fn method(&self) -> &str {
	        "blacklistrune"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CheckruneRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub method: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub nodeid: Option<String>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub params: Option<Vec<String>>,
	    pub rune: String,
	}

	impl From<CheckruneRequest> for Request {
	    fn from(r: CheckruneRequest) -> Self {
	        Request::CheckRune(r)
	    }
	}

	impl IntoRequest for CheckruneRequest {
	    type Response = super::responses::CheckruneResponse;
	}

	impl TypedRequest for CheckruneRequest {
	    type Response = super::responses::CheckruneResponse;

	    fn method(&self) -> &str {
	        "checkrune"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CreateruneRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub rune: Option<String>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub restrictions: Option<Vec<String>>,
	}

	impl From<CreateruneRequest> for Request {
	    fn from(r: CreateruneRequest) -> Self {
	        Request::CreateRune(r)
	    }
	}

	impl IntoRequest for CreateruneRequest {
	    type Response = super::responses::CreateruneResponse;
	}

	impl TypedRequest for CreateruneRequest {
	    type Response = super::responses::CreateruneResponse;

	    fn method(&self) -> &str {
	        "createrune"
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ShowrunesRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub rune: Option<String>,
	}

	impl From<ShowrunesRequest> for Request {
	    fn from(r: ShowrunesRequest) -> Self {
	        Request::ShowRunes(r)
	    }
	}

	impl IntoRequest for ShowrunesRequest {
	    type Response = super::responses::ShowrunesResponse;
	}

	impl TypedRequest for ShowrunesRequest {
	    type Response = super::responses::ShowrunesResponse;

	    fn method(&self) -> &str {
	        "showrunes"
	    }
	}
}


pub mod responses {
    #[allow(unused_imports)]
    use crate::primitives::*;
    #[allow(unused_imports)]
    use serde::{{Deserialize, Serialize}};
    use super::{TryFromResponseError, Response};

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetinfoOur_features {
	    pub channel: String,
	    pub init: String,
	    pub invoice: String,
	    pub node: String,
	}

	/// ['Type of connection (until 23.08, `websocket` was also allowed).']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum GetinfoAddressType {
	    #[serde(rename = "dns")]
	    DNS = 0,
	    #[serde(rename = "ipv4")]
	    IPV4 = 1,
	    #[serde(rename = "ipv6")]
	    IPV6 = 2,
	    #[serde(rename = "torv2")]
	    TORV2 = 3,
	    #[serde(rename = "torv3")]
	    TORV3 = 4,
	}

	impl TryFrom<i32> for GetinfoAddressType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<GetinfoAddressType, anyhow::Error> {
	        match c {
	    0 => Ok(GetinfoAddressType::DNS),
	    1 => Ok(GetinfoAddressType::IPV4),
	    2 => Ok(GetinfoAddressType::IPV6),
	    3 => Ok(GetinfoAddressType::TORV2),
	    4 => Ok(GetinfoAddressType::TORV3),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum GetinfoAddressType", o)),
	        }
	    }
	}

	impl ToString for GetinfoAddressType {
	    fn to_string(&self) -> String {
	        match self {
	            GetinfoAddressType::DNS => "DNS",
	            GetinfoAddressType::IPV4 => "IPV4",
	            GetinfoAddressType::IPV6 => "IPV6",
	            GetinfoAddressType::TORV2 => "TORV2",
	            GetinfoAddressType::TORV3 => "TORV3",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetinfoAddress {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub address: Option<String>,
	    // Path `Getinfo.address[].type`
	    #[serde(rename = "type")]
	    pub item_type: GetinfoAddressType,
	    pub port: u16,
	}

	/// ['Type of connection.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum GetinfoBindingType {
	    #[serde(rename = "local socket")]
	    LOCAL_SOCKET = 0,
	    #[serde(rename = "ipv4")]
	    IPV4 = 1,
	    #[serde(rename = "ipv6")]
	    IPV6 = 2,
	    #[serde(rename = "torv2")]
	    TORV2 = 3,
	    #[serde(rename = "torv3")]
	    TORV3 = 4,
	    #[serde(rename = "websocket")]
	    WEBSOCKET = 5,
	}

	impl TryFrom<i32> for GetinfoBindingType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<GetinfoBindingType, anyhow::Error> {
	        match c {
	    0 => Ok(GetinfoBindingType::LOCAL_SOCKET),
	    1 => Ok(GetinfoBindingType::IPV4),
	    2 => Ok(GetinfoBindingType::IPV6),
	    3 => Ok(GetinfoBindingType::TORV2),
	    4 => Ok(GetinfoBindingType::TORV3),
	    5 => Ok(GetinfoBindingType::WEBSOCKET),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum GetinfoBindingType", o)),
	        }
	    }
	}

	impl ToString for GetinfoBindingType {
	    fn to_string(&self) -> String {
	        match self {
	            GetinfoBindingType::LOCAL_SOCKET => "LOCAL_SOCKET",
	            GetinfoBindingType::WEBSOCKET => "WEBSOCKET",
	            GetinfoBindingType::IPV4 => "IPV4",
	            GetinfoBindingType::IPV6 => "IPV6",
	            GetinfoBindingType::TORV2 => "TORV2",
	            GetinfoBindingType::TORV3 => "TORV3",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetinfoBinding {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub address: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub port: Option<u16>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub socket: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub subtype: Option<String>,
	    // Path `Getinfo.binding[].type`
	    #[serde(rename = "type")]
	    pub item_type: GetinfoBindingType,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetinfoResponse {
	    #[serde(rename = "lightning-dir")]
	    pub lightning_dir: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub alias: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub our_features: Option<GetinfoOur_features>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_bitcoind_sync: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_lightningd_sync: Option<String>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub address: Option<Vec<GetinfoAddress>>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub binding: Option<Vec<GetinfoBinding>>,
	    pub blockheight: u32,
	    pub color: String,
	    pub fees_collected_msat: Amount,
	    pub id: PublicKey,
	    pub network: String,
	    pub num_active_channels: u32,
	    pub num_inactive_channels: u32,
	    pub num_peers: u32,
	    pub num_pending_channels: u32,
	    pub version: String,
	}

	impl TryFrom<Response> for GetinfoResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Getinfo(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListpeersPeersLogType {
	    #[serde(rename = "SKIPPED")]
	    SKIPPED = 0,
	    #[serde(rename = "BROKEN")]
	    BROKEN = 1,
	    #[serde(rename = "UNUSUAL")]
	    UNUSUAL = 2,
	    #[serde(rename = "INFO")]
	    INFO = 3,
	    #[serde(rename = "DEBUG")]
	    DEBUG = 4,
	    #[serde(rename = "IO_IN")]
	    IO_IN = 5,
	    #[serde(rename = "IO_OUT")]
	    IO_OUT = 6,
	    #[serde(rename = "TRACE")]
	    TRACE = 7,
	}

	impl TryFrom<i32> for ListpeersPeersLogType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListpeersPeersLogType, anyhow::Error> {
	        match c {
	    0 => Ok(ListpeersPeersLogType::SKIPPED),
	    1 => Ok(ListpeersPeersLogType::BROKEN),
	    2 => Ok(ListpeersPeersLogType::UNUSUAL),
	    3 => Ok(ListpeersPeersLogType::INFO),
	    4 => Ok(ListpeersPeersLogType::DEBUG),
	    5 => Ok(ListpeersPeersLogType::IO_IN),
	    6 => Ok(ListpeersPeersLogType::IO_OUT),
	    7 => Ok(ListpeersPeersLogType::TRACE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListpeersPeersLogType", o)),
	        }
	    }
	}

	impl ToString for ListpeersPeersLogType {
	    fn to_string(&self) -> String {
	        match self {
	            ListpeersPeersLogType::SKIPPED => "SKIPPED",
	            ListpeersPeersLogType::BROKEN => "BROKEN",
	            ListpeersPeersLogType::UNUSUAL => "UNUSUAL",
	            ListpeersPeersLogType::INFO => "INFO",
	            ListpeersPeersLogType::DEBUG => "DEBUG",
	            ListpeersPeersLogType::TRACE => "TRACE",
	            ListpeersPeersLogType::IO_IN => "IO_IN",
	            ListpeersPeersLogType::IO_OUT => "IO_OUT",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeersPeersLog {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub data: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub log: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub node_id: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub num_skipped: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub source: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub time: Option<String>,
	    // Path `ListPeers.peers[].log[].type`
	    #[serde(rename = "type")]
	    pub item_type: ListpeersPeersLogType,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeersPeers {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub features: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub num_channels: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub remote_addr: Option<String>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub log: Option<Vec<ListpeersPeersLog>>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub netaddr: Option<Vec<String>>,
	    pub connected: bool,
	    pub id: PublicKey,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeersResponse {
	    pub peers: Vec<ListpeersPeers>,
	}

	impl TryFrom<Response> for ListpeersResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListPeers(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListfundsChannels {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub channel_id: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub short_channel_id: Option<ShortChannelId>,
	    // Path `ListFunds.channels[].state`
	    pub state: ChannelState,
	    pub amount_msat: Amount,
	    pub connected: bool,
	    pub funding_output: u32,
	    pub funding_txid: String,
	    pub our_amount_msat: Amount,
	    pub peer_id: PublicKey,
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListfundsOutputsStatus {
	    #[serde(rename = "unconfirmed")]
	    UNCONFIRMED = 0,
	    #[serde(rename = "confirmed")]
	    CONFIRMED = 1,
	    #[serde(rename = "spent")]
	    SPENT = 2,
	    #[serde(rename = "immature")]
	    IMMATURE = 3,
	}

	impl TryFrom<i32> for ListfundsOutputsStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListfundsOutputsStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListfundsOutputsStatus::UNCONFIRMED),
	    1 => Ok(ListfundsOutputsStatus::CONFIRMED),
	    2 => Ok(ListfundsOutputsStatus::SPENT),
	    3 => Ok(ListfundsOutputsStatus::IMMATURE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListfundsOutputsStatus", o)),
	        }
	    }
	}

	impl ToString for ListfundsOutputsStatus {
	    fn to_string(&self) -> String {
	        match self {
	            ListfundsOutputsStatus::UNCONFIRMED => "UNCONFIRMED",
	            ListfundsOutputsStatus::CONFIRMED => "CONFIRMED",
	            ListfundsOutputsStatus::SPENT => "SPENT",
	            ListfundsOutputsStatus::IMMATURE => "IMMATURE",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListfundsOutputs {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub address: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub blockheight: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub redeemscript: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub reserved_to_block: Option<u32>,
	    // Path `ListFunds.outputs[].status`
	    pub status: ListfundsOutputsStatus,
	    pub amount_msat: Amount,
	    pub output: u32,
	    pub reserved: bool,
	    pub scriptpubkey: String,
	    pub txid: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListfundsResponse {
	    pub channels: Vec<ListfundsChannels>,
	    pub outputs: Vec<ListfundsOutputs>,
	}

	impl TryFrom<Response> for ListfundsResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListFunds(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Status of the payment (could be complete if already sent previously).']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum SendpayStatus {
	    #[serde(rename = "pending")]
	    PENDING = 0,
	    #[serde(rename = "complete")]
	    COMPLETE = 1,
	}

	impl TryFrom<i32> for SendpayStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<SendpayStatus, anyhow::Error> {
	        match c {
	    0 => Ok(SendpayStatus::PENDING),
	    1 => Ok(SendpayStatus::COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum SendpayStatus", o)),
	        }
	    }
	}

	impl ToString for SendpayStatus {
	    fn to_string(&self) -> String {
	        match self {
	            SendpayStatus::PENDING => "PENDING",
	            SendpayStatus::COMPLETE => "COMPLETE",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendpayResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub completed_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub groupid: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub message: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub updated_index: Option<u64>,
	    // Path `SendPay.status`
	    pub status: SendpayStatus,
	    pub amount_sent_msat: Amount,
	    pub created_at: u64,
	    pub id: u64,
	    pub payment_hash: Sha256,
	}

	impl TryFrom<Response> for SendpayResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SendPay(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListchannelsChannels {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub htlc_maximum_msat: Option<Amount>,
	    pub active: bool,
	    pub amount_msat: Amount,
	    pub base_fee_millisatoshi: u32,
	    pub channel_flags: u8,
	    pub delay: u32,
	    pub destination: PublicKey,
	    pub direction: u32,
	    pub features: String,
	    pub fee_per_millionth: u32,
	    pub htlc_minimum_msat: Amount,
	    pub last_update: u32,
	    pub message_flags: u8,
	    pub public: bool,
	    pub short_channel_id: ShortChannelId,
	    pub source: PublicKey,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListchannelsResponse {
	    pub channels: Vec<ListchannelsChannels>,
	}

	impl TryFrom<Response> for ListchannelsResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListChannels(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AddgossipResponse {
	}

	impl TryFrom<Response> for AddgossipResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::AddGossip(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AddpsbtoutputResponse {
	    pub estimated_added_weight: u32,
	    pub outnum: u32,
	    pub psbt: String,
	}

	impl TryFrom<Response> for AddpsbtoutputResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::AddPsbtOutput(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AutocleaninvoiceResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub cycle_seconds: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub expired_by: Option<u64>,
	    pub enabled: bool,
	}

	impl TryFrom<Response> for AutocleaninvoiceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::AutoCleanInvoice(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AutocleanonceAutocleanExpiredinvoices {
	    pub cleaned: u64,
	    pub uncleaned: u64,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AutocleanonceAutocleanFailedforwards {
	    pub cleaned: u64,
	    pub uncleaned: u64,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AutocleanonceAutocleanFailedpays {
	    pub cleaned: u64,
	    pub uncleaned: u64,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AutocleanonceAutocleanPaidinvoices {
	    pub cleaned: u64,
	    pub uncleaned: u64,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AutocleanonceAutocleanSucceededforwards {
	    pub cleaned: u64,
	    pub uncleaned: u64,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AutocleanonceAutocleanSucceededpays {
	    pub cleaned: u64,
	    pub uncleaned: u64,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AutocleanonceAutoclean {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub expiredinvoices: Option<AutocleanonceAutocleanExpiredinvoices>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub failedforwards: Option<AutocleanonceAutocleanFailedforwards>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub failedpays: Option<AutocleanonceAutocleanFailedpays>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub paidinvoices: Option<AutocleanonceAutocleanPaidinvoices>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub succeededforwards: Option<AutocleanonceAutocleanSucceededforwards>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub succeededpays: Option<AutocleanonceAutocleanSucceededpays>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AutocleanonceResponse {
	    pub autoclean: AutocleanonceAutoclean,
	}

	impl TryFrom<Response> for AutocleanonceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::AutoCleanOnce(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AutocleanstatusAutocleanExpiredinvoices {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub age: Option<u64>,
	    pub cleaned: u64,
	    pub enabled: bool,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AutocleanstatusAutocleanFailedforwards {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub age: Option<u64>,
	    pub cleaned: u64,
	    pub enabled: bool,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AutocleanstatusAutocleanFailedpays {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub age: Option<u64>,
	    pub cleaned: u64,
	    pub enabled: bool,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AutocleanstatusAutocleanPaidinvoices {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub age: Option<u64>,
	    pub cleaned: u64,
	    pub enabled: bool,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AutocleanstatusAutocleanSucceededforwards {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub age: Option<u64>,
	    pub cleaned: u64,
	    pub enabled: bool,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AutocleanstatusAutocleanSucceededpays {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub age: Option<u64>,
	    pub cleaned: u64,
	    pub enabled: bool,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AutocleanstatusAutoclean {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub expiredinvoices: Option<AutocleanstatusAutocleanExpiredinvoices>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub failedforwards: Option<AutocleanstatusAutocleanFailedforwards>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub failedpays: Option<AutocleanstatusAutocleanFailedpays>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub paidinvoices: Option<AutocleanstatusAutocleanPaidinvoices>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub succeededforwards: Option<AutocleanstatusAutocleanSucceededforwards>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub succeededpays: Option<AutocleanstatusAutocleanSucceededpays>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AutocleanstatusResponse {
	    pub autoclean: AutocleanstatusAutoclean,
	}

	impl TryFrom<Response> for AutocleanstatusResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::AutoCleanStatus(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CheckmessageResponse {
	    pub pubkey: PublicKey,
	    pub verified: bool,
	}

	impl TryFrom<Response> for CheckmessageResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::CheckMessage(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Whether we successfully negotiated a mutual close, closed without them, or discarded not-yet-opened channel.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum CloseType {
	    #[serde(rename = "mutual")]
	    MUTUAL = 0,
	    #[serde(rename = "unilateral")]
	    UNILATERAL = 1,
	    #[serde(rename = "unopened")]
	    UNOPENED = 2,
	}

	impl TryFrom<i32> for CloseType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<CloseType, anyhow::Error> {
	        match c {
	    0 => Ok(CloseType::MUTUAL),
	    1 => Ok(CloseType::UNILATERAL),
	    2 => Ok(CloseType::UNOPENED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum CloseType", o)),
	        }
	    }
	}

	impl ToString for CloseType {
	    fn to_string(&self) -> String {
	        match self {
	            CloseType::MUTUAL => "MUTUAL",
	            CloseType::UNILATERAL => "UNILATERAL",
	            CloseType::UNOPENED => "UNOPENED",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CloseResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub tx: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub txid: Option<String>,
	    // Path `Close.type`
	    #[serde(rename = "type")]
	    pub item_type: CloseType,
	}

	impl TryFrom<Response> for CloseResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Close(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Whether they initiated connection or we did.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ConnectDirection {
	    #[serde(rename = "in")]
	    IN = 0,
	    #[serde(rename = "out")]
	    OUT = 1,
	}

	impl TryFrom<i32> for ConnectDirection {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ConnectDirection, anyhow::Error> {
	        match c {
	    0 => Ok(ConnectDirection::IN),
	    1 => Ok(ConnectDirection::OUT),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ConnectDirection", o)),
	        }
	    }
	}

	impl ToString for ConnectDirection {
	    fn to_string(&self) -> String {
	        match self {
	            ConnectDirection::IN => "IN",
	            ConnectDirection::OUT => "OUT",
	        }.to_string()
	    }
	}

	/// ['Type of connection (*torv2*/*torv3* only if **direction** is *out*).']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ConnectAddressType {
	    #[serde(rename = "local socket")]
	    LOCAL_SOCKET = 0,
	    #[serde(rename = "ipv4")]
	    IPV4 = 1,
	    #[serde(rename = "ipv6")]
	    IPV6 = 2,
	    #[serde(rename = "torv2")]
	    TORV2 = 3,
	    #[serde(rename = "torv3")]
	    TORV3 = 4,
	}

	impl TryFrom<i32> for ConnectAddressType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ConnectAddressType, anyhow::Error> {
	        match c {
	    0 => Ok(ConnectAddressType::LOCAL_SOCKET),
	    1 => Ok(ConnectAddressType::IPV4),
	    2 => Ok(ConnectAddressType::IPV6),
	    3 => Ok(ConnectAddressType::TORV2),
	    4 => Ok(ConnectAddressType::TORV3),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ConnectAddressType", o)),
	        }
	    }
	}

	impl ToString for ConnectAddressType {
	    fn to_string(&self) -> String {
	        match self {
	            ConnectAddressType::LOCAL_SOCKET => "LOCAL_SOCKET",
	            ConnectAddressType::IPV4 => "IPV4",
	            ConnectAddressType::IPV6 => "IPV6",
	            ConnectAddressType::TORV2 => "TORV2",
	            ConnectAddressType::TORV3 => "TORV3",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ConnectAddress {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub address: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub port: Option<u16>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub socket: Option<String>,
	    // Path `Connect.address.type`
	    #[serde(rename = "type")]
	    pub item_type: ConnectAddressType,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ConnectResponse {
	    // Path `Connect.direction`
	    pub direction: ConnectDirection,
	    pub address: ConnectAddress,
	    pub features: String,
	    pub id: PublicKey,
	}

	impl TryFrom<Response> for ConnectResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Connect(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CreateinvoicePaid_outpoint {
	    pub outnum: u32,
	    pub txid: String,
	}

	/// ['Whether it has been paid, or can no longer be paid.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum CreateinvoiceStatus {
	    #[serde(rename = "paid")]
	    PAID = 0,
	    #[serde(rename = "expired")]
	    EXPIRED = 1,
	    #[serde(rename = "unpaid")]
	    UNPAID = 2,
	}

	impl TryFrom<i32> for CreateinvoiceStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<CreateinvoiceStatus, anyhow::Error> {
	        match c {
	    0 => Ok(CreateinvoiceStatus::PAID),
	    1 => Ok(CreateinvoiceStatus::EXPIRED),
	    2 => Ok(CreateinvoiceStatus::UNPAID),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum CreateinvoiceStatus", o)),
	        }
	    }
	}

	impl ToString for CreateinvoiceStatus {
	    fn to_string(&self) -> String {
	        match self {
	            CreateinvoiceStatus::PAID => "PAID",
	            CreateinvoiceStatus::EXPIRED => "EXPIRED",
	            CreateinvoiceStatus::UNPAID => "UNPAID",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CreateinvoiceResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_received_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_payer_note: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub local_offer_id: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub paid_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub paid_outpoint: Option<CreateinvoicePaid_outpoint>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub pay_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	    // Path `CreateInvoice.status`
	    pub status: CreateinvoiceStatus,
	    pub description: String,
	    pub expires_at: u64,
	    pub label: String,
	    pub payment_hash: Sha256,
	}

	impl TryFrom<Response> for CreateinvoiceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::CreateInvoice(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DatastoreResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub generation: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub hex: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub string: Option<String>,
	    pub key: Vec<String>,
	}

	impl TryFrom<Response> for DatastoreResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Datastore(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DatastoreusageDatastoreusage {
	    pub key: String,
	    pub total_bytes: u64,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DatastoreusageResponse {
	    pub datastoreusage: DatastoreusageDatastoreusage,
	}

	impl TryFrom<Response> for DatastoreusageResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::DatastoreUsage(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CreateonionResponse {
	    pub onion: String,
	    pub shared_secrets: Vec<Secret>,
	}

	impl TryFrom<Response> for CreateonionResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::CreateOnion(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DeldatastoreResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub generation: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub hex: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub string: Option<String>,
	    pub key: Vec<String>,
	}

	impl TryFrom<Response> for DeldatastoreResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::DelDatastore(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['State of invoice.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum DelinvoiceStatus {
	    #[serde(rename = "paid")]
	    PAID = 0,
	    #[serde(rename = "expired")]
	    EXPIRED = 1,
	    #[serde(rename = "unpaid")]
	    UNPAID = 2,
	}

	impl TryFrom<i32> for DelinvoiceStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<DelinvoiceStatus, anyhow::Error> {
	        match c {
	    0 => Ok(DelinvoiceStatus::PAID),
	    1 => Ok(DelinvoiceStatus::EXPIRED),
	    2 => Ok(DelinvoiceStatus::UNPAID),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum DelinvoiceStatus", o)),
	        }
	    }
	}

	impl ToString for DelinvoiceStatus {
	    fn to_string(&self) -> String {
	        match self {
	            DelinvoiceStatus::PAID => "PAID",
	            DelinvoiceStatus::EXPIRED => "EXPIRED",
	            DelinvoiceStatus::UNPAID => "UNPAID",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DelinvoiceResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_received_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_payer_note: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub local_offer_id: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub paid_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub pay_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub updated_index: Option<u64>,
	    // Path `DelInvoice.status`
	    pub status: DelinvoiceStatus,
	    pub expires_at: u64,
	    pub label: String,
	    pub payment_hash: Sha256,
	}

	impl TryFrom<Response> for DelinvoiceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::DelInvoice(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DevforgetchannelResponse {
	    pub forced: bool,
	    pub funding_txid: String,
	    pub funding_unspent: bool,
	}

	impl TryFrom<Response> for DevforgetchannelResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::DevForgetChannel(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct EmergencyrecoverResponse {
	    pub stubs: Vec<Sha256>,
	}

	impl TryFrom<Response> for EmergencyrecoverResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::EmergencyRecover(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum RecoverResult {
	    #[serde(rename = "Recovery restart in progress")]
	    RECOVERY_RESTART_IN_PROGRESS = 0,
	}

	impl TryFrom<i32> for RecoverResult {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<RecoverResult, anyhow::Error> {
	        match c {
	    0 => Ok(RecoverResult::RECOVERY_RESTART_IN_PROGRESS),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum RecoverResult", o)),
	        }
	    }
	}

	impl ToString for RecoverResult {
	    fn to_string(&self) -> String {
	        match self {
	            RecoverResult::RECOVERY_RESTART_IN_PROGRESS => "RECOVERY_RESTART_IN_PROGRESS",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct RecoverResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub result: Option<RecoverResult>,
	}

	impl TryFrom<Response> for RecoverResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Recover(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct RecoverchannelResponse {
	    pub stubs: Vec<String>,
	}

	impl TryFrom<Response> for RecoverchannelResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::RecoverChannel(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct InvoiceResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_capacity: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_deadends: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_mpp: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_offline: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_private_unused: Option<String>,
	    pub bolt11: String,
	    pub expires_at: u64,
	    pub payment_hash: Sha256,
	    pub payment_secret: Secret,
	}

	impl TryFrom<Response> for InvoiceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Invoice(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct InvoicerequestResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    pub active: bool,
	    pub bolt12: String,
	    pub invreq_id: Sha256,
	    pub single_use: bool,
	    pub used: bool,
	}

	impl TryFrom<Response> for InvoicerequestResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::InvoiceRequest(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DisableinvoicerequestResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    pub active: bool,
	    pub bolt12: String,
	    pub invreq_id: Sha256,
	    pub single_use: bool,
	    pub used: bool,
	}

	impl TryFrom<Response> for DisableinvoicerequestResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::DisableInvoiceRequest(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListinvoicerequestsInvoicerequests {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    pub active: bool,
	    pub bolt12: String,
	    pub invreq_id: Sha256,
	    pub single_use: bool,
	    pub used: bool,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListinvoicerequestsResponse {
	    pub invoicerequests: Vec<ListinvoicerequestsInvoicerequests>,
	}

	impl TryFrom<Response> for ListinvoicerequestsResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListInvoiceRequests(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListdatastoreDatastore {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub generation: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub hex: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub string: Option<String>,
	    pub key: Vec<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListdatastoreResponse {
	    pub datastore: Vec<ListdatastoreDatastore>,
	}

	impl TryFrom<Response> for ListdatastoreResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListDatastore(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListinvoicesInvoicesPaid_outpoint {
	    pub outnum: u32,
	    pub txid: String,
	}

	/// ["Whether it's paid, unpaid or unpayable."]
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListinvoicesInvoicesStatus {
	    #[serde(rename = "unpaid")]
	    UNPAID = 0,
	    #[serde(rename = "paid")]
	    PAID = 1,
	    #[serde(rename = "expired")]
	    EXPIRED = 2,
	}

	impl TryFrom<i32> for ListinvoicesInvoicesStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListinvoicesInvoicesStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListinvoicesInvoicesStatus::UNPAID),
	    1 => Ok(ListinvoicesInvoicesStatus::PAID),
	    2 => Ok(ListinvoicesInvoicesStatus::EXPIRED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListinvoicesInvoicesStatus", o)),
	        }
	    }
	}

	impl ToString for ListinvoicesInvoicesStatus {
	    fn to_string(&self) -> String {
	        match self {
	            ListinvoicesInvoicesStatus::UNPAID => "UNPAID",
	            ListinvoicesInvoicesStatus::PAID => "PAID",
	            ListinvoicesInvoicesStatus::EXPIRED => "EXPIRED",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListinvoicesInvoices {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_received_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_payer_note: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub local_offer_id: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub paid_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub paid_outpoint: Option<ListinvoicesInvoicesPaid_outpoint>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub pay_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub updated_index: Option<u64>,
	    // Path `ListInvoices.invoices[].status`
	    pub status: ListinvoicesInvoicesStatus,
	    pub expires_at: u64,
	    pub label: String,
	    pub payment_hash: Sha256,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListinvoicesResponse {
	    pub invoices: Vec<ListinvoicesInvoices>,
	}

	impl TryFrom<Response> for ListinvoicesResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListInvoices(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Status of the payment (could be complete if already sent previously).']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum SendonionStatus {
	    #[serde(rename = "pending")]
	    PENDING = 0,
	    #[serde(rename = "complete")]
	    COMPLETE = 1,
	}

	impl TryFrom<i32> for SendonionStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<SendonionStatus, anyhow::Error> {
	        match c {
	    0 => Ok(SendonionStatus::PENDING),
	    1 => Ok(SendonionStatus::COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum SendonionStatus", o)),
	        }
	    }
	}

	impl ToString for SendonionStatus {
	    fn to_string(&self) -> String {
	        match self {
	            SendonionStatus::PENDING => "PENDING",
	            SendonionStatus::COMPLETE => "COMPLETE",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendonionResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub message: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub updated_index: Option<u64>,
	    // Path `SendOnion.status`
	    pub status: SendonionStatus,
	    pub amount_sent_msat: Amount,
	    pub created_at: u64,
	    pub id: u64,
	    pub payment_hash: Sha256,
	}

	impl TryFrom<Response> for SendonionResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SendOnion(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Status of the payment.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListsendpaysPaymentsStatus {
	    #[serde(rename = "pending")]
	    PENDING = 0,
	    #[serde(rename = "failed")]
	    FAILED = 1,
	    #[serde(rename = "complete")]
	    COMPLETE = 2,
	}

	impl TryFrom<i32> for ListsendpaysPaymentsStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListsendpaysPaymentsStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListsendpaysPaymentsStatus::PENDING),
	    1 => Ok(ListsendpaysPaymentsStatus::FAILED),
	    2 => Ok(ListsendpaysPaymentsStatus::COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListsendpaysPaymentsStatus", o)),
	        }
	    }
	}

	impl ToString for ListsendpaysPaymentsStatus {
	    fn to_string(&self) -> String {
	        match self {
	            ListsendpaysPaymentsStatus::PENDING => "PENDING",
	            ListsendpaysPaymentsStatus::FAILED => "FAILED",
	            ListsendpaysPaymentsStatus::COMPLETE => "COMPLETE",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListsendpaysPayments {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub completed_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub erroronion: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub updated_index: Option<u64>,
	    // Path `ListSendPays.payments[].status`
	    pub status: ListsendpaysPaymentsStatus,
	    pub amount_sent_msat: Amount,
	    pub created_at: u64,
	    pub groupid: u64,
	    pub id: u64,
	    pub payment_hash: Sha256,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListsendpaysResponse {
	    pub payments: Vec<ListsendpaysPayments>,
	}

	impl TryFrom<Response> for ListsendpaysResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListSendPays(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListtransactionsTransactionsInputs {
	    pub index: u32,
	    pub sequence: u32,
	    pub txid: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListtransactionsTransactionsOutputs {
	    #[serde(rename = "scriptPubKey")]
	    pub script_pub_key: String,
	    pub amount_msat: Amount,
	    pub index: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListtransactionsTransactions {
	    pub blockheight: u32,
	    pub hash: String,
	    pub inputs: Vec<ListtransactionsTransactionsInputs>,
	    pub locktime: u32,
	    pub outputs: Vec<ListtransactionsTransactionsOutputs>,
	    pub rawtx: String,
	    pub txindex: u32,
	    pub version: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListtransactionsResponse {
	    pub transactions: Vec<ListtransactionsTransactions>,
	}

	impl TryFrom<Response> for ListtransactionsResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListTransactions(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct MakesecretResponse {
	    pub secret: Secret,
	}

	impl TryFrom<Response> for MakesecretResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::MakeSecret(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Status of payment.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum PayStatus {
	    #[serde(rename = "complete")]
	    COMPLETE = 0,
	    #[serde(rename = "pending")]
	    PENDING = 1,
	    #[serde(rename = "failed")]
	    FAILED = 2,
	}

	impl TryFrom<i32> for PayStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<PayStatus, anyhow::Error> {
	        match c {
	    0 => Ok(PayStatus::COMPLETE),
	    1 => Ok(PayStatus::PENDING),
	    2 => Ok(PayStatus::FAILED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum PayStatus", o)),
	        }
	    }
	}

	impl ToString for PayStatus {
	    fn to_string(&self) -> String {
	        match self {
	            PayStatus::COMPLETE => "COMPLETE",
	            PayStatus::PENDING => "PENDING",
	            PayStatus::FAILED => "FAILED",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct PayResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_partial_completion: Option<String>,
	    // Path `Pay.status`
	    pub status: PayStatus,
	    pub amount_msat: Amount,
	    pub amount_sent_msat: Amount,
	    pub created_at: f64,
	    pub parts: u32,
	    pub payment_hash: Sha256,
	    pub payment_preimage: Secret,
	}

	impl TryFrom<Response> for PayResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Pay(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListnodesNodesOption_will_fund {
	    pub channel_fee_max_base_msat: Amount,
	    pub channel_fee_max_proportional_thousandths: u32,
	    pub compact_lease: String,
	    pub funding_weight: u32,
	    pub lease_fee_base_msat: Amount,
	    pub lease_fee_basis: u32,
	}

	/// ['Type of connection (until 23.08, `websocket` was also allowed).']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListnodesNodesAddressesType {
	    #[serde(rename = "dns")]
	    DNS = 0,
	    #[serde(rename = "ipv4")]
	    IPV4 = 1,
	    #[serde(rename = "ipv6")]
	    IPV6 = 2,
	    #[serde(rename = "torv2")]
	    TORV2 = 3,
	    #[serde(rename = "torv3")]
	    TORV3 = 4,
	}

	impl TryFrom<i32> for ListnodesNodesAddressesType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListnodesNodesAddressesType, anyhow::Error> {
	        match c {
	    0 => Ok(ListnodesNodesAddressesType::DNS),
	    1 => Ok(ListnodesNodesAddressesType::IPV4),
	    2 => Ok(ListnodesNodesAddressesType::IPV6),
	    3 => Ok(ListnodesNodesAddressesType::TORV2),
	    4 => Ok(ListnodesNodesAddressesType::TORV3),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListnodesNodesAddressesType", o)),
	        }
	    }
	}

	impl ToString for ListnodesNodesAddressesType {
	    fn to_string(&self) -> String {
	        match self {
	            ListnodesNodesAddressesType::DNS => "DNS",
	            ListnodesNodesAddressesType::IPV4 => "IPV4",
	            ListnodesNodesAddressesType::IPV6 => "IPV6",
	            ListnodesNodesAddressesType::TORV2 => "TORV2",
	            ListnodesNodesAddressesType::TORV3 => "TORV3",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListnodesNodesAddresses {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub address: Option<String>,
	    // Path `ListNodes.nodes[].addresses[].type`
	    #[serde(rename = "type")]
	    pub item_type: ListnodesNodesAddressesType,
	    pub port: u16,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListnodesNodes {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub alias: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub color: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub features: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub last_timestamp: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub option_will_fund: Option<ListnodesNodesOption_will_fund>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub addresses: Option<Vec<ListnodesNodesAddresses>>,
	    pub nodeid: PublicKey,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListnodesResponse {
	    pub nodes: Vec<ListnodesNodes>,
	}

	impl TryFrom<Response> for ListnodesResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListNodes(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitanyinvoicePaid_outpoint {
	    pub outnum: u32,
	    pub txid: String,
	}

	/// ["Whether it's paid or expired."]
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum WaitanyinvoiceStatus {
	    #[serde(rename = "paid")]
	    PAID = 0,
	    #[serde(rename = "expired")]
	    EXPIRED = 1,
	}

	impl TryFrom<i32> for WaitanyinvoiceStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<WaitanyinvoiceStatus, anyhow::Error> {
	        match c {
	    0 => Ok(WaitanyinvoiceStatus::PAID),
	    1 => Ok(WaitanyinvoiceStatus::EXPIRED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum WaitanyinvoiceStatus", o)),
	        }
	    }
	}

	impl ToString for WaitanyinvoiceStatus {
	    fn to_string(&self) -> String {
	        match self {
	            WaitanyinvoiceStatus::PAID => "PAID",
	            WaitanyinvoiceStatus::EXPIRED => "EXPIRED",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitanyinvoiceResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_received_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub paid_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub paid_outpoint: Option<WaitanyinvoicePaid_outpoint>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub pay_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub updated_index: Option<u64>,
	    // Path `WaitAnyInvoice.status`
	    pub status: WaitanyinvoiceStatus,
	    pub description: String,
	    pub expires_at: u64,
	    pub label: String,
	    pub payment_hash: Sha256,
	}

	impl TryFrom<Response> for WaitanyinvoiceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::WaitAnyInvoice(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitinvoicePaid_outpoint {
	    pub outnum: u32,
	    pub txid: String,
	}

	/// ["Whether it's paid or expired."]
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum WaitinvoiceStatus {
	    #[serde(rename = "paid")]
	    PAID = 0,
	    #[serde(rename = "expired")]
	    EXPIRED = 1,
	}

	impl TryFrom<i32> for WaitinvoiceStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<WaitinvoiceStatus, anyhow::Error> {
	        match c {
	    0 => Ok(WaitinvoiceStatus::PAID),
	    1 => Ok(WaitinvoiceStatus::EXPIRED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum WaitinvoiceStatus", o)),
	        }
	    }
	}

	impl ToString for WaitinvoiceStatus {
	    fn to_string(&self) -> String {
	        match self {
	            WaitinvoiceStatus::PAID => "PAID",
	            WaitinvoiceStatus::EXPIRED => "EXPIRED",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitinvoiceResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_received_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub paid_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub paid_outpoint: Option<WaitinvoicePaid_outpoint>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub pay_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub updated_index: Option<u64>,
	    // Path `WaitInvoice.status`
	    pub status: WaitinvoiceStatus,
	    pub description: String,
	    pub expires_at: u64,
	    pub label: String,
	    pub payment_hash: Sha256,
	}

	impl TryFrom<Response> for WaitinvoiceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::WaitInvoice(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Status of the payment.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum WaitsendpayStatus {
	    #[serde(rename = "complete")]
	    COMPLETE = 0,
	}

	impl TryFrom<i32> for WaitsendpayStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<WaitsendpayStatus, anyhow::Error> {
	        match c {
	    0 => Ok(WaitsendpayStatus::COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum WaitsendpayStatus", o)),
	        }
	    }
	}

	impl ToString for WaitsendpayStatus {
	    fn to_string(&self) -> String {
	        match self {
	            WaitsendpayStatus::COMPLETE => "COMPLETE",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitsendpayResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub completed_at: Option<f64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub groupid: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub updated_index: Option<u64>,
	    // Path `WaitSendPay.status`
	    pub status: WaitsendpayStatus,
	    pub amount_sent_msat: Amount,
	    pub created_at: u64,
	    pub id: u64,
	    pub payment_hash: Sha256,
	}

	impl TryFrom<Response> for WaitsendpayResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::WaitSendPay(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct NewaddrResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bech32: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub p2tr: Option<String>,
	}

	impl TryFrom<Response> for NewaddrResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::NewAddr(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WithdrawResponse {
	    pub psbt: String,
	    pub tx: String,
	    pub txid: String,
	}

	impl TryFrom<Response> for WithdrawResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Withdraw(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Status of payment.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum KeysendStatus {
	    #[serde(rename = "complete")]
	    COMPLETE = 0,
	}

	impl TryFrom<i32> for KeysendStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<KeysendStatus, anyhow::Error> {
	        match c {
	    0 => Ok(KeysendStatus::COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum KeysendStatus", o)),
	        }
	    }
	}

	impl ToString for KeysendStatus {
	    fn to_string(&self) -> String {
	        match self {
	            KeysendStatus::COMPLETE => "COMPLETE",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct KeysendResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_partial_completion: Option<String>,
	    // Path `KeySend.status`
	    pub status: KeysendStatus,
	    pub amount_msat: Amount,
	    pub amount_sent_msat: Amount,
	    pub created_at: f64,
	    pub parts: u32,
	    pub payment_hash: Sha256,
	    pub payment_preimage: Secret,
	}

	impl TryFrom<Response> for KeysendResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::KeySend(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FundpsbtReservations {
	    pub reserved: bool,
	    pub reserved_to_block: u32,
	    pub txid: String,
	    pub vout: u32,
	    pub was_reserved: bool,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FundpsbtResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub change_outnum: Option<u32>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub reservations: Option<Vec<FundpsbtReservations>>,
	    pub estimated_final_weight: u32,
	    pub excess_msat: Amount,
	    pub feerate_per_kw: u32,
	    pub psbt: String,
	}

	impl TryFrom<Response> for FundpsbtResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::FundPsbt(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendpsbtResponse {
	    pub tx: String,
	    pub txid: String,
	}

	impl TryFrom<Response> for SendpsbtResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SendPsbt(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SignpsbtResponse {
	    pub signed_psbt: String,
	}

	impl TryFrom<Response> for SignpsbtResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SignPsbt(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct UtxopsbtReservations {
	    pub reserved: bool,
	    pub reserved_to_block: u32,
	    pub txid: String,
	    pub vout: u32,
	    pub was_reserved: bool,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct UtxopsbtResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub change_outnum: Option<u32>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub reservations: Option<Vec<UtxopsbtReservations>>,
	    pub estimated_final_weight: u32,
	    pub excess_msat: Amount,
	    pub feerate_per_kw: u32,
	    pub psbt: String,
	}

	impl TryFrom<Response> for UtxopsbtResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::UtxoPsbt(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct TxdiscardResponse {
	    pub txid: String,
	    pub unsigned_tx: String,
	}

	impl TryFrom<Response> for TxdiscardResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::TxDiscard(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct TxprepareResponse {
	    pub psbt: String,
	    pub txid: String,
	    pub unsigned_tx: String,
	}

	impl TryFrom<Response> for TxprepareResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::TxPrepare(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct TxsendResponse {
	    pub psbt: String,
	    pub tx: String,
	    pub txid: String,
	}

	impl TryFrom<Response> for TxsendResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::TxSend(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeerchannelsChannelsAlias {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub local: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub remote: Option<ShortChannelId>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeerchannelsChannelsFeerate {
	    pub perkb: u32,
	    pub perkw: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeerchannelsChannelsFunding {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_paid_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_rcvd_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub pushed_msat: Option<Amount>,
	    pub local_funds_msat: Amount,
	    pub remote_funds_msat: Amount,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeerchannelsChannelsUpdatesRemote {
	    pub cltv_expiry_delta: u32,
	    pub fee_base_msat: Amount,
	    pub fee_proportional_millionths: u32,
	    pub htlc_maximum_msat: Amount,
	    pub htlc_minimum_msat: Amount,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeerchannelsChannelsUpdatesLocal {
	    pub cltv_expiry_delta: u32,
	    pub fee_base_msat: Amount,
	    pub fee_proportional_millionths: u32,
	    pub htlc_maximum_msat: Amount,
	    pub htlc_minimum_msat: Amount,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeerchannelsChannelsUpdates {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub remote: Option<ListpeerchannelsChannelsUpdatesRemote>,
	    pub local: ListpeerchannelsChannelsUpdatesLocal,
	}

	/// ['Whether it came from peer, or is going to peer.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListpeerchannelsChannelsHtlcsDirection {
	    #[serde(rename = "in")]
	    IN = 0,
	    #[serde(rename = "out")]
	    OUT = 1,
	}

	impl TryFrom<i32> for ListpeerchannelsChannelsHtlcsDirection {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListpeerchannelsChannelsHtlcsDirection, anyhow::Error> {
	        match c {
	    0 => Ok(ListpeerchannelsChannelsHtlcsDirection::IN),
	    1 => Ok(ListpeerchannelsChannelsHtlcsDirection::OUT),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListpeerchannelsChannelsHtlcsDirection", o)),
	        }
	    }
	}

	impl ToString for ListpeerchannelsChannelsHtlcsDirection {
	    fn to_string(&self) -> String {
	        match self {
	            ListpeerchannelsChannelsHtlcsDirection::IN => "IN",
	            ListpeerchannelsChannelsHtlcsDirection::OUT => "OUT",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeerchannelsChannelsHtlcs {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub local_trimmed: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub status: Option<String>,
	    // Path `ListPeerChannels.channels[].htlcs[].direction`
	    pub direction: ListpeerchannelsChannelsHtlcsDirection,
	    // Path `ListPeerChannels.channels[].htlcs[].state`
	    pub state: HtlcState,
	    pub amount_msat: Amount,
	    pub expiry: u32,
	    pub id: u64,
	    pub payment_hash: Sha256,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeerchannelsChannelsInflight {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub scratch_txid: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub splice_amount: Option<i64>,
	    pub feerate: String,
	    pub funding_outnum: u32,
	    pub funding_txid: String,
	    pub our_funding_msat: Amount,
	    pub total_funding_msat: Amount,
	}

	/// ['The channel state, in particular `CHANNELD_NORMAL` means the channel can be used normally.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListpeerchannelsChannelsState {
	    #[serde(rename = "OPENINGD")]
	    OPENINGD = 0,
	    #[serde(rename = "CHANNELD_AWAITING_LOCKIN")]
	    CHANNELD_AWAITING_LOCKIN = 1,
	    #[serde(rename = "CHANNELD_NORMAL")]
	    CHANNELD_NORMAL = 2,
	    #[serde(rename = "CHANNELD_SHUTTING_DOWN")]
	    CHANNELD_SHUTTING_DOWN = 3,
	    #[serde(rename = "CLOSINGD_SIGEXCHANGE")]
	    CLOSINGD_SIGEXCHANGE = 4,
	    #[serde(rename = "CLOSINGD_COMPLETE")]
	    CLOSINGD_COMPLETE = 5,
	    #[serde(rename = "AWAITING_UNILATERAL")]
	    AWAITING_UNILATERAL = 6,
	    #[serde(rename = "FUNDING_SPEND_SEEN")]
	    FUNDING_SPEND_SEEN = 7,
	    #[serde(rename = "ONCHAIN")]
	    ONCHAIN = 8,
	    #[serde(rename = "DUALOPEND_OPEN_INIT")]
	    DUALOPEND_OPEN_INIT = 9,
	    #[serde(rename = "DUALOPEND_AWAITING_LOCKIN")]
	    DUALOPEND_AWAITING_LOCKIN = 10,
	    #[serde(rename = "CHANNELD_AWAITING_SPLICE")]
	    CHANNELD_AWAITING_SPLICE = 11,
	    #[serde(rename = "DUALOPEND_OPEN_COMMITTED")]
	    DUALOPEND_OPEN_COMMITTED = 12,
	    #[serde(rename = "DUALOPEND_OPEN_COMMIT_READY")]
	    DUALOPEND_OPEN_COMMIT_READY = 13,
	}

	impl TryFrom<i32> for ListpeerchannelsChannelsState {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListpeerchannelsChannelsState, anyhow::Error> {
	        match c {
	    0 => Ok(ListpeerchannelsChannelsState::OPENINGD),
	    1 => Ok(ListpeerchannelsChannelsState::CHANNELD_AWAITING_LOCKIN),
	    2 => Ok(ListpeerchannelsChannelsState::CHANNELD_NORMAL),
	    3 => Ok(ListpeerchannelsChannelsState::CHANNELD_SHUTTING_DOWN),
	    4 => Ok(ListpeerchannelsChannelsState::CLOSINGD_SIGEXCHANGE),
	    5 => Ok(ListpeerchannelsChannelsState::CLOSINGD_COMPLETE),
	    6 => Ok(ListpeerchannelsChannelsState::AWAITING_UNILATERAL),
	    7 => Ok(ListpeerchannelsChannelsState::FUNDING_SPEND_SEEN),
	    8 => Ok(ListpeerchannelsChannelsState::ONCHAIN),
	    9 => Ok(ListpeerchannelsChannelsState::DUALOPEND_OPEN_INIT),
	    10 => Ok(ListpeerchannelsChannelsState::DUALOPEND_AWAITING_LOCKIN),
	    11 => Ok(ListpeerchannelsChannelsState::CHANNELD_AWAITING_SPLICE),
	    12 => Ok(ListpeerchannelsChannelsState::DUALOPEND_OPEN_COMMITTED),
	    13 => Ok(ListpeerchannelsChannelsState::DUALOPEND_OPEN_COMMIT_READY),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListpeerchannelsChannelsState", o)),
	        }
	    }
	}

	impl ToString for ListpeerchannelsChannelsState {
	    fn to_string(&self) -> String {
	        match self {
	            ListpeerchannelsChannelsState::OPENINGD => "OPENINGD",
	            ListpeerchannelsChannelsState::CHANNELD_AWAITING_LOCKIN => "CHANNELD_AWAITING_LOCKIN",
	            ListpeerchannelsChannelsState::CHANNELD_NORMAL => "CHANNELD_NORMAL",
	            ListpeerchannelsChannelsState::CHANNELD_SHUTTING_DOWN => "CHANNELD_SHUTTING_DOWN",
	            ListpeerchannelsChannelsState::CLOSINGD_SIGEXCHANGE => "CLOSINGD_SIGEXCHANGE",
	            ListpeerchannelsChannelsState::CLOSINGD_COMPLETE => "CLOSINGD_COMPLETE",
	            ListpeerchannelsChannelsState::AWAITING_UNILATERAL => "AWAITING_UNILATERAL",
	            ListpeerchannelsChannelsState::FUNDING_SPEND_SEEN => "FUNDING_SPEND_SEEN",
	            ListpeerchannelsChannelsState::ONCHAIN => "ONCHAIN",
	            ListpeerchannelsChannelsState::DUALOPEND_OPEN_INIT => "DUALOPEND_OPEN_INIT",
	            ListpeerchannelsChannelsState::DUALOPEND_AWAITING_LOCKIN => "DUALOPEND_AWAITING_LOCKIN",
	            ListpeerchannelsChannelsState::CHANNELD_AWAITING_SPLICE => "CHANNELD_AWAITING_SPLICE",
	            ListpeerchannelsChannelsState::DUALOPEND_OPEN_COMMITTED => "DUALOPEND_OPEN_COMMITTED",
	            ListpeerchannelsChannelsState::DUALOPEND_OPEN_COMMIT_READY => "DUALOPEND_OPEN_COMMIT_READY",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeerchannelsChannels {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub alias: Option<ListpeerchannelsChannelsAlias>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub channel_id: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub close_to: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub close_to_addr: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub closer: Option<ChannelSide>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub direction: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub dust_limit_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_base_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_proportional_millionths: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feerate: Option<ListpeerchannelsChannelsFeerate>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding: Option<ListpeerchannelsChannelsFunding>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_outnum: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_txid: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub ignore_fee_limits: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub in_fulfilled_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub in_offered_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub in_payments_fulfilled: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub in_payments_offered: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub initial_feerate: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub last_feerate: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub last_stable_connection: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub last_tx_fee_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub lost_state: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub max_accepted_htlcs: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub max_to_us_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub max_total_htlc_in_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub maximum_htlc_out_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub min_to_us_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub minimum_htlc_in_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub minimum_htlc_out_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub next_fee_step: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub next_feerate: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub our_reserve_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub our_to_self_delay: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_fulfilled_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_offered_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_payments_fulfilled: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_payments_offered: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub owner: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub private: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub receivable_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub reestablished: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub scratch_txid: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub short_channel_id: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub spendable_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub their_reserve_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub their_to_self_delay: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub to_us_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub total_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub updates: Option<ListpeerchannelsChannelsUpdates>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub htlcs: Option<Vec<ListpeerchannelsChannelsHtlcs>>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub inflight: Option<Vec<ListpeerchannelsChannelsInflight>>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub status: Option<Vec<String>>,
	    // Path `ListPeerChannels.channels[].opener`
	    pub opener: ChannelSide,
	    // Path `ListPeerChannels.channels[].state`
	    pub state: ListpeerchannelsChannelsState,
	    pub peer_connected: bool,
	    pub peer_id: PublicKey,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeerchannelsResponse {
	    pub channels: Vec<ListpeerchannelsChannels>,
	}

	impl TryFrom<Response> for ListpeerchannelsResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListPeerChannels(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListclosedchannelsClosedchannelsAlias {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub local: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub remote: Option<ShortChannelId>,
	}

	/// ['What caused the channel to close.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListclosedchannelsClosedchannelsClose_cause {
	    #[serde(rename = "unknown")]
	    UNKNOWN = 0,
	    #[serde(rename = "local")]
	    LOCAL = 1,
	    #[serde(rename = "user")]
	    USER = 2,
	    #[serde(rename = "remote")]
	    REMOTE = 3,
	    #[serde(rename = "protocol")]
	    PROTOCOL = 4,
	    #[serde(rename = "onchain")]
	    ONCHAIN = 5,
	}

	impl TryFrom<i32> for ListclosedchannelsClosedchannelsClose_cause {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListclosedchannelsClosedchannelsClose_cause, anyhow::Error> {
	        match c {
	    0 => Ok(ListclosedchannelsClosedchannelsClose_cause::UNKNOWN),
	    1 => Ok(ListclosedchannelsClosedchannelsClose_cause::LOCAL),
	    2 => Ok(ListclosedchannelsClosedchannelsClose_cause::USER),
	    3 => Ok(ListclosedchannelsClosedchannelsClose_cause::REMOTE),
	    4 => Ok(ListclosedchannelsClosedchannelsClose_cause::PROTOCOL),
	    5 => Ok(ListclosedchannelsClosedchannelsClose_cause::ONCHAIN),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListclosedchannelsClosedchannelsClose_cause", o)),
	        }
	    }
	}

	impl ToString for ListclosedchannelsClosedchannelsClose_cause {
	    fn to_string(&self) -> String {
	        match self {
	            ListclosedchannelsClosedchannelsClose_cause::UNKNOWN => "UNKNOWN",
	            ListclosedchannelsClosedchannelsClose_cause::LOCAL => "LOCAL",
	            ListclosedchannelsClosedchannelsClose_cause::USER => "USER",
	            ListclosedchannelsClosedchannelsClose_cause::REMOTE => "REMOTE",
	            ListclosedchannelsClosedchannelsClose_cause::PROTOCOL => "PROTOCOL",
	            ListclosedchannelsClosedchannelsClose_cause::ONCHAIN => "ONCHAIN",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListclosedchannelsClosedchannels {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub alias: Option<ListclosedchannelsClosedchannelsAlias>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub closer: Option<ChannelSide>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_fee_paid_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_fee_rcvd_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_pushed_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub last_commitment_fee_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub last_commitment_txid: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub last_stable_connection: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub peer_id: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub short_channel_id: Option<ShortChannelId>,
	    // Path `ListClosedChannels.closedchannels[].close_cause`
	    pub close_cause: ListclosedchannelsClosedchannelsClose_cause,
	    // Path `ListClosedChannels.closedchannels[].opener`
	    pub opener: ChannelSide,
	    pub channel_id: Sha256,
	    pub final_to_us_msat: Amount,
	    pub funding_outnum: u32,
	    pub funding_txid: String,
	    pub leased: bool,
	    pub max_to_us_msat: Amount,
	    pub min_to_us_msat: Amount,
	    pub private: bool,
	    pub total_htlcs_sent: u64,
	    pub total_local_commitments: u64,
	    pub total_msat: Amount,
	    pub total_remote_commitments: u64,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListclosedchannelsResponse {
	    pub closedchannels: Vec<ListclosedchannelsClosedchannels>,
	}

	impl TryFrom<Response> for ListclosedchannelsResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListClosedChannels(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodepayExtra {
	    pub data: String,
	    pub tag: String,
	}

	/// ['The address type (if known).']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum DecodepayFallbacksType {
	    #[serde(rename = "P2PKH")]
	    P2PKH = 0,
	    #[serde(rename = "P2SH")]
	    P2SH = 1,
	    #[serde(rename = "P2WPKH")]
	    P2WPKH = 2,
	    #[serde(rename = "P2WSH")]
	    P2WSH = 3,
	    #[serde(rename = "P2TR")]
	    P2TR = 4,
	}

	impl TryFrom<i32> for DecodepayFallbacksType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<DecodepayFallbacksType, anyhow::Error> {
	        match c {
	    0 => Ok(DecodepayFallbacksType::P2PKH),
	    1 => Ok(DecodepayFallbacksType::P2SH),
	    2 => Ok(DecodepayFallbacksType::P2WPKH),
	    3 => Ok(DecodepayFallbacksType::P2WSH),
	    4 => Ok(DecodepayFallbacksType::P2TR),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum DecodepayFallbacksType", o)),
	        }
	    }
	}

	impl ToString for DecodepayFallbacksType {
	    fn to_string(&self) -> String {
	        match self {
	            DecodepayFallbacksType::P2PKH => "P2PKH",
	            DecodepayFallbacksType::P2SH => "P2SH",
	            DecodepayFallbacksType::P2WPKH => "P2WPKH",
	            DecodepayFallbacksType::P2WSH => "P2WSH",
	            DecodepayFallbacksType::P2TR => "P2TR",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodepayFallbacks {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub addr: Option<String>,
	    // Path `DecodePay.fallbacks[].type`
	    #[serde(rename = "type")]
	    pub item_type: DecodepayFallbacksType,
	    pub hex: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodepayResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description_hash: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub features: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_metadata: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_secret: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub routes: Option<DecodeRoutehintList>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub extra: Option<Vec<DecodepayExtra>>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub fallbacks: Option<Vec<DecodepayFallbacks>>,
	    pub created_at: u64,
	    pub currency: String,
	    pub expiry: u64,
	    pub min_final_cltv_expiry: u32,
	    pub payee: PublicKey,
	    pub payment_hash: Sha256,
	    pub signature: String,
	}

	impl TryFrom<Response> for DecodepayResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::DecodePay(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeExtra {
	    pub data: String,
	    pub tag: String,
	}

	/// ['The address type (if known).']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum DecodeFallbacksType {
	    #[serde(rename = "P2PKH")]
	    P2PKH = 0,
	    #[serde(rename = "P2SH")]
	    P2SH = 1,
	    #[serde(rename = "P2WPKH")]
	    P2WPKH = 2,
	    #[serde(rename = "P2WSH")]
	    P2WSH = 3,
	    #[serde(rename = "P2TR")]
	    P2TR = 4,
	}

	impl TryFrom<i32> for DecodeFallbacksType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<DecodeFallbacksType, anyhow::Error> {
	        match c {
	    0 => Ok(DecodeFallbacksType::P2PKH),
	    1 => Ok(DecodeFallbacksType::P2SH),
	    2 => Ok(DecodeFallbacksType::P2WPKH),
	    3 => Ok(DecodeFallbacksType::P2WSH),
	    4 => Ok(DecodeFallbacksType::P2TR),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum DecodeFallbacksType", o)),
	        }
	    }
	}

	impl ToString for DecodeFallbacksType {
	    fn to_string(&self) -> String {
	        match self {
	            DecodeFallbacksType::P2PKH => "P2PKH",
	            DecodeFallbacksType::P2SH => "P2SH",
	            DecodeFallbacksType::P2WPKH => "P2WPKH",
	            DecodeFallbacksType::P2WSH => "P2WSH",
	            DecodeFallbacksType::P2TR => "P2TR",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeFallbacks {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub addr: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_invoice_fallbacks_version_invalid: Option<String>,
	    // Path `Decode.fallbacks[].type`
	    #[serde(rename = "type")]
	    pub item_type: DecodeFallbacksType,
	    pub hex: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeInvoice_fallbacks {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub address: Option<String>,
	    pub hex: String,
	    pub version: u8,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeOffer_paths {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub first_node_id: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub first_scid: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub first_scid_dir: Option<u32>,
	    pub blinding: PublicKey,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeRestrictions {
	    pub alternatives: Vec<String>,
	    pub summary: String,
	}

	/// ['What kind of object it decoded to.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum DecodeType {
	    #[serde(rename = "bolt12 offer")]
	    BOLT12_OFFER = 0,
	    #[serde(rename = "bolt12 invoice")]
	    BOLT12_INVOICE = 1,
	    #[serde(rename = "bolt12 invoice_request")]
	    BOLT12_INVOICE_REQUEST = 2,
	    #[serde(rename = "bolt11 invoice")]
	    BOLT11_INVOICE = 3,
	    #[serde(rename = "rune")]
	    RUNE = 4,
	    #[serde(rename = "emergency recover")]
	    EMERGENCY_RECOVER = 5,
	}

	impl TryFrom<i32> for DecodeType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<DecodeType, anyhow::Error> {
	        match c {
	    0 => Ok(DecodeType::BOLT12_OFFER),
	    1 => Ok(DecodeType::BOLT12_INVOICE),
	    2 => Ok(DecodeType::BOLT12_INVOICE_REQUEST),
	    3 => Ok(DecodeType::BOLT11_INVOICE),
	    4 => Ok(DecodeType::RUNE),
	    5 => Ok(DecodeType::EMERGENCY_RECOVER),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum DecodeType", o)),
	        }
	    }
	}

	impl ToString for DecodeType {
	    fn to_string(&self) -> String {
	        match self {
	            DecodeType::BOLT12_OFFER => "BOLT12_OFFER",
	            DecodeType::BOLT12_INVOICE => "BOLT12_INVOICE",
	            DecodeType::BOLT12_INVOICE_REQUEST => "BOLT12_INVOICE_REQUEST",
	            DecodeType::BOLT11_INVOICE => "BOLT11_INVOICE",
	            DecodeType::RUNE => "RUNE",
	            DecodeType::EMERGENCY_RECOVER => "EMERGENCY_RECOVER",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub currency: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub currency_minor_unit: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub decrypted: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description_hash: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub expiry: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub features: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub hex: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invoice_amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invoice_created_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invoice_features: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invoice_node_id: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invoice_payment_hash: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invoice_recurrence_basetime: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invoice_relative_expiry: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_chain: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_features: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_metadata: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_payer_id: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_payer_note: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_quantity: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_recurrence_counter: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_recurrence_start: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub min_final_cltv_expiry: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_absolute_expiry: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_amount: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_currency: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_features: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_id: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_issuer: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_metadata: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_node_id: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_quantity_max: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payee: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_hash: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_metadata: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_secret: Option<Secret>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub routes: Option<DecodeRoutehintList>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub signature: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub string: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub unique_id: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub version: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_invalid_invoice_request_signature: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_invalid_invoice_signature: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_invalid_invreq_payer_note: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_invalid_offer_currency: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_invalid_offer_description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_invalid_offer_issuer: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invoice_amount: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invoice_blindedpay: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invoice_created_at: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invoice_node_id: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invoice_paths: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invoice_payment_hash: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invoice_recurrence_basetime: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invoice_request_signature: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invoice_signature: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invreq_metadata: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invreq_payer_id: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_offer_description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_offer_node_id: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_rune_invalid_utf8: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_unknown_offer_currency: Option<String>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub extra: Option<Vec<DecodeExtra>>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub fallbacks: Option<Vec<DecodeFallbacks>>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub invoice_fallbacks: Option<Vec<DecodeInvoice_fallbacks>>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub offer_chains: Option<Vec<Sha256>>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub offer_paths: Option<Vec<DecodeOffer_paths>>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub restrictions: Option<Vec<DecodeRestrictions>>,
	    // Path `Decode.type`
	    #[serde(rename = "type")]
	    pub item_type: DecodeType,
	    pub valid: bool,
	}

	impl TryFrom<Response> for DecodeResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Decode(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Status of the payment.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum DelpayPaymentsStatus {
	    #[serde(rename = "pending")]
	    PENDING = 0,
	    #[serde(rename = "failed")]
	    FAILED = 1,
	    #[serde(rename = "complete")]
	    COMPLETE = 2,
	}

	impl TryFrom<i32> for DelpayPaymentsStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<DelpayPaymentsStatus, anyhow::Error> {
	        match c {
	    0 => Ok(DelpayPaymentsStatus::PENDING),
	    1 => Ok(DelpayPaymentsStatus::FAILED),
	    2 => Ok(DelpayPaymentsStatus::COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum DelpayPaymentsStatus", o)),
	        }
	    }
	}

	impl ToString for DelpayPaymentsStatus {
	    fn to_string(&self) -> String {
	        match self {
	            DelpayPaymentsStatus::PENDING => "PENDING",
	            DelpayPaymentsStatus::FAILED => "FAILED",
	            DelpayPaymentsStatus::COMPLETE => "COMPLETE",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DelpayPayments {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub completed_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub erroronion: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub groupid: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub updated_index: Option<u64>,
	    // Path `DelPay.payments[].status`
	    pub status: DelpayPaymentsStatus,
	    pub amount_sent_msat: Amount,
	    pub created_at: u64,
	    pub id: u64,
	    pub payment_hash: Sha256,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DelpayResponse {
	    pub payments: Vec<DelpayPayments>,
	}

	impl TryFrom<Response> for DelpayResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::DelPay(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DelforwardResponse {
	}

	impl TryFrom<Response> for DelforwardResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::DelForward(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DisableofferResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    pub active: bool,
	    pub bolt12: String,
	    pub offer_id: Sha256,
	    pub single_use: bool,
	    pub used: bool,
	}

	impl TryFrom<Response> for DisableofferResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::DisableOffer(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DisconnectResponse {
	}

	impl TryFrom<Response> for DisconnectResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Disconnect(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FeeratesOnchain_fee_estimates {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub unilateral_close_nonanchor_satoshis: Option<u64>,
	    pub htlc_success_satoshis: u64,
	    pub htlc_timeout_satoshis: u64,
	    pub mutual_close_satoshis: u64,
	    pub opening_channel_satoshis: u64,
	    pub unilateral_close_satoshis: u64,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FeeratesPerkbEstimates {
	    pub blockcount: u32,
	    pub feerate: u32,
	    pub smoothed_feerate: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FeeratesPerkb {
	    #[deprecated]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub delayed_to_us: Option<u32>,
	    #[deprecated]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub htlc_resolution: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub floor: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub mutual_close: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub opening: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub penalty: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub unilateral_anchor_close: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub unilateral_close: Option<u32>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub estimates: Option<Vec<FeeratesPerkbEstimates>>,
	    pub max_acceptable: u32,
	    pub min_acceptable: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FeeratesPerkwEstimates {
	    pub blockcount: u32,
	    pub feerate: u32,
	    pub smoothed_feerate: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FeeratesPerkw {
	    #[deprecated]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub delayed_to_us: Option<u32>,
	    #[deprecated]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub htlc_resolution: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub floor: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub mutual_close: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub opening: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub penalty: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub unilateral_anchor_close: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub unilateral_close: Option<u32>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub estimates: Option<Vec<FeeratesPerkwEstimates>>,
	    pub max_acceptable: u32,
	    pub min_acceptable: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FeeratesResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub onchain_fee_estimates: Option<FeeratesOnchain_fee_estimates>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub perkb: Option<FeeratesPerkb>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub perkw: Option<FeeratesPerkw>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_feerates: Option<String>,
	}

	impl TryFrom<Response> for FeeratesResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Feerates(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FetchinvoiceNext_period {
	    pub counter: u64,
	    pub endtime: u64,
	    pub paywindow_end: u64,
	    pub paywindow_start: u64,
	    pub starttime: u64,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FetchinvoiceChanges {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description_appended: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub vendor: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub vendor_removed: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FetchinvoiceResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub next_period: Option<FetchinvoiceNext_period>,
	    pub changes: FetchinvoiceChanges,
	    pub invoice: String,
	}

	impl TryFrom<Response> for FetchinvoiceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::FetchInvoice(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct Fundchannel_cancelResponse {
	    pub cancelled: String,
	}

	impl TryFrom<Response> for Fundchannel_cancelResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::FundChannel_Cancel(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct Fundchannel_completeResponse {
	    pub channel_id: Sha256,
	    pub commitments_secured: bool,
	}

	impl TryFrom<Response> for Fundchannel_completeResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::FundChannel_Complete(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FundchannelChannel_type {
	    pub bits: Vec<u32>,
	    pub names: Vec<ChannelTypeName>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FundchannelResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub channel_type: Option<FundchannelChannel_type>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub close_to: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub mindepth: Option<u32>,
	    pub channel_id: Sha256,
	    pub outnum: u32,
	    pub tx: String,
	    pub txid: String,
	}

	impl TryFrom<Response> for FundchannelResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::FundChannel(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct Fundchannel_startChannel_type {
	    pub bits: Vec<u32>,
	    pub names: Vec<ChannelTypeName>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct Fundchannel_startResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub channel_type: Option<Fundchannel_startChannel_type>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub close_to: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub mindepth: Option<u32>,
	    pub funding_address: String,
	    pub scriptpubkey: String,
	    pub warning_usage: String,
	}

	impl TryFrom<Response> for Fundchannel_startResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::FundChannel_Start(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum GetlogLogType {
	    #[serde(rename = "SKIPPED")]
	    SKIPPED = 0,
	    #[serde(rename = "BROKEN")]
	    BROKEN = 1,
	    #[serde(rename = "UNUSUAL")]
	    UNUSUAL = 2,
	    #[serde(rename = "INFO")]
	    INFO = 3,
	    #[serde(rename = "DEBUG")]
	    DEBUG = 4,
	    #[serde(rename = "IO_IN")]
	    IO_IN = 5,
	    #[serde(rename = "IO_OUT")]
	    IO_OUT = 6,
	    #[serde(rename = "TRACE")]
	    TRACE = 7,
	}

	impl TryFrom<i32> for GetlogLogType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<GetlogLogType, anyhow::Error> {
	        match c {
	    0 => Ok(GetlogLogType::SKIPPED),
	    1 => Ok(GetlogLogType::BROKEN),
	    2 => Ok(GetlogLogType::UNUSUAL),
	    3 => Ok(GetlogLogType::INFO),
	    4 => Ok(GetlogLogType::DEBUG),
	    5 => Ok(GetlogLogType::IO_IN),
	    6 => Ok(GetlogLogType::IO_OUT),
	    7 => Ok(GetlogLogType::TRACE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum GetlogLogType", o)),
	        }
	    }
	}

	impl ToString for GetlogLogType {
	    fn to_string(&self) -> String {
	        match self {
	            GetlogLogType::SKIPPED => "SKIPPED",
	            GetlogLogType::BROKEN => "BROKEN",
	            GetlogLogType::UNUSUAL => "UNUSUAL",
	            GetlogLogType::INFO => "INFO",
	            GetlogLogType::DEBUG => "DEBUG",
	            GetlogLogType::TRACE => "TRACE",
	            GetlogLogType::IO_IN => "IO_IN",
	            GetlogLogType::IO_OUT => "IO_OUT",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetlogLog {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub data: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub log: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub node_id: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub num_skipped: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub source: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub time: Option<String>,
	    // Path `GetLog.log[].type`
	    #[serde(rename = "type")]
	    pub item_type: GetlogLogType,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetlogResponse {
	    pub bytes_max: u32,
	    pub bytes_used: u32,
	    pub created_at: String,
	    pub log: Vec<GetlogLog>,
	}

	impl TryFrom<Response> for GetlogResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::GetLog(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Policy funder plugin will use to decide how much capital to commit to a v2 open channel request.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum FunderupdatePolicy {
	    #[serde(rename = "match")]
	    MATCH = 0,
	    #[serde(rename = "available")]
	    AVAILABLE = 1,
	    #[serde(rename = "fixed")]
	    FIXED = 2,
	}

	impl TryFrom<i32> for FunderupdatePolicy {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<FunderupdatePolicy, anyhow::Error> {
	        match c {
	    0 => Ok(FunderupdatePolicy::MATCH),
	    1 => Ok(FunderupdatePolicy::AVAILABLE),
	    2 => Ok(FunderupdatePolicy::FIXED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum FunderupdatePolicy", o)),
	        }
	    }
	}

	impl ToString for FunderupdatePolicy {
	    fn to_string(&self) -> String {
	        match self {
	            FunderupdatePolicy::MATCH => "MATCH",
	            FunderupdatePolicy::AVAILABLE => "AVAILABLE",
	            FunderupdatePolicy::FIXED => "FIXED",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FunderupdateResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub channel_fee_max_base_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub channel_fee_max_proportional_thousandths: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub compact_lease: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_weight: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub lease_fee_base_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub lease_fee_basis: Option<u32>,
	    // Path `FunderUpdate.policy`
	    pub policy: FunderupdatePolicy,
	    pub fund_probability: u32,
	    pub fuzz_percent: u32,
	    pub leases_only: bool,
	    pub max_their_funding_msat: Amount,
	    pub min_their_funding_msat: Amount,
	    pub per_channel_max_msat: Amount,
	    pub per_channel_min_msat: Amount,
	    pub policy_mod: u32,
	    pub reserve_tank_msat: Amount,
	    pub summary: String,
	}

	impl TryFrom<Response> for FunderupdateResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::FunderUpdate(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['The features understood by the destination node.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum GetrouteRouteStyle {
	    #[serde(rename = "tlv")]
	    TLV = 0,
	}

	impl TryFrom<i32> for GetrouteRouteStyle {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<GetrouteRouteStyle, anyhow::Error> {
	        match c {
	    0 => Ok(GetrouteRouteStyle::TLV),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum GetrouteRouteStyle", o)),
	        }
	    }
	}

	impl ToString for GetrouteRouteStyle {
	    fn to_string(&self) -> String {
	        match self {
	            GetrouteRouteStyle::TLV => "TLV",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetrouteRoute {
	    // Path `GetRoute.route[].style`
	    pub style: GetrouteRouteStyle,
	    pub amount_msat: Amount,
	    pub channel: ShortChannelId,
	    pub delay: u32,
	    pub direction: u32,
	    pub id: PublicKey,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetrouteResponse {
	    pub route: Vec<GetrouteRoute>,
	}

	impl TryFrom<Response> for GetrouteResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::GetRoute(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Either a legacy onion format or a modern tlv format.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListforwardsForwardsStyle {
	    #[serde(rename = "legacy")]
	    LEGACY = 0,
	    #[serde(rename = "tlv")]
	    TLV = 1,
	}

	impl TryFrom<i32> for ListforwardsForwardsStyle {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListforwardsForwardsStyle, anyhow::Error> {
	        match c {
	    0 => Ok(ListforwardsForwardsStyle::LEGACY),
	    1 => Ok(ListforwardsForwardsStyle::TLV),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListforwardsForwardsStyle", o)),
	        }
	    }
	}

	impl ToString for ListforwardsForwardsStyle {
	    fn to_string(&self) -> String {
	        match self {
	            ListforwardsForwardsStyle::LEGACY => "LEGACY",
	            ListforwardsForwardsStyle::TLV => "TLV",
	        }.to_string()
	    }
	}

	/// ['Still ongoing, completed, failed locally, or failed after forwarding.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListforwardsForwardsStatus {
	    #[serde(rename = "offered")]
	    OFFERED = 0,
	    #[serde(rename = "settled")]
	    SETTLED = 1,
	    #[serde(rename = "local_failed")]
	    LOCAL_FAILED = 2,
	    #[serde(rename = "failed")]
	    FAILED = 3,
	}

	impl TryFrom<i32> for ListforwardsForwardsStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListforwardsForwardsStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListforwardsForwardsStatus::OFFERED),
	    1 => Ok(ListforwardsForwardsStatus::SETTLED),
	    2 => Ok(ListforwardsForwardsStatus::LOCAL_FAILED),
	    3 => Ok(ListforwardsForwardsStatus::FAILED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListforwardsForwardsStatus", o)),
	        }
	    }
	}

	impl ToString for ListforwardsForwardsStatus {
	    fn to_string(&self) -> String {
	        match self {
	            ListforwardsForwardsStatus::OFFERED => "OFFERED",
	            ListforwardsForwardsStatus::SETTLED => "SETTLED",
	            ListforwardsForwardsStatus::LOCAL_FAILED => "LOCAL_FAILED",
	            ListforwardsForwardsStatus::FAILED => "FAILED",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListforwardsForwards {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub failcode: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub failreason: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub in_htlc_id: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_channel: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_htlc_id: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub resolved_time: Option<f64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub style: Option<ListforwardsForwardsStyle>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub updated_index: Option<u64>,
	    // Path `ListForwards.forwards[].status`
	    pub status: ListforwardsForwardsStatus,
	    pub in_channel: ShortChannelId,
	    pub in_msat: Amount,
	    pub received_time: f64,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListforwardsResponse {
	    pub forwards: Vec<ListforwardsForwards>,
	}

	impl TryFrom<Response> for ListforwardsResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListForwards(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListoffersOffers {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    pub active: bool,
	    pub bolt12: String,
	    pub offer_id: Sha256,
	    pub single_use: bool,
	    pub used: bool,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListoffersResponse {
	    pub offers: Vec<ListoffersOffers>,
	}

	impl TryFrom<Response> for ListoffersResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListOffers(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Status of the payment.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListpaysPaysStatus {
	    #[serde(rename = "pending")]
	    PENDING = 0,
	    #[serde(rename = "failed")]
	    FAILED = 1,
	    #[serde(rename = "complete")]
	    COMPLETE = 2,
	}

	impl TryFrom<i32> for ListpaysPaysStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListpaysPaysStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListpaysPaysStatus::PENDING),
	    1 => Ok(ListpaysPaysStatus::FAILED),
	    2 => Ok(ListpaysPaysStatus::COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListpaysPaysStatus", o)),
	        }
	    }
	}

	impl ToString for ListpaysPaysStatus {
	    fn to_string(&self) -> String {
	        match self {
	            ListpaysPaysStatus::PENDING => "PENDING",
	            ListpaysPaysStatus::FAILED => "FAILED",
	            ListpaysPaysStatus::COMPLETE => "COMPLETE",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpaysPays {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_sent_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub completed_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub erroronion: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub number_of_parts: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub preimage: Option<Secret>,
	    // Path `ListPays.pays[].status`
	    pub status: ListpaysPaysStatus,
	    pub created_at: u64,
	    pub payment_hash: Sha256,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpaysResponse {
	    pub pays: Vec<ListpaysPays>,
	}

	impl TryFrom<Response> for ListpaysResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListPays(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Out if we offered this to the peer, in if they offered it.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListhtlcsHtlcsDirection {
	    #[serde(rename = "out")]
	    OUT = 0,
	    #[serde(rename = "in")]
	    IN = 1,
	}

	impl TryFrom<i32> for ListhtlcsHtlcsDirection {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListhtlcsHtlcsDirection, anyhow::Error> {
	        match c {
	    0 => Ok(ListhtlcsHtlcsDirection::OUT),
	    1 => Ok(ListhtlcsHtlcsDirection::IN),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListhtlcsHtlcsDirection", o)),
	        }
	    }
	}

	impl ToString for ListhtlcsHtlcsDirection {
	    fn to_string(&self) -> String {
	        match self {
	            ListhtlcsHtlcsDirection::OUT => "OUT",
	            ListhtlcsHtlcsDirection::IN => "IN",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListhtlcsHtlcs {
	    // Path `ListHtlcs.htlcs[].direction`
	    pub direction: ListhtlcsHtlcsDirection,
	    // Path `ListHtlcs.htlcs[].state`
	    pub state: HtlcState,
	    pub amount_msat: Amount,
	    pub expiry: u32,
	    pub id: u64,
	    pub payment_hash: Sha256,
	    pub short_channel_id: ShortChannelId,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListhtlcsResponse {
	    pub htlcs: Vec<ListhtlcsHtlcs>,
	}

	impl TryFrom<Response> for ListhtlcsResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListHtlcs(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['What stage we failed at.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum MultifundchannelFailedMethod {
	    #[serde(rename = "connect")]
	    CONNECT = 0,
	    #[serde(rename = "openchannel_init")]
	    OPENCHANNEL_INIT = 1,
	    #[serde(rename = "fundchannel_start")]
	    FUNDCHANNEL_START = 2,
	    #[serde(rename = "fundchannel_complete")]
	    FUNDCHANNEL_COMPLETE = 3,
	}

	impl TryFrom<i32> for MultifundchannelFailedMethod {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<MultifundchannelFailedMethod, anyhow::Error> {
	        match c {
	    0 => Ok(MultifundchannelFailedMethod::CONNECT),
	    1 => Ok(MultifundchannelFailedMethod::OPENCHANNEL_INIT),
	    2 => Ok(MultifundchannelFailedMethod::FUNDCHANNEL_START),
	    3 => Ok(MultifundchannelFailedMethod::FUNDCHANNEL_COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum MultifundchannelFailedMethod", o)),
	        }
	    }
	}

	impl ToString for MultifundchannelFailedMethod {
	    fn to_string(&self) -> String {
	        match self {
	            MultifundchannelFailedMethod::CONNECT => "CONNECT",
	            MultifundchannelFailedMethod::OPENCHANNEL_INIT => "OPENCHANNEL_INIT",
	            MultifundchannelFailedMethod::FUNDCHANNEL_START => "FUNDCHANNEL_START",
	            MultifundchannelFailedMethod::FUNDCHANNEL_COMPLETE => "FUNDCHANNEL_COMPLETE",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct MultifundchannelFailedError {
	    pub code: i64,
	    pub message: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct MultifundchannelFailed {
	    // Path `MultiFundChannel.failed[].method`
	    pub method: MultifundchannelFailedMethod,
	    pub error: MultifundchannelFailedError,
	    pub id: PublicKey,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct MultifundchannelChannel_idsChannel_type {
	    pub bits: Vec<u32>,
	    pub names: Vec<ChannelTypeName>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct MultifundchannelChannel_ids {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub channel_type: Option<MultifundchannelChannel_idsChannel_type>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub close_to: Option<String>,
	    pub channel_id: Sha256,
	    pub id: PublicKey,
	    pub outnum: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct MultifundchannelResponse {
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub failed: Option<Vec<MultifundchannelFailed>>,
	    pub channel_ids: Vec<MultifundchannelChannel_ids>,
	    pub tx: String,
	    pub txid: String,
	}

	impl TryFrom<Response> for MultifundchannelResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::MultiFundChannel(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct MultiwithdrawResponse {
	    pub tx: String,
	    pub txid: String,
	}

	impl TryFrom<Response> for MultiwithdrawResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::MultiWithdraw(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct OfferResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    pub active: bool,
	    pub bolt12: String,
	    pub created: bool,
	    pub offer_id: Sha256,
	    pub single_use: bool,
	    pub used: bool,
	}

	impl TryFrom<Response> for OfferResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Offer(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct Openchannel_abortResponse {
	    pub channel_canceled: bool,
	    pub channel_id: Sha256,
	    pub reason: String,
	}

	impl TryFrom<Response> for Openchannel_abortResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::OpenChannel_Abort(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct Openchannel_bumpChannel_type {
	    pub bits: Vec<u32>,
	    pub names: Vec<ChannelTypeName>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct Openchannel_bumpResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub channel_type: Option<Openchannel_bumpChannel_type>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub requires_confirmed_inputs: Option<bool>,
	    pub channel_id: Sha256,
	    pub commitments_secured: bool,
	    pub funding_serial: u64,
	    pub psbt: String,
	}

	impl TryFrom<Response> for Openchannel_bumpResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::OpenChannel_Bump(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct Openchannel_initChannel_type {
	    pub bits: Vec<u32>,
	    pub names: Vec<ChannelTypeName>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct Openchannel_initResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub channel_type: Option<Openchannel_initChannel_type>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub requires_confirmed_inputs: Option<bool>,
	    pub channel_id: Sha256,
	    pub commitments_secured: bool,
	    pub funding_serial: u64,
	    pub psbt: String,
	}

	impl TryFrom<Response> for Openchannel_initResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::OpenChannel_Init(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct Openchannel_signedResponse {
	    pub channel_id: Sha256,
	    pub tx: String,
	    pub txid: String,
	}

	impl TryFrom<Response> for Openchannel_signedResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::OpenChannel_Signed(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct Openchannel_updateChannel_type {
	    pub bits: Vec<u32>,
	    pub names: Vec<ChannelTypeName>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct Openchannel_updateResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub channel_type: Option<Openchannel_updateChannel_type>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub close_to: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub requires_confirmed_inputs: Option<bool>,
	    pub channel_id: Sha256,
	    pub commitments_secured: bool,
	    pub funding_outnum: u32,
	    pub psbt: String,
	}

	impl TryFrom<Response> for Openchannel_updateResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::OpenChannel_Update(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct PingResponse {
	    pub totlen: u16,
	}

	impl TryFrom<Response> for PingResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Ping(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct PluginPlugins {
	    pub active: bool,
	    pub dynamic: bool,
	    pub name: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct PluginResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub result: Option<String>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub plugins: Option<Vec<PluginPlugins>>,
	    // Path `Plugin.command`
	    pub command: PluginSubcommand,
	}

	impl TryFrom<Response> for PluginResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Plugin(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Status of payment.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum RenepaystatusPaystatusStatus {
	    #[serde(rename = "complete")]
	    COMPLETE = 0,
	    #[serde(rename = "pending")]
	    PENDING = 1,
	    #[serde(rename = "failed")]
	    FAILED = 2,
	}

	impl TryFrom<i32> for RenepaystatusPaystatusStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<RenepaystatusPaystatusStatus, anyhow::Error> {
	        match c {
	    0 => Ok(RenepaystatusPaystatusStatus::COMPLETE),
	    1 => Ok(RenepaystatusPaystatusStatus::PENDING),
	    2 => Ok(RenepaystatusPaystatusStatus::FAILED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum RenepaystatusPaystatusStatus", o)),
	        }
	    }
	}

	impl ToString for RenepaystatusPaystatusStatus {
	    fn to_string(&self) -> String {
	        match self {
	            RenepaystatusPaystatusStatus::COMPLETE => "COMPLETE",
	            RenepaystatusPaystatusStatus::PENDING => "PENDING",
	            RenepaystatusPaystatusStatus::FAILED => "FAILED",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct RenepaystatusPaystatus {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_sent_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub parts: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	    // Path `RenePayStatus.paystatus[].status`
	    pub status: RenepaystatusPaystatusStatus,
	    pub amount_msat: Amount,
	    pub bolt11: String,
	    pub created_at: f64,
	    pub groupid: u32,
	    pub notes: Vec<String>,
	    pub payment_hash: Sha256,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct RenepaystatusResponse {
	    pub paystatus: Vec<RenepaystatusPaystatus>,
	}

	impl TryFrom<Response> for RenepaystatusResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::RenePayStatus(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Status of payment.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum RenepayStatus {
	    #[serde(rename = "complete")]
	    COMPLETE = 0,
	    #[serde(rename = "pending")]
	    PENDING = 1,
	    #[serde(rename = "failed")]
	    FAILED = 2,
	}

	impl TryFrom<i32> for RenepayStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<RenepayStatus, anyhow::Error> {
	        match c {
	    0 => Ok(RenepayStatus::COMPLETE),
	    1 => Ok(RenepayStatus::PENDING),
	    2 => Ok(RenepayStatus::FAILED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum RenepayStatus", o)),
	        }
	    }
	}

	impl ToString for RenepayStatus {
	    fn to_string(&self) -> String {
	        match self {
	            RenepayStatus::COMPLETE => "COMPLETE",
	            RenepayStatus::PENDING => "PENDING",
	            RenepayStatus::FAILED => "FAILED",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct RenepayResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    // Path `RenePay.status`
	    pub status: RenepayStatus,
	    pub amount_msat: Amount,
	    pub amount_sent_msat: Amount,
	    pub created_at: f64,
	    pub parts: u32,
	    pub payment_hash: Sha256,
	    pub payment_preimage: Secret,
	}

	impl TryFrom<Response> for RenepayResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::RenePay(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ReserveinputsReservations {
	    pub reserved: bool,
	    pub reserved_to_block: u32,
	    pub txid: String,
	    pub vout: u32,
	    pub was_reserved: bool,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ReserveinputsResponse {
	    pub reservations: Vec<ReserveinputsReservations>,
	}

	impl TryFrom<Response> for ReserveinputsResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ReserveInputs(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendcustommsgResponse {
	    pub status: String,
	}

	impl TryFrom<Response> for SendcustommsgResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SendCustomMsg(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ["Whether it's paid, unpaid or unpayable."]
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum SendinvoiceStatus {
	    #[serde(rename = "unpaid")]
	    UNPAID = 0,
	    #[serde(rename = "paid")]
	    PAID = 1,
	    #[serde(rename = "expired")]
	    EXPIRED = 2,
	}

	impl TryFrom<i32> for SendinvoiceStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<SendinvoiceStatus, anyhow::Error> {
	        match c {
	    0 => Ok(SendinvoiceStatus::UNPAID),
	    1 => Ok(SendinvoiceStatus::PAID),
	    2 => Ok(SendinvoiceStatus::EXPIRED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum SendinvoiceStatus", o)),
	        }
	    }
	}

	impl ToString for SendinvoiceStatus {
	    fn to_string(&self) -> String {
	        match self {
	            SendinvoiceStatus::UNPAID => "UNPAID",
	            SendinvoiceStatus::PAID => "PAID",
	            SendinvoiceStatus::EXPIRED => "EXPIRED",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendinvoiceResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_received_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub paid_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub pay_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub updated_index: Option<u64>,
	    // Path `SendInvoice.status`
	    pub status: SendinvoiceStatus,
	    pub description: String,
	    pub expires_at: u64,
	    pub label: String,
	    pub payment_hash: Sha256,
	}

	impl TryFrom<Response> for SendinvoiceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SendInvoice(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendonionmessageResponse {
	}

	impl TryFrom<Response> for SendonionmessageResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SendOnionMessage(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SetchannelChannels {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub ignore_fee_limits: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub short_channel_id: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_htlcmax_too_high: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_htlcmin_too_low: Option<String>,
	    pub channel_id: Sha256,
	    pub fee_base_msat: Amount,
	    pub fee_proportional_millionths: u32,
	    pub maximum_htlc_out_msat: Amount,
	    pub minimum_htlc_out_msat: Amount,
	    pub peer_id: PublicKey,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SetchannelResponse {
	    pub channels: Vec<SetchannelChannels>,
	}

	impl TryFrom<Response> for SetchannelResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SetChannel(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SetconfigConfig {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub plugin: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub set: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub value_bool: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub value_int: Option<i64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub value_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub value_str: Option<String>,
	    pub config: String,
	    pub dynamic: bool,
	    pub source: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SetconfigResponse {
	    pub config: SetconfigConfig,
	}

	impl TryFrom<Response> for SetconfigResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SetConfig(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SetpsbtversionResponse {
	    pub psbt: String,
	}

	impl TryFrom<Response> for SetpsbtversionResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SetPsbtVersion(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SigninvoiceResponse {
	    pub bolt11: String,
	}

	impl TryFrom<Response> for SigninvoiceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SignInvoice(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SignmessageResponse {
	    pub recid: String,
	    pub signature: String,
	    pub zbase: String,
	}

	impl TryFrom<Response> for SignmessageResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SignMessage(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct Splice_initResponse {
	    pub psbt: String,
	}

	impl TryFrom<Response> for Splice_initResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Splice_Init(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct Splice_signedResponse {
	    pub tx: String,
	    pub txid: String,
	}

	impl TryFrom<Response> for Splice_signedResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Splice_Signed(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct Splice_updateResponse {
	    pub commitments_secured: bool,
	    pub psbt: String,
	}

	impl TryFrom<Response> for Splice_updateResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Splice_Update(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct UnreserveinputsReservations {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub reserved_to_block: Option<u32>,
	    pub reserved: bool,
	    pub txid: String,
	    pub vout: u32,
	    pub was_reserved: bool,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct UnreserveinputsResponse {
	    pub reservations: Vec<UnreserveinputsReservations>,
	}

	impl TryFrom<Response> for UnreserveinputsResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::UnreserveInputs(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct UpgradewalletResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub psbt: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub tx: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub txid: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub upgraded_outs: Option<u64>,
	}

	impl TryFrom<Response> for UpgradewalletResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::UpgradeWallet(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitblockheightResponse {
	    pub blockheight: u32,
	}

	impl TryFrom<Response> for WaitblockheightResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::WaitBlockHeight(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Status of the payment.', 'Still ongoing, completed, failed locally, or failed after forwarding.', "Whether it's paid, unpaid or unpayable."]
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum WaitDetailsStatus {
	    #[serde(rename = "unpaid")]
	    UNPAID = 0,
	    #[serde(rename = "paid")]
	    PAID = 1,
	    #[serde(rename = "expired")]
	    EXPIRED = 2,
	    #[serde(rename = "pending")]
	    PENDING = 3,
	    #[serde(rename = "failed")]
	    FAILED = 4,
	    #[serde(rename = "complete")]
	    COMPLETE = 5,
	    #[serde(rename = "offered")]
	    OFFERED = 6,
	    #[serde(rename = "settled")]
	    SETTLED = 7,
	    #[serde(rename = "local_failed")]
	    LOCAL_FAILED = 8,
	}

	impl TryFrom<i32> for WaitDetailsStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<WaitDetailsStatus, anyhow::Error> {
	        match c {
	    0 => Ok(WaitDetailsStatus::UNPAID),
	    1 => Ok(WaitDetailsStatus::PAID),
	    2 => Ok(WaitDetailsStatus::EXPIRED),
	    3 => Ok(WaitDetailsStatus::PENDING),
	    4 => Ok(WaitDetailsStatus::FAILED),
	    5 => Ok(WaitDetailsStatus::COMPLETE),
	    6 => Ok(WaitDetailsStatus::OFFERED),
	    7 => Ok(WaitDetailsStatus::SETTLED),
	    8 => Ok(WaitDetailsStatus::LOCAL_FAILED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum WaitDetailsStatus", o)),
	        }
	    }
	}

	impl ToString for WaitDetailsStatus {
	    fn to_string(&self) -> String {
	        match self {
	            WaitDetailsStatus::COMPLETE => "COMPLETE",
	            WaitDetailsStatus::EXPIRED => "EXPIRED",
	            WaitDetailsStatus::FAILED => "FAILED",
	            WaitDetailsStatus::LOCAL_FAILED => "LOCAL_FAILED",
	            WaitDetailsStatus::OFFERED => "OFFERED",
	            WaitDetailsStatus::PAID => "PAID",
	            WaitDetailsStatus::PENDING => "PENDING",
	            WaitDetailsStatus::SETTLED => "SETTLED",
	            WaitDetailsStatus::UNPAID => "UNPAID",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitDetails {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub groupid: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub in_channel: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub in_htlc_id: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub in_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_channel: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_hash: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub status: Option<WaitDetailsStatus>,
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum WaitSubsystem {
	    #[serde(rename = "invoices")]
	    INVOICES = 0,
	    #[serde(rename = "forwards")]
	    FORWARDS = 1,
	    #[serde(rename = "sendpays")]
	    SENDPAYS = 2,
	}

	impl TryFrom<i32> for WaitSubsystem {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<WaitSubsystem, anyhow::Error> {
	        match c {
	    0 => Ok(WaitSubsystem::INVOICES),
	    1 => Ok(WaitSubsystem::FORWARDS),
	    2 => Ok(WaitSubsystem::SENDPAYS),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum WaitSubsystem", o)),
	        }
	    }
	}

	impl ToString for WaitSubsystem {
	    fn to_string(&self) -> String {
	        match self {
	            WaitSubsystem::INVOICES => "INVOICES",
	            WaitSubsystem::FORWARDS => "FORWARDS",
	            WaitSubsystem::SENDPAYS => "SENDPAYS",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub deleted: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub details: Option<WaitDetails>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub updated: Option<u64>,
	    // Path `Wait.subsystem`
	    pub subsystem: WaitSubsystem,
	}

	impl TryFrom<Response> for WaitResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Wait(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsImportantpluginsOptions {
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsImportantplugins {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub options: Option<ListconfigsImportantpluginsOptions>,
	    pub name: String,
	    pub path: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsPluginsOptions {
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsPlugins {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub options: Option<ListconfigsPluginsOptions>,
	    pub name: String,
	    pub path: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsMaxlocktimeblocks {
	    pub source: String,
	    pub value_int: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsAccepthtlctlvtypes {
	    pub source: String,
	    pub value_str: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsAllowdeprecatedapis {
	    pub source: String,
	    pub value_bool: bool,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsAlwaysuseproxy {
	    pub source: String,
	    pub value_bool: bool,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsAnnounceaddr {
	    pub sources: Vec<String>,
	    pub values_str: Vec<String>,
	}

	/// ['Field from config or cmdline, or default.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListconfigsConfigsAnnounceaddrdiscoveredValue_str {
	    #[serde(rename = "true")]
	    TRUE = 0,
	    #[serde(rename = "false")]
	    FALSE = 1,
	    #[serde(rename = "auto")]
	    AUTO = 2,
	}

	impl TryFrom<i32> for ListconfigsConfigsAnnounceaddrdiscoveredValue_str {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListconfigsConfigsAnnounceaddrdiscoveredValue_str, anyhow::Error> {
	        match c {
	    0 => Ok(ListconfigsConfigsAnnounceaddrdiscoveredValue_str::TRUE),
	    1 => Ok(ListconfigsConfigsAnnounceaddrdiscoveredValue_str::FALSE),
	    2 => Ok(ListconfigsConfigsAnnounceaddrdiscoveredValue_str::AUTO),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListconfigsConfigsAnnounceaddrdiscoveredValue_str", o)),
	        }
	    }
	}

	impl ToString for ListconfigsConfigsAnnounceaddrdiscoveredValue_str {
	    fn to_string(&self) -> String {
	        match self {
	            ListconfigsConfigsAnnounceaddrdiscoveredValue_str::TRUE => "TRUE",
	            ListconfigsConfigsAnnounceaddrdiscoveredValue_str::FALSE => "FALSE",
	            ListconfigsConfigsAnnounceaddrdiscoveredValue_str::AUTO => "AUTO",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsAnnounceaddrdiscovered {
	    // Path `ListConfigs.configs.announce-addr-discovered.value_str`
	    pub value_str: ListconfigsConfigsAnnounceaddrdiscoveredValue_str,
	    pub source: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsAnnounceaddrdiscoveredport {
	    pub source: String,
	    pub value_int: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsAnnounceaddrdns {
	    pub source: String,
	    pub value_bool: bool,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsBindaddr {
	    pub sources: Vec<String>,
	    pub values_str: Vec<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsClearplugins {
	    pub set: bool,
	    pub source: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsCltvdelta {
	    pub source: String,
	    pub value_int: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsCltvfinal {
	    pub source: String,
	    pub value_int: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsCommitfee {
	    pub source: String,
	    pub value_int: u64,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsCommitfeerateoffset {
	    pub source: String,
	    pub value_int: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsCommittime {
	    pub source: String,
	    pub value_int: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsDatabaseupgrade {
	    pub source: String,
	    pub value_bool: bool,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsDisabledns {
	    pub set: bool,
	    pub source: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsDisablempp {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub plugin: Option<String>,
	    pub set: bool,
	    pub source: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsDisableplugin {
	    pub sources: Vec<String>,
	    pub values_str: Vec<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsEncryptedhsm {
	    pub set: bool,
	    pub source: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsExperimentalanchors {
	    pub set: bool,
	    pub source: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsExperimentaldualfund {
	    pub set: bool,
	    pub source: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsExperimentaloffers {
	    pub set: bool,
	    pub source: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsExperimentalonionmessages {
	    pub set: bool,
	    pub source: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsExperimentalpeerstorage {
	    pub set: bool,
	    pub source: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsExperimentalshutdownwrongfunding {
	    pub set: bool,
	    pub source: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsExperimentalsplicing {
	    pub set: bool,
	    pub source: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsFeebase {
	    pub source: String,
	    pub value_int: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsFeepersatoshi {
	    pub source: String,
	    pub value_int: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsFetchinvoicenoconnect {
	    pub set: bool,
	    pub source: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsForcefeerates {
	    pub source: String,
	    pub value_str: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsFundingconfirms {
	    pub source: String,
	    pub value_int: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsHtlcmaximummsat {
	    pub source: String,
	    pub value_msat: Amount,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsHtlcminimummsat {
	    pub source: String,
	    pub value_msat: Amount,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsIgnorefeelimits {
	    pub source: String,
	    pub value_bool: bool,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsImportantplugin {
	    pub sources: Vec<String>,
	    pub values_str: Vec<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsLargechannels {
	    pub set: bool,
	    pub source: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsLightningdir {
	    pub source: String,
	    pub value_str: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsLogfile {
	    pub sources: Vec<String>,
	    pub values_str: Vec<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsLoglevel {
	    pub source: String,
	    pub value_str: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsLogprefix {
	    pub source: String,
	    pub value_str: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsLogtimestamps {
	    pub source: String,
	    pub value_bool: bool,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsMaxconcurrenthtlcs {
	    pub source: String,
	    pub value_int: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsMaxdusthtlcexposuremsat {
	    pub source: String,
	    pub value_msat: Amount,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsMincapacitysat {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub dynamic: Option<bool>,
	    pub source: String,
	    pub value_int: u64,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsPidfile {
	    pub source: String,
	    pub value_str: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsPlugindir {
	    pub sources: Vec<String>,
	    pub values_str: Vec<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsRequireconfirmedinputs {
	    pub source: String,
	    pub value_bool: bool,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsRpcfile {
	    pub source: String,
	    pub value_str: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsRpcfilemode {
	    pub source: String,
	    pub value_str: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsTorservicepassword {
	    pub source: String,
	    pub value_str: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsWatchtimeblocks {
	    pub source: String,
	    pub value_int: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsAddr {
	    pub sources: Vec<String>,
	    pub values_str: Vec<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsAlias {
	    pub source: String,
	    pub value_str: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsAutolisten {
	    pub source: String,
	    pub value_bool: bool,
	}

	/// ['Source of configuration setting.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum ListconfigsConfigsConfSource {
	    #[serde(rename = "cmdline")]
	    CMDLINE = 0,
	}

	impl TryFrom<i32> for ListconfigsConfigsConfSource {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListconfigsConfigsConfSource, anyhow::Error> {
	        match c {
	    0 => Ok(ListconfigsConfigsConfSource::CMDLINE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListconfigsConfigsConfSource", o)),
	        }
	    }
	}

	impl ToString for ListconfigsConfigsConfSource {
	    fn to_string(&self) -> String {
	        match self {
	            ListconfigsConfigsConfSource::CMDLINE => "CMDLINE",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsConf {
	    // Path `ListConfigs.configs.conf.source`
	    pub source: ListconfigsConfigsConfSource,
	    pub value_str: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsDaemon {
	    pub set: bool,
	    pub source: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsDeveloper {
	    pub set: bool,
	    pub source: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsMainnet {
	    pub set: bool,
	    pub source: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsNetwork {
	    pub source: String,
	    pub value_str: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsOffline {
	    pub set: bool,
	    pub source: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsPlugin {
	    pub sources: Vec<String>,
	    pub values_str: Vec<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsProxy {
	    pub source: String,
	    pub value_str: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsRegtest {
	    pub set: bool,
	    pub source: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsRescan {
	    pub source: String,
	    pub value_int: i64,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsRgb {
	    pub source: String,
	    pub value_str: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsSignet {
	    pub set: bool,
	    pub source: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsSubdaemon {
	    pub sources: Vec<String>,
	    pub values_str: Vec<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsTestnet {
	    pub set: bool,
	    pub source: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigsWallet {
	    pub source: String,
	    pub value_str: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsConfigs {
	    #[deprecated]
	    #[serde(rename = "max-locktime-blocks")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub max_locktime_blocks: Option<ListconfigsConfigsMaxlocktimeblocks>,
	    #[serde(rename = "accept-htlc-tlv-types")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub accept_htlc_tlv_types: Option<ListconfigsConfigsAccepthtlctlvtypes>,
	    #[serde(rename = "allow-deprecated-apis")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub allow_deprecated_apis: Option<ListconfigsConfigsAllowdeprecatedapis>,
	    #[serde(rename = "always-use-proxy")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub always_use_proxy: Option<ListconfigsConfigsAlwaysuseproxy>,
	    #[serde(rename = "announce-addr")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub announce_addr: Option<ListconfigsConfigsAnnounceaddr>,
	    #[serde(rename = "announce-addr-discovered")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub announce_addr_discovered: Option<ListconfigsConfigsAnnounceaddrdiscovered>,
	    #[serde(rename = "announce-addr-discovered-port")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub announce_addr_discovered_port: Option<ListconfigsConfigsAnnounceaddrdiscoveredport>,
	    #[serde(rename = "announce-addr-dns")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub announce_addr_dns: Option<ListconfigsConfigsAnnounceaddrdns>,
	    #[serde(rename = "bind-addr")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bind_addr: Option<ListconfigsConfigsBindaddr>,
	    #[serde(rename = "clear-plugins")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub clear_plugins: Option<ListconfigsConfigsClearplugins>,
	    #[serde(rename = "cltv-delta")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub cltv_delta: Option<ListconfigsConfigsCltvdelta>,
	    #[serde(rename = "cltv-final")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub cltv_final: Option<ListconfigsConfigsCltvfinal>,
	    #[serde(rename = "commit-fee")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub commit_fee: Option<ListconfigsConfigsCommitfee>,
	    #[serde(rename = "commit-feerate-offset")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub commit_feerate_offset: Option<ListconfigsConfigsCommitfeerateoffset>,
	    #[serde(rename = "commit-time")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub commit_time: Option<ListconfigsConfigsCommittime>,
	    #[serde(rename = "database-upgrade")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub database_upgrade: Option<ListconfigsConfigsDatabaseupgrade>,
	    #[serde(rename = "disable-dns")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub disable_dns: Option<ListconfigsConfigsDisabledns>,
	    #[serde(rename = "disable-mpp")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub disable_mpp: Option<ListconfigsConfigsDisablempp>,
	    #[serde(rename = "disable-plugin")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub disable_plugin: Option<ListconfigsConfigsDisableplugin>,
	    #[serde(rename = "encrypted-hsm")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub encrypted_hsm: Option<ListconfigsConfigsEncryptedhsm>,
	    #[serde(rename = "experimental-anchors")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub experimental_anchors: Option<ListconfigsConfigsExperimentalanchors>,
	    #[serde(rename = "experimental-dual-fund")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub experimental_dual_fund: Option<ListconfigsConfigsExperimentaldualfund>,
	    #[serde(rename = "experimental-offers")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub experimental_offers: Option<ListconfigsConfigsExperimentaloffers>,
	    #[serde(rename = "experimental-onion-messages")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub experimental_onion_messages: Option<ListconfigsConfigsExperimentalonionmessages>,
	    #[serde(rename = "experimental-peer-storage")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub experimental_peer_storage: Option<ListconfigsConfigsExperimentalpeerstorage>,
	    #[serde(rename = "experimental-shutdown-wrong-funding")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub experimental_shutdown_wrong_funding: Option<ListconfigsConfigsExperimentalshutdownwrongfunding>,
	    #[serde(rename = "experimental-splicing")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub experimental_splicing: Option<ListconfigsConfigsExperimentalsplicing>,
	    #[serde(rename = "fee-base")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_base: Option<ListconfigsConfigsFeebase>,
	    #[serde(rename = "fee-per-satoshi")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_per_satoshi: Option<ListconfigsConfigsFeepersatoshi>,
	    #[serde(rename = "fetchinvoice-noconnect")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fetchinvoice_noconnect: Option<ListconfigsConfigsFetchinvoicenoconnect>,
	    #[serde(rename = "force-feerates")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub force_feerates: Option<ListconfigsConfigsForcefeerates>,
	    #[serde(rename = "funding-confirms")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_confirms: Option<ListconfigsConfigsFundingconfirms>,
	    #[serde(rename = "htlc-maximum-msat")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub htlc_maximum_msat: Option<ListconfigsConfigsHtlcmaximummsat>,
	    #[serde(rename = "htlc-minimum-msat")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub htlc_minimum_msat: Option<ListconfigsConfigsHtlcminimummsat>,
	    #[serde(rename = "ignore-fee-limits")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub ignore_fee_limits: Option<ListconfigsConfigsIgnorefeelimits>,
	    #[serde(rename = "important-plugin")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub important_plugin: Option<ListconfigsConfigsImportantplugin>,
	    #[serde(rename = "large-channels")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub large_channels: Option<ListconfigsConfigsLargechannels>,
	    #[serde(rename = "lightning-dir")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub lightning_dir: Option<ListconfigsConfigsLightningdir>,
	    #[serde(rename = "log-file")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub log_file: Option<ListconfigsConfigsLogfile>,
	    #[serde(rename = "log-level")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub log_level: Option<ListconfigsConfigsLoglevel>,
	    #[serde(rename = "log-prefix")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub log_prefix: Option<ListconfigsConfigsLogprefix>,
	    #[serde(rename = "log-timestamps")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub log_timestamps: Option<ListconfigsConfigsLogtimestamps>,
	    #[serde(rename = "max-concurrent-htlcs")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub max_concurrent_htlcs: Option<ListconfigsConfigsMaxconcurrenthtlcs>,
	    #[serde(rename = "max-dust-htlc-exposure-msat")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub max_dust_htlc_exposure_msat: Option<ListconfigsConfigsMaxdusthtlcexposuremsat>,
	    #[serde(rename = "min-capacity-sat")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub min_capacity_sat: Option<ListconfigsConfigsMincapacitysat>,
	    #[serde(rename = "pid-file")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub pid_file: Option<ListconfigsConfigsPidfile>,
	    #[serde(rename = "plugin-dir")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub plugin_dir: Option<ListconfigsConfigsPlugindir>,
	    #[serde(rename = "require-confirmed-inputs")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub require_confirmed_inputs: Option<ListconfigsConfigsRequireconfirmedinputs>,
	    #[serde(rename = "rpc-file")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub rpc_file: Option<ListconfigsConfigsRpcfile>,
	    #[serde(rename = "rpc-file-mode")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub rpc_file_mode: Option<ListconfigsConfigsRpcfilemode>,
	    #[serde(rename = "tor-service-password")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub tor_service_password: Option<ListconfigsConfigsTorservicepassword>,
	    #[serde(rename = "watchtime-blocks")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub watchtime_blocks: Option<ListconfigsConfigsWatchtimeblocks>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub addr: Option<ListconfigsConfigsAddr>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub alias: Option<ListconfigsConfigsAlias>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub autolisten: Option<ListconfigsConfigsAutolisten>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub conf: Option<ListconfigsConfigsConf>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub daemon: Option<ListconfigsConfigsDaemon>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub developer: Option<ListconfigsConfigsDeveloper>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub mainnet: Option<ListconfigsConfigsMainnet>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub network: Option<ListconfigsConfigsNetwork>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offline: Option<ListconfigsConfigsOffline>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub plugin: Option<ListconfigsConfigsPlugin>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub proxy: Option<ListconfigsConfigsProxy>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub regtest: Option<ListconfigsConfigsRegtest>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub rescan: Option<ListconfigsConfigsRescan>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub rgb: Option<ListconfigsConfigsRgb>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub signet: Option<ListconfigsConfigsSignet>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub subdaemon: Option<ListconfigsConfigsSubdaemon>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub testnet: Option<ListconfigsConfigsTestnet>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub wallet: Option<ListconfigsConfigsWallet>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListconfigsResponse {
	    #[deprecated]
	    #[serde(rename = "accept-htlc-tlv-types")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub accept_htlc_tlv_types: Option<String>,
	    #[deprecated]
	    #[serde(rename = "allow-deprecated-apis")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub allow_deprecated_apis: Option<bool>,
	    #[deprecated]
	    #[serde(rename = "always-use-proxy")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub always_use_proxy: Option<bool>,
	    #[deprecated]
	    #[serde(rename = "announce-addr")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub announce_addr: Option<String>,
	    #[deprecated]
	    #[serde(rename = "announce-addr-discovered")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub announce_addr_discovered: Option<String>,
	    #[deprecated]
	    #[serde(rename = "announce-addr-discovered-port")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub announce_addr_discovered_port: Option<i64>,
	    #[deprecated]
	    #[serde(rename = "announce-addr-dns")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub announce_addr_dns: Option<bool>,
	    #[deprecated]
	    #[serde(rename = "bind-addr")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bind_addr: Option<String>,
	    #[deprecated]
	    #[serde(rename = "bookkeeper-db")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bookkeeper_db: Option<String>,
	    #[deprecated]
	    #[serde(rename = "bookkeeper-dir")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bookkeeper_dir: Option<String>,
	    #[deprecated]
	    #[serde(rename = "cltv-delta")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub cltv_delta: Option<u32>,
	    #[deprecated]
	    #[serde(rename = "cltv-final")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub cltv_final: Option<u32>,
	    #[deprecated]
	    #[serde(rename = "commit-fee")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub commit_fee: Option<u64>,
	    #[deprecated]
	    #[serde(rename = "commit-time")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub commit_time: Option<u32>,
	    #[deprecated]
	    #[serde(rename = "database-upgrade")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub database_upgrade: Option<bool>,
	    #[deprecated]
	    #[serde(rename = "dev-allowdustreserve")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub dev_allowdustreserve: Option<bool>,
	    #[deprecated]
	    #[serde(rename = "disable-dns")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub disable_dns: Option<bool>,
	    #[deprecated]
	    #[serde(rename = "encrypted-hsm")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub encrypted_hsm: Option<bool>,
	    #[deprecated]
	    #[serde(rename = "experimental-dual-fund")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub experimental_dual_fund: Option<bool>,
	    #[deprecated]
	    #[serde(rename = "experimental-offers")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub experimental_offers: Option<bool>,
	    #[deprecated]
	    #[serde(rename = "experimental-onion-messages")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub experimental_onion_messages: Option<bool>,
	    #[deprecated]
	    #[serde(rename = "experimental-peer-storage")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub experimental_peer_storage: Option<bool>,
	    #[deprecated]
	    #[serde(rename = "experimental-quiesce")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub experimental_quiesce: Option<bool>,
	    #[deprecated]
	    #[serde(rename = "experimental-shutdown-wrong-funding")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub experimental_shutdown_wrong_funding: Option<bool>,
	    #[deprecated]
	    #[serde(rename = "experimental-splicing")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub experimental_splicing: Option<bool>,
	    #[deprecated]
	    #[serde(rename = "experimental-upgrade-protocol")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub experimental_upgrade_protocol: Option<bool>,
	    #[deprecated]
	    #[serde(rename = "fee-base")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_base: Option<u32>,
	    #[deprecated]
	    #[serde(rename = "fee-per-satoshi")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_per_satoshi: Option<u32>,
	    #[deprecated]
	    #[serde(rename = "fetchinvoice-noconnect")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fetchinvoice_noconnect: Option<bool>,
	    #[deprecated]
	    #[serde(rename = "force-feerates")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub force_feerates: Option<String>,
	    #[deprecated]
	    #[serde(rename = "funding-confirms")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_confirms: Option<u32>,
	    #[deprecated]
	    #[serde(rename = "htlc-maximum-msat")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub htlc_maximum_msat: Option<Amount>,
	    #[deprecated]
	    #[serde(rename = "htlc-minimum-msat")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub htlc_minimum_msat: Option<Amount>,
	    #[deprecated]
	    #[serde(rename = "ignore-fee-limits")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub ignore_fee_limits: Option<bool>,
	    #[deprecated]
	    #[serde(rename = "large-channels")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub large_channels: Option<bool>,
	    #[deprecated]
	    #[serde(rename = "lightning-dir")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub lightning_dir: Option<String>,
	    #[deprecated]
	    #[serde(rename = "log-file")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub log_file: Option<String>,
	    #[deprecated]
	    #[serde(rename = "log-level")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub log_level: Option<String>,
	    #[deprecated]
	    #[serde(rename = "log-prefix")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub log_prefix: Option<String>,
	    #[deprecated]
	    #[serde(rename = "log-timestamps")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub log_timestamps: Option<bool>,
	    #[deprecated]
	    #[serde(rename = "max-concurrent-htlcs")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub max_concurrent_htlcs: Option<u32>,
	    #[deprecated]
	    #[serde(rename = "max-dust-htlc-exposure-msat")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub max_dust_htlc_exposure_msat: Option<Amount>,
	    #[deprecated]
	    #[serde(rename = "max-locktime-blocks")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub max_locktime_blocks: Option<u32>,
	    #[deprecated]
	    #[serde(rename = "min-capacity-sat")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub min_capacity_sat: Option<u64>,
	    #[deprecated]
	    #[serde(rename = "pid-file")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub pid_file: Option<String>,
	    #[deprecated]
	    #[serde(rename = "require-confirmed-inputs")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub require_confirmed_inputs: Option<bool>,
	    #[deprecated]
	    #[serde(rename = "rpc-file")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub rpc_file: Option<String>,
	    #[deprecated]
	    #[serde(rename = "rpc-file-mode")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub rpc_file_mode: Option<String>,
	    #[deprecated]
	    #[serde(rename = "tor-service-password")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub tor_service_password: Option<String>,
	    #[deprecated]
	    #[serde(rename = "watchtime-blocks")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub watchtime_blocks: Option<u32>,
	    #[deprecated]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub addr: Option<String>,
	    #[deprecated]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub alias: Option<String>,
	    #[deprecated]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub autolisten: Option<bool>,
	    #[deprecated]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub conf: Option<String>,
	    #[deprecated]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub daemon: Option<bool>,
	    #[deprecated]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub network: Option<String>,
	    #[deprecated]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offline: Option<bool>,
	    #[deprecated]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub proxy: Option<String>,
	    #[deprecated]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub rescan: Option<i64>,
	    #[deprecated]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub rgb: Option<String>,
	    #[deprecated]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub subdaemon: Option<String>,
	    #[deprecated]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub wallet: Option<String>,
	    #[deprecated]
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub disable_plugin: Option<Vec<String>>,
	    #[deprecated]
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub important_plugins: Option<Vec<ListconfigsImportantplugins>>,
	    #[deprecated]
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub plugins: Option<Vec<ListconfigsPlugins>>,
	    #[serde(rename = "commit-feerate-offset")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub commit_feerate_offset: Option<u32>,
	    #[serde(rename = "invoices-onchain-fallback")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invoices_onchain_fallback: Option<bool>,
	    #[serde(rename = "min-emergency-msat")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub min_emergency_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub configs: Option<ListconfigsConfigs>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub developer: Option<bool>,
	}

	impl TryFrom<Response> for ListconfigsResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListConfigs(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum StopResult {
	    #[serde(rename = "Shutdown complete")]
	    SHUTDOWN_COMPLETE = 0,
	}

	impl TryFrom<i32> for StopResult {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<StopResult, anyhow::Error> {
	        match c {
	    0 => Ok(StopResult::SHUTDOWN_COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum StopResult", o)),
	        }
	    }
	}

	impl ToString for StopResult {
	    fn to_string(&self) -> String {
	        match self {
	            StopResult::SHUTDOWN_COMPLETE => "SHUTDOWN_COMPLETE",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct StopResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub result: Option<StopResult>,
	}

	impl TryFrom<Response> for StopResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Stop(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Prints the help in human-readable flat form.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum HelpFormathint {
	    #[serde(rename = "simple")]
	    SIMPLE = 0,
	}

	impl TryFrom<i32> for HelpFormathint {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<HelpFormathint, anyhow::Error> {
	        match c {
	    0 => Ok(HelpFormathint::SIMPLE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum HelpFormathint", o)),
	        }
	    }
	}

	impl ToString for HelpFormathint {
	    fn to_string(&self) -> String {
	        match self {
	            HelpFormathint::SIMPLE => "SIMPLE",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct HelpHelp {
	    pub category: String,
	    pub command: String,
	    pub description: String,
	    pub verbose: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct HelpResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub format_hint: Option<HelpFormathint>,
	    pub help: Vec<HelpHelp>,
	}

	impl TryFrom<Response> for HelpResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Help(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct PreapprovekeysendResponse {
	}

	impl TryFrom<Response> for PreapprovekeysendResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::PreApproveKeysend(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct PreapproveinvoiceResponse {
	}

	impl TryFrom<Response> for PreapproveinvoiceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::PreApproveInvoice(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct StaticbackupResponse {
	    pub scb: Vec<String>,
	}

	impl TryFrom<Response> for StaticbackupResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::StaticBackup(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct BkprchannelsapyChannels_apy {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub apy_in_initial: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub apy_lease: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub apy_out_initial: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub apy_total_initial: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fees_in_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub utilization_in_initial: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub utilization_out_initial: Option<String>,
	    pub account: String,
	    pub apy_in: String,
	    pub apy_out: String,
	    pub apy_total: String,
	    pub channel_start_balance_msat: Amount,
	    pub fees_out_msat: Amount,
	    pub lease_fee_earned_msat: Amount,
	    pub lease_fee_paid_msat: Amount,
	    pub our_start_balance_msat: Amount,
	    pub pushed_in_msat: Amount,
	    pub pushed_out_msat: Amount,
	    pub routed_in_msat: Amount,
	    pub routed_out_msat: Amount,
	    pub utilization_in: String,
	    pub utilization_out: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct BkprchannelsapyResponse {
	    pub channels_apy: Vec<BkprchannelsapyChannels_apy>,
	}

	impl TryFrom<Response> for BkprchannelsapyResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::BkprChannelsApy(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Format to print csv as.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum BkprdumpincomecsvCsv_format {
	    #[serde(rename = "cointracker")]
	    COINTRACKER = 0,
	    #[serde(rename = "koinly")]
	    KOINLY = 1,
	    #[serde(rename = "harmony")]
	    HARMONY = 2,
	    #[serde(rename = "quickbooks")]
	    QUICKBOOKS = 3,
	}

	impl TryFrom<i32> for BkprdumpincomecsvCsv_format {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<BkprdumpincomecsvCsv_format, anyhow::Error> {
	        match c {
	    0 => Ok(BkprdumpincomecsvCsv_format::COINTRACKER),
	    1 => Ok(BkprdumpincomecsvCsv_format::KOINLY),
	    2 => Ok(BkprdumpincomecsvCsv_format::HARMONY),
	    3 => Ok(BkprdumpincomecsvCsv_format::QUICKBOOKS),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum BkprdumpincomecsvCsv_format", o)),
	        }
	    }
	}

	impl ToString for BkprdumpincomecsvCsv_format {
	    fn to_string(&self) -> String {
	        match self {
	            BkprdumpincomecsvCsv_format::COINTRACKER => "COINTRACKER",
	            BkprdumpincomecsvCsv_format::KOINLY => "KOINLY",
	            BkprdumpincomecsvCsv_format::HARMONY => "HARMONY",
	            BkprdumpincomecsvCsv_format::QUICKBOOKS => "QUICKBOOKS",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct BkprdumpincomecsvResponse {
	    // Path `Bkpr-DumpIncomeCsv.csv_format`
	    pub csv_format: BkprdumpincomecsvCsv_format,
	    pub csv_file: String,
	}

	impl TryFrom<Response> for BkprdumpincomecsvResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::BkprDumpIncomeCsv(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct BkprinspectTxsOutputs {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub credit_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub debit_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub originating_account: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub output_tag: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_id: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub spend_tag: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub spending_txid: Option<String>,
	    pub account: String,
	    pub currency: String,
	    pub outnum: u32,
	    pub output_value_msat: Amount,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct BkprinspectTxs {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub blockheight: Option<u32>,
	    pub fees_paid_msat: Amount,
	    pub outputs: Vec<BkprinspectTxsOutputs>,
	    pub txid: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct BkprinspectResponse {
	    pub txs: Vec<BkprinspectTxs>,
	}

	impl TryFrom<Response> for BkprinspectResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::BkprInspect(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// ['Coin movement type.']
	#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
	pub enum BkprlistaccounteventsEventsType {
	    #[serde(rename = "onchain_fee")]
	    ONCHAIN_FEE = 0,
	    #[serde(rename = "chain")]
	    CHAIN = 1,
	    #[serde(rename = "channel")]
	    CHANNEL = 2,
	}

	impl TryFrom<i32> for BkprlistaccounteventsEventsType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<BkprlistaccounteventsEventsType, anyhow::Error> {
	        match c {
	    0 => Ok(BkprlistaccounteventsEventsType::ONCHAIN_FEE),
	    1 => Ok(BkprlistaccounteventsEventsType::CHAIN),
	    2 => Ok(BkprlistaccounteventsEventsType::CHANNEL),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum BkprlistaccounteventsEventsType", o)),
	        }
	    }
	}

	impl ToString for BkprlistaccounteventsEventsType {
	    fn to_string(&self) -> String {
	        match self {
	            BkprlistaccounteventsEventsType::ONCHAIN_FEE => "ONCHAIN_FEE",
	            BkprlistaccounteventsEventsType::CHAIN => "CHAIN",
	            BkprlistaccounteventsEventsType::CHANNEL => "CHANNEL",
	        }.to_string()
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct BkprlistaccounteventsEvents {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub blockheight: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fees_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub is_rebalance: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub origin: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub outpoint: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub part_id: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_id: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub txid: Option<String>,
	    // Path `Bkpr-ListAccountEvents.events[].type`
	    #[serde(rename = "type")]
	    pub item_type: BkprlistaccounteventsEventsType,
	    pub account: String,
	    pub credit_msat: Amount,
	    pub currency: String,
	    pub debit_msat: Amount,
	    pub tag: String,
	    pub timestamp: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct BkprlistaccounteventsResponse {
	    pub events: Vec<BkprlistaccounteventsEvents>,
	}

	impl TryFrom<Response> for BkprlistaccounteventsResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::BkprListAccountEvents(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct BkprlistbalancesAccountsBalances {
	    pub balance_msat: Amount,
	    pub coin_type: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct BkprlistbalancesAccounts {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub account_closed: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub account_resolved: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub peer_id: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub resolved_at_block: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub we_opened: Option<bool>,
	    pub account: String,
	    pub balances: Vec<BkprlistbalancesAccountsBalances>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct BkprlistbalancesResponse {
	    pub accounts: Vec<BkprlistbalancesAccounts>,
	}

	impl TryFrom<Response> for BkprlistbalancesResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::BkprListBalances(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct BkprlistincomeIncome_events {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub outpoint: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_id: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub txid: Option<String>,
	    pub account: String,
	    pub credit_msat: Amount,
	    pub currency: String,
	    pub debit_msat: Amount,
	    pub tag: String,
	    pub timestamp: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct BkprlistincomeResponse {
	    pub income_events: Vec<BkprlistincomeIncome_events>,
	}

	impl TryFrom<Response> for BkprlistincomeResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::BkprListIncome(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct BlacklistruneBlacklist {
	    pub end: u64,
	    pub start: u64,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct BlacklistruneResponse {
	    pub blacklist: Vec<BlacklistruneBlacklist>,
	}

	impl TryFrom<Response> for BlacklistruneResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::BlacklistRune(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CheckruneResponse {
	    pub valid: bool,
	}

	impl TryFrom<Response> for CheckruneResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::CheckRune(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CreateruneResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_unrestricted_rune: Option<String>,
	    pub rune: String,
	    pub unique_id: String,
	}

	impl TryFrom<Response> for CreateruneResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::CreateRune(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ShowrunesRunesRestrictionsAlternatives {
	    pub condition: String,
	    pub english: String,
	    pub fieldname: String,
	    pub value: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ShowrunesRunesRestrictions {
	    pub alternatives: Vec<ShowrunesRunesRestrictionsAlternatives>,
	    pub english: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ShowrunesRunes {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub blacklisted: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub last_used: Option<f64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub our_rune: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub stored: Option<bool>,
	    pub restrictions: Vec<ShowrunesRunesRestrictions>,
	    pub restrictions_as_english: String,
	    pub rune: String,
	    pub unique_id: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ShowrunesResponse {
	    pub runes: Vec<ShowrunesRunes>,
	}

	impl TryFrom<Response> for ShowrunesResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ShowRunes(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

}

