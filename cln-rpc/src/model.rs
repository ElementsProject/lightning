#![allow(non_camel_case_types)]
//! This file was automatically generated using the following command:
//!
//! ```bash
//! contrib/msggen/msggen/__main__.py
//! ```
//!
//! Do not edit this file, it'll be overwritten. Rather edit the schema that
//! this file was generated from

use serde::{Deserialize, Serialize};
pub use requests::*;
pub use responses::*;

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(tag = "method", content = "params")]
#[serde(rename_all = "lowercase")]
pub enum Request {
	Getinfo(requests::GetinfoRequest),
	ListPeers(requests::ListpeersRequest),
	ListFunds(requests::ListfundsRequest),
	SendPay(requests::SendpayRequest),
	ListChannels(requests::ListchannelsRequest),
	AddGossip(requests::AddgossipRequest),
	AutoCleanInvoice(requests::AutocleaninvoiceRequest),
	CheckMessage(requests::CheckmessageRequest),
	Close(requests::CloseRequest),
	ConnectPeer(requests::ConnectRequest),
	CreateInvoice(requests::CreateinvoiceRequest),
	Datastore(requests::DatastoreRequest),
	CreateOnion(requests::CreateonionRequest),
	DelDatastore(requests::DeldatastoreRequest),
	DelExpiredInvoice(requests::DelexpiredinvoiceRequest),
	DelInvoice(requests::DelinvoiceRequest),
	Invoice(requests::InvoiceRequest),
	ListDatastore(requests::ListdatastoreRequest),
	ListInvoices(requests::ListinvoicesRequest),
	SendOnion(requests::SendonionRequest),
	ListSendPays(requests::ListsendpaysRequest),
	ListTransactions(requests::ListtransactionsRequest),
	Pay(requests::PayRequest),
	ListNodes(requests::ListnodesRequest),
	WaitAnyInvoice(requests::WaitanyinvoiceRequest),
	WaitInvoice(requests::WaitinvoiceRequest),
	WaitSendPay(requests::WaitsendpayRequest),
	NewAddr(requests::NewaddrRequest),
	Withdraw(requests::WithdrawRequest),
	KeySend(requests::KeysendRequest),
	FundPsbt(requests::FundpsbtRequest),
	SendPsbt(requests::SendpsbtRequest),
	SignPsbt(requests::SignpsbtRequest),
	UtxoPsbt(requests::UtxopsbtRequest),
	TxDiscard(requests::TxdiscardRequest),
	TxPrepare(requests::TxprepareRequest),
	TxSend(requests::TxsendRequest),
	Disconnect(requests::DisconnectRequest),
	Feerates(requests::FeeratesRequest),
	GetRoute(requests::GetrouteRequest),
	ListForwards(requests::ListforwardsRequest),
	ListPays(requests::ListpaysRequest),
	Ping(requests::PingRequest),
	SignMessage(requests::SignmessageRequest),
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(tag = "method", content = "result")]
#[serde(rename_all = "lowercase")]
pub enum Response {
	Getinfo(responses::GetinfoResponse),
	ListPeers(responses::ListpeersResponse),
	ListFunds(responses::ListfundsResponse),
	SendPay(responses::SendpayResponse),
	ListChannels(responses::ListchannelsResponse),
	AddGossip(responses::AddgossipResponse),
	AutoCleanInvoice(responses::AutocleaninvoiceResponse),
	CheckMessage(responses::CheckmessageResponse),
	Close(responses::CloseResponse),
	ConnectPeer(responses::ConnectResponse),
	CreateInvoice(responses::CreateinvoiceResponse),
	Datastore(responses::DatastoreResponse),
	CreateOnion(responses::CreateonionResponse),
	DelDatastore(responses::DeldatastoreResponse),
	DelExpiredInvoice(responses::DelexpiredinvoiceResponse),
	DelInvoice(responses::DelinvoiceResponse),
	Invoice(responses::InvoiceResponse),
	ListDatastore(responses::ListdatastoreResponse),
	ListInvoices(responses::ListinvoicesResponse),
	SendOnion(responses::SendonionResponse),
	ListSendPays(responses::ListsendpaysResponse),
	ListTransactions(responses::ListtransactionsResponse),
	Pay(responses::PayResponse),
	ListNodes(responses::ListnodesResponse),
	WaitAnyInvoice(responses::WaitanyinvoiceResponse),
	WaitInvoice(responses::WaitinvoiceResponse),
	WaitSendPay(responses::WaitsendpayResponse),
	NewAddr(responses::NewaddrResponse),
	Withdraw(responses::WithdrawResponse),
	KeySend(responses::KeysendResponse),
	FundPsbt(responses::FundpsbtResponse),
	SendPsbt(responses::SendpsbtResponse),
	SignPsbt(responses::SignpsbtResponse),
	UtxoPsbt(responses::UtxopsbtResponse),
	TxDiscard(responses::TxdiscardResponse),
	TxPrepare(responses::TxprepareResponse),
	TxSend(responses::TxsendResponse),
	Disconnect(responses::DisconnectResponse),
	Feerates(responses::FeeratesResponse),
	GetRoute(responses::GetrouteResponse),
	ListForwards(responses::ListforwardsResponse),
	ListPays(responses::ListpaysResponse),
	Ping(responses::PingResponse),
	SignMessage(responses::SignmessageResponse),
}

pub mod requests {
    #[allow(unused_imports)]
    use crate::primitives::*;
    #[allow(unused_imports)]
    use serde::{{Deserialize, Serialize}};

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetinfoRequest {
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeersRequest {
	    #[serde(alias = "id", skip_serializing_if = "Option::is_none")]
	    pub id: Option<Pubkey>,
	    #[serde(alias = "level", skip_serializing_if = "Option::is_none")]
	    pub level: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListfundsRequest {
	    #[serde(alias = "spent", skip_serializing_if = "Option::is_none")]
	    pub spent: Option<bool>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendpayRoute {
	    #[serde(alias = "msatoshi")]
	    pub msatoshi: Amount,
	    #[serde(alias = "id")]
	    pub id: Pubkey,
	    #[serde(alias = "delay")]
	    pub delay: u16,
	    #[serde(alias = "channel")]
	    pub channel: ShortChannelId,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendpayRequest {
	    #[serde(alias = "route")]
	    pub route: Vec<SendpayRoute>,
	    #[serde(alias = "payment_hash")]
	    pub payment_hash: Sha256,
	    #[serde(alias = "label", skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(alias = "msatoshi", skip_serializing_if = "Option::is_none")]
	    pub msatoshi: Option<Amount>,
	    #[serde(alias = "bolt11", skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(alias = "payment_secret", skip_serializing_if = "Option::is_none")]
	    pub payment_secret: Option<Secret>,
	    #[serde(alias = "partid", skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u16>,
	    #[serde(alias = "localofferid", skip_serializing_if = "Option::is_none")]
	    pub localofferid: Option<String>,
	    #[serde(alias = "groupid", skip_serializing_if = "Option::is_none")]
	    pub groupid: Option<u64>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListchannelsRequest {
	    #[serde(alias = "short_channel_id", skip_serializing_if = "Option::is_none")]
	    pub short_channel_id: Option<ShortChannelId>,
	    #[serde(alias = "source", skip_serializing_if = "Option::is_none")]
	    pub source: Option<Pubkey>,
	    #[serde(alias = "destination", skip_serializing_if = "Option::is_none")]
	    pub destination: Option<Pubkey>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AddgossipRequest {
	    #[serde(alias = "message")]
	    pub message: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AutocleaninvoiceRequest {
	    #[serde(alias = "expired_by", skip_serializing_if = "Option::is_none")]
	    pub expired_by: Option<u64>,
	    #[serde(alias = "cycle_seconds", skip_serializing_if = "Option::is_none")]
	    pub cycle_seconds: Option<u64>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CheckmessageRequest {
	    #[serde(alias = "message")]
	    pub message: String,
	    #[serde(alias = "zbase")]
	    pub zbase: String,
	    #[serde(alias = "pubkey", skip_serializing_if = "Option::is_none")]
	    pub pubkey: Option<Pubkey>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CloseRequest {
	    #[serde(alias = "id")]
	    pub id: String,
	    #[serde(alias = "unilateraltimeout", skip_serializing_if = "Option::is_none")]
	    pub unilateraltimeout: Option<u32>,
	    #[serde(alias = "destination", skip_serializing_if = "Option::is_none")]
	    pub destination: Option<String>,
	    #[serde(alias = "fee_negotiation_step", skip_serializing_if = "Option::is_none")]
	    pub fee_negotiation_step: Option<String>,
	    #[serde(alias = "wrong_funding", skip_serializing_if = "Option::is_none")]
	    pub wrong_funding: Option<String>,
	    #[serde(alias = "force_lease_closed", skip_serializing_if = "Option::is_none")]
	    pub force_lease_closed: Option<bool>,
	    #[serde(alias = "feerange", skip_serializing_if = "Option::is_none")]
	    pub feerange: Option<Vec<Feerate>>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ConnectRequest {
	    #[serde(alias = "id")]
	    pub id: String,
	    #[serde(alias = "host", skip_serializing_if = "Option::is_none")]
	    pub host: Option<String>,
	    #[serde(alias = "port", skip_serializing_if = "Option::is_none")]
	    pub port: Option<u16>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CreateinvoiceRequest {
	    #[serde(alias = "invstring")]
	    pub invstring: String,
	    #[serde(alias = "label")]
	    pub label: String,
	    #[serde(alias = "preimage")]
	    pub preimage: String,
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum DatastoreMode {
	    #[serde(rename = "must-create")]
	    MUST_CREATE,
	    #[serde(rename = "must-replace")]
	    MUST_REPLACE,
	    #[serde(rename = "create-or-replace")]
	    CREATE_OR_REPLACE,
	    #[serde(rename = "must-append")]
	    MUST_APPEND,
	    #[serde(rename = "create-or-append")]
	    CREATE_OR_APPEND,
	}

	impl TryFrom<i32> for DatastoreMode {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<DatastoreMode, anyhow::Error> {
	        match c {
	    0 => Ok(DatastoreMode::MUST_CREATE),
	    1 => Ok(DatastoreMode::MUST_REPLACE),
	    2 => Ok(DatastoreMode::CREATE_OR_REPLACE),
	    3 => Ok(DatastoreMode::MUST_APPEND),
	    4 => Ok(DatastoreMode::CREATE_OR_APPEND),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum DatastoreMode", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DatastoreRequest {
	    #[serde(alias = "key")]
	    pub key: Vec<String>,
	    #[serde(alias = "string", skip_serializing_if = "Option::is_none")]
	    pub string: Option<String>,
	    #[serde(alias = "hex", skip_serializing_if = "Option::is_none")]
	    pub hex: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub mode: Option<DatastoreMode>,
	    #[serde(alias = "generation", skip_serializing_if = "Option::is_none")]
	    pub generation: Option<u64>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CreateonionHops {
	    #[serde(alias = "pubkey")]
	    pub pubkey: Pubkey,
	    #[serde(alias = "payload")]
	    pub payload: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CreateonionRequest {
	    #[serde(alias = "hops")]
	    pub hops: Vec<CreateonionHops>,
	    #[serde(alias = "assocdata")]
	    pub assocdata: String,
	    #[serde(alias = "session_key", skip_serializing_if = "Option::is_none")]
	    pub session_key: Option<Secret>,
	    #[serde(alias = "onion_size", skip_serializing_if = "Option::is_none")]
	    pub onion_size: Option<u16>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DeldatastoreRequest {
	    #[serde(alias = "key")]
	    pub key: Vec<String>,
	    #[serde(alias = "generation", skip_serializing_if = "Option::is_none")]
	    pub generation: Option<u64>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DelexpiredinvoiceRequest {
	    #[serde(alias = "maxexpirytime", skip_serializing_if = "Option::is_none")]
	    pub maxexpirytime: Option<u64>,
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum DelinvoiceStatus {
	    #[serde(rename = "paid")]
	    PAID,
	    #[serde(rename = "expired")]
	    EXPIRED,
	    #[serde(rename = "unpaid")]
	    UNPAID,
	}

	impl TryFrom<i32> for DelinvoiceStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<DelinvoiceStatus, anyhow::Error> {
	        match c {
	    0 => Ok(DelinvoiceStatus::PAID),
	    1 => Ok(DelinvoiceStatus::EXPIRED),
	    2 => Ok(DelinvoiceStatus::UNPAID),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum DelinvoiceStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DelinvoiceRequest {
	    #[serde(alias = "label")]
	    pub label: String,
	    // Path `DelInvoice.status`
	    #[serde(rename = "status")]
	    pub status: DelinvoiceStatus,
	    #[serde(alias = "desconly", skip_serializing_if = "Option::is_none")]
	    pub desconly: Option<bool>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct InvoiceRequest {
	    #[serde(alias = "msatoshi")]
	    pub msatoshi: AmountOrAny,
	    #[serde(alias = "description")]
	    pub description: String,
	    #[serde(alias = "label")]
	    pub label: String,
	    #[serde(alias = "expiry", skip_serializing_if = "Option::is_none")]
	    pub expiry: Option<u64>,
	    #[serde(alias = "fallbacks", skip_serializing_if = "Option::is_none")]
	    pub fallbacks: Option<Vec<String>>,
	    #[serde(alias = "preimage", skip_serializing_if = "Option::is_none")]
	    pub preimage: Option<String>,
	    #[serde(alias = "exposeprivatechannels", skip_serializing_if = "Option::is_none")]
	    pub exposeprivatechannels: Option<bool>,
	    #[serde(alias = "cltv", skip_serializing_if = "Option::is_none")]
	    pub cltv: Option<u32>,
	    #[serde(alias = "deschashonly", skip_serializing_if = "Option::is_none")]
	    pub deschashonly: Option<bool>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListdatastoreRequest {
	    #[serde(alias = "key", skip_serializing_if = "Option::is_none")]
	    pub key: Option<Vec<String>>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListinvoicesRequest {
	    #[serde(alias = "label", skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(alias = "invstring", skip_serializing_if = "Option::is_none")]
	    pub invstring: Option<String>,
	    #[serde(alias = "payment_hash", skip_serializing_if = "Option::is_none")]
	    pub payment_hash: Option<String>,
	    #[serde(alias = "offer_id", skip_serializing_if = "Option::is_none")]
	    pub offer_id: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendonionFirst_hop {
	    #[serde(alias = "id")]
	    pub id: Pubkey,
	    #[serde(alias = "amount_msat")]
	    pub amount_msat: Amount,
	    #[serde(alias = "delay")]
	    pub delay: u16,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendonionRequest {
	    #[serde(alias = "onion")]
	    pub onion: String,
	    #[serde(alias = "payment_hash")]
	    pub payment_hash: Sha256,
	    #[serde(alias = "label", skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(alias = "shared_secrets", skip_serializing_if = "Option::is_none")]
	    pub shared_secrets: Option<Vec<Secret>>,
	    #[serde(alias = "partid", skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u16>,
	    #[serde(alias = "bolt11", skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(alias = "msatoshi", skip_serializing_if = "Option::is_none")]
	    pub msatoshi: Option<Amount>,
	    #[serde(alias = "destination", skip_serializing_if = "Option::is_none")]
	    pub destination: Option<Pubkey>,
	    #[serde(alias = "localofferid", skip_serializing_if = "Option::is_none")]
	    pub localofferid: Option<Sha256>,
	    #[serde(alias = "groupid", skip_serializing_if = "Option::is_none")]
	    pub groupid: Option<u64>,
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListsendpaysStatus {
	    #[serde(rename = "pending")]
	    PENDING,
	    #[serde(rename = "complete")]
	    COMPLETE,
	    #[serde(rename = "failed")]
	    FAILED,
	}

	impl TryFrom<i32> for ListsendpaysStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListsendpaysStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListsendpaysStatus::PENDING),
	    1 => Ok(ListsendpaysStatus::COMPLETE),
	    2 => Ok(ListsendpaysStatus::FAILED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListsendpaysStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListsendpaysRequest {
	    #[serde(alias = "bolt11", skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(alias = "payment_hash", skip_serializing_if = "Option::is_none")]
	    pub payment_hash: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub status: Option<ListsendpaysStatus>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListtransactionsRequest {
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct PayRequest {
	    #[serde(alias = "bolt11")]
	    pub bolt11: String,
	    #[serde(alias = "msatoshi", skip_serializing_if = "Option::is_none")]
	    pub msatoshi: Option<Amount>,
	    #[serde(alias = "label", skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(alias = "riskfactor", skip_serializing_if = "Option::is_none")]
	    pub riskfactor: Option<f64>,
	    #[serde(alias = "maxfeepercent", skip_serializing_if = "Option::is_none")]
	    pub maxfeepercent: Option<f64>,
	    #[serde(alias = "retry_for", skip_serializing_if = "Option::is_none")]
	    pub retry_for: Option<u16>,
	    #[serde(alias = "maxdelay", skip_serializing_if = "Option::is_none")]
	    pub maxdelay: Option<u16>,
	    #[serde(alias = "exemptfee", skip_serializing_if = "Option::is_none")]
	    pub exemptfee: Option<Amount>,
	    #[serde(alias = "localofferid", skip_serializing_if = "Option::is_none")]
	    pub localofferid: Option<String>,
	    #[serde(alias = "exclude", skip_serializing_if = "Option::is_none")]
	    pub exclude: Option<Vec<String>>,
	    #[serde(alias = "maxfee", skip_serializing_if = "Option::is_none")]
	    pub maxfee: Option<Amount>,
	    #[serde(alias = "description", skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListnodesRequest {
	    #[serde(alias = "id", skip_serializing_if = "Option::is_none")]
	    pub id: Option<Pubkey>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitanyinvoiceRequest {
	    #[serde(alias = "lastpay_index", skip_serializing_if = "Option::is_none")]
	    pub lastpay_index: Option<u64>,
	    #[serde(alias = "timeout", skip_serializing_if = "Option::is_none")]
	    pub timeout: Option<u64>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitinvoiceRequest {
	    #[serde(alias = "label")]
	    pub label: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitsendpayRequest {
	    #[serde(alias = "payment_hash")]
	    pub payment_hash: Sha256,
	    #[serde(alias = "timeout", skip_serializing_if = "Option::is_none")]
	    pub timeout: Option<u32>,
	    #[serde(alias = "partid", skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u64>,
	    #[serde(alias = "groupid", skip_serializing_if = "Option::is_none")]
	    pub groupid: Option<u64>,
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum NewaddrAddresstype {
	    #[serde(rename = "bech32")]
	    BECH32,
	    #[serde(rename = "p2sh-segwit")]
	    P2SH_SEGWIT,
	    #[serde(rename = "all")]
	    ALL,
	}

	impl TryFrom<i32> for NewaddrAddresstype {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<NewaddrAddresstype, anyhow::Error> {
	        match c {
	    0 => Ok(NewaddrAddresstype::BECH32),
	    1 => Ok(NewaddrAddresstype::P2SH_SEGWIT),
	    2 => Ok(NewaddrAddresstype::ALL),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum NewaddrAddresstype", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct NewaddrRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub addresstype: Option<NewaddrAddresstype>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WithdrawRequest {
	    #[serde(alias = "destination")]
	    pub destination: String,
	    #[serde(alias = "satoshi", skip_serializing_if = "Option::is_none")]
	    pub satoshi: Option<AmountOrAll>,
	    #[serde(alias = "feerate", skip_serializing_if = "Option::is_none")]
	    pub feerate: Option<Feerate>,
	    #[serde(alias = "minconf", skip_serializing_if = "Option::is_none")]
	    pub minconf: Option<u16>,
	    #[serde(alias = "utxos", skip_serializing_if = "Option::is_none")]
	    pub utxos: Option<Vec<Outpoint>>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct KeysendExtratlvs {
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct KeysendRequest {
	    #[serde(alias = "destination")]
	    pub destination: Pubkey,
	    #[serde(alias = "msatoshi")]
	    pub msatoshi: Amount,
	    #[serde(alias = "label", skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(alias = "maxfeepercent", skip_serializing_if = "Option::is_none")]
	    pub maxfeepercent: Option<f64>,
	    #[serde(alias = "retry_for", skip_serializing_if = "Option::is_none")]
	    pub retry_for: Option<u32>,
	    #[serde(alias = "maxdelay", skip_serializing_if = "Option::is_none")]
	    pub maxdelay: Option<u32>,
	    #[serde(alias = "exemptfee", skip_serializing_if = "Option::is_none")]
	    pub exemptfee: Option<Amount>,
	    #[serde(alias = "routehints", skip_serializing_if = "Option::is_none")]
	    pub routehints: Option<RoutehintList>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FundpsbtRequest {
	    #[serde(alias = "satoshi")]
	    pub satoshi: Amount,
	    #[serde(alias = "feerate")]
	    pub feerate: Feerate,
	    #[serde(alias = "startweight")]
	    pub startweight: u32,
	    #[serde(alias = "minconf", skip_serializing_if = "Option::is_none")]
	    pub minconf: Option<u32>,
	    #[serde(alias = "reserve", skip_serializing_if = "Option::is_none")]
	    pub reserve: Option<u32>,
	    #[serde(alias = "locktime", skip_serializing_if = "Option::is_none")]
	    pub locktime: Option<u32>,
	    #[serde(alias = "min_witness_weight", skip_serializing_if = "Option::is_none")]
	    pub min_witness_weight: Option<u32>,
	    #[serde(alias = "excess_as_change", skip_serializing_if = "Option::is_none")]
	    pub excess_as_change: Option<bool>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendpsbtRequest {
	    #[serde(alias = "psbt")]
	    pub psbt: String,
	    #[serde(alias = "reserve", skip_serializing_if = "Option::is_none")]
	    pub reserve: Option<bool>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SignpsbtRequest {
	    #[serde(alias = "psbt")]
	    pub psbt: String,
	    #[serde(alias = "signonly", skip_serializing_if = "Option::is_none")]
	    pub signonly: Option<Vec<u32>>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct UtxopsbtRequest {
	    #[serde(alias = "satoshi")]
	    pub satoshi: Amount,
	    #[serde(alias = "feerate")]
	    pub feerate: Feerate,
	    #[serde(alias = "startweight")]
	    pub startweight: u32,
	    #[serde(alias = "utxos")]
	    pub utxos: Vec<Outpoint>,
	    #[serde(alias = "reserve", skip_serializing_if = "Option::is_none")]
	    pub reserve: Option<u32>,
	    #[serde(alias = "reservedok", skip_serializing_if = "Option::is_none")]
	    pub reservedok: Option<bool>,
	    #[serde(alias = "locktime", skip_serializing_if = "Option::is_none")]
	    pub locktime: Option<u32>,
	    #[serde(alias = "min_witness_weight", skip_serializing_if = "Option::is_none")]
	    pub min_witness_weight: Option<u32>,
	    #[serde(alias = "excess_as_change", skip_serializing_if = "Option::is_none")]
	    pub excess_as_change: Option<bool>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct TxdiscardRequest {
	    #[serde(alias = "txid")]
	    pub txid: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct TxprepareRequest {
	    #[serde(alias = "outputs")]
	    pub outputs: Vec<OutputDesc>,
	    #[serde(alias = "feerate", skip_serializing_if = "Option::is_none")]
	    pub feerate: Option<Feerate>,
	    #[serde(alias = "minconf", skip_serializing_if = "Option::is_none")]
	    pub minconf: Option<u32>,
	    #[serde(alias = "utxos", skip_serializing_if = "Option::is_none")]
	    pub utxos: Option<Vec<Outpoint>>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct TxsendRequest {
	    #[serde(alias = "txid")]
	    pub txid: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DisconnectRequest {
	    #[serde(alias = "id")]
	    pub id: Pubkey,
	    #[serde(alias = "force", skip_serializing_if = "Option::is_none")]
	    pub force: Option<bool>,
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum FeeratesStyle {
	    #[serde(rename = "perkb")]
	    PERKB,
	    #[serde(rename = "perkw")]
	    PERKW,
	}

	impl TryFrom<i32> for FeeratesStyle {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<FeeratesStyle, anyhow::Error> {
	        match c {
	    0 => Ok(FeeratesStyle::PERKB),
	    1 => Ok(FeeratesStyle::PERKW),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum FeeratesStyle", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FeeratesRequest {
	    // Path `Feerates.style`
	    #[serde(rename = "style")]
	    pub style: FeeratesStyle,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetrouteRequest {
	    #[serde(alias = "id")]
	    pub id: Pubkey,
	    #[serde(alias = "msatoshi")]
	    pub msatoshi: Amount,
	    #[serde(alias = "riskfactor")]
	    pub riskfactor: u64,
	    #[serde(alias = "cltv", skip_serializing_if = "Option::is_none")]
	    pub cltv: Option<f64>,
	    #[serde(alias = "fromid", skip_serializing_if = "Option::is_none")]
	    pub fromid: Option<Pubkey>,
	    #[serde(alias = "fuzzpercent", skip_serializing_if = "Option::is_none")]
	    pub fuzzpercent: Option<u32>,
	    #[serde(alias = "exclude", skip_serializing_if = "Option::is_none")]
	    pub exclude: Option<Vec<String>>,
	    #[serde(alias = "maxhops", skip_serializing_if = "Option::is_none")]
	    pub maxhops: Option<u32>,
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListforwardsStatus {
	    #[serde(rename = "offered")]
	    OFFERED,
	    #[serde(rename = "settled")]
	    SETTLED,
	    #[serde(rename = "local_failed")]
	    LOCAL_FAILED,
	    #[serde(rename = "failed")]
	    FAILED,
	}

	impl TryFrom<i32> for ListforwardsStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListforwardsStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListforwardsStatus::OFFERED),
	    1 => Ok(ListforwardsStatus::SETTLED),
	    2 => Ok(ListforwardsStatus::LOCAL_FAILED),
	    3 => Ok(ListforwardsStatus::FAILED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListforwardsStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListforwardsRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub status: Option<ListforwardsStatus>,
	    #[serde(alias = "in_channel", skip_serializing_if = "Option::is_none")]
	    pub in_channel: Option<ShortChannelId>,
	    #[serde(alias = "out_channel", skip_serializing_if = "Option::is_none")]
	    pub out_channel: Option<ShortChannelId>,
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListpaysStatus {
	    #[serde(rename = "pending")]
	    PENDING,
	    #[serde(rename = "complete")]
	    COMPLETE,
	    #[serde(rename = "failed")]
	    FAILED,
	}

	impl TryFrom<i32> for ListpaysStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListpaysStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListpaysStatus::PENDING),
	    1 => Ok(ListpaysStatus::COMPLETE),
	    2 => Ok(ListpaysStatus::FAILED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListpaysStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpaysRequest {
	    #[serde(alias = "bolt11", skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(alias = "payment_hash", skip_serializing_if = "Option::is_none")]
	    pub payment_hash: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub status: Option<ListpaysStatus>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct PingRequest {
	    #[serde(alias = "id")]
	    pub id: Pubkey,
	    #[serde(alias = "len", skip_serializing_if = "Option::is_none")]
	    pub len: Option<f64>,
	    #[serde(alias = "pongbytes", skip_serializing_if = "Option::is_none")]
	    pub pongbytes: Option<f64>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SignmessageRequest {
	    #[serde(alias = "message")]
	    pub message: String,
	}

}


pub mod responses {
    #[allow(unused_imports)]
    use crate::primitives::*;
    #[allow(unused_imports)]
    use serde::{{Deserialize, Serialize}};

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetinfoOur_features {
	    #[serde(alias = "init")]
	    pub init: String,
	    #[serde(alias = "node")]
	    pub node: String,
	    #[serde(alias = "channel")]
	    pub channel: String,
	    #[serde(alias = "invoice")]
	    pub invoice: String,
	}

	/// Type of connection
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum GetinfoAddressType {
	    #[serde(rename = "dns")]
	    DNS,
	    #[serde(rename = "ipv4")]
	    IPV4,
	    #[serde(rename = "ipv6")]
	    IPV6,
	    #[serde(rename = "torv2")]
	    TORV2,
	    #[serde(rename = "torv3")]
	    TORV3,
	    #[serde(rename = "websocket")]
	    WEBSOCKET,
	}

	impl TryFrom<i32> for GetinfoAddressType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<GetinfoAddressType, anyhow::Error> {
	        match c {
	    0 => Ok(GetinfoAddressType::DNS),
	    1 => Ok(GetinfoAddressType::IPV4),
	    2 => Ok(GetinfoAddressType::IPV6),
	    3 => Ok(GetinfoAddressType::TORV2),
	    4 => Ok(GetinfoAddressType::TORV3),
	    5 => Ok(GetinfoAddressType::WEBSOCKET),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum GetinfoAddressType", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetinfoAddress {
	    // Path `Getinfo.address[].type`
	    #[serde(rename = "type")]
	    pub item_type: GetinfoAddressType,
	    #[serde(alias = "port")]
	    pub port: u16,
	    #[serde(alias = "address", skip_serializing_if = "Option::is_none")]
	    pub address: Option<String>,
	}

	/// Type of connection
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum GetinfoBindingType {
	    #[serde(rename = "local socket")]
	    LOCAL_SOCKET,
	    #[serde(rename = "ipv4")]
	    IPV4,
	    #[serde(rename = "ipv6")]
	    IPV6,
	    #[serde(rename = "torv2")]
	    TORV2,
	    #[serde(rename = "torv3")]
	    TORV3,
	}

	impl TryFrom<i32> for GetinfoBindingType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<GetinfoBindingType, anyhow::Error> {
	        match c {
	    0 => Ok(GetinfoBindingType::LOCAL_SOCKET),
	    1 => Ok(GetinfoBindingType::IPV4),
	    2 => Ok(GetinfoBindingType::IPV6),
	    3 => Ok(GetinfoBindingType::TORV2),
	    4 => Ok(GetinfoBindingType::TORV3),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum GetinfoBindingType", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetinfoBinding {
	    // Path `Getinfo.binding[].type`
	    #[serde(rename = "type")]
	    pub item_type: GetinfoBindingType,
	    #[serde(alias = "address", skip_serializing_if = "Option::is_none")]
	    pub address: Option<String>,
	    #[serde(alias = "port", skip_serializing_if = "Option::is_none")]
	    pub port: Option<u16>,
	    #[serde(alias = "socket", skip_serializing_if = "Option::is_none")]
	    pub socket: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetinfoResponse {
	    #[serde(alias = "id")]
	    pub id: Pubkey,
	    #[serde(alias = "alias")]
	    pub alias: String,
	    #[serde(alias = "color")]
	    pub color: String,
	    #[serde(alias = "num_peers")]
	    pub num_peers: u32,
	    #[serde(alias = "num_pending_channels")]
	    pub num_pending_channels: u32,
	    #[serde(alias = "num_active_channels")]
	    pub num_active_channels: u32,
	    #[serde(alias = "num_inactive_channels")]
	    pub num_inactive_channels: u32,
	    #[serde(alias = "version")]
	    pub version: String,
	    #[serde(alias = "lightning-dir")]
	    pub lightning_dir: String,
	    #[serde(alias = "blockheight")]
	    pub blockheight: u32,
	    #[serde(alias = "network")]
	    pub network: String,
	    #[serde(alias = "fees_collected_msat")]
	    pub fees_collected_msat: Amount,
	    #[serde(alias = "address", skip_serializing_if = "Option::is_none")]
	    pub address: Option<Vec<GetinfoAddress>>,
	    #[serde(alias = "binding", skip_serializing_if = "Option::is_none")]
	    pub binding: Option<Vec<GetinfoBinding>>,
	    #[serde(alias = "warning_bitcoind_sync", skip_serializing_if = "Option::is_none")]
	    pub warning_bitcoind_sync: Option<String>,
	    #[serde(alias = "warning_lightningd_sync", skip_serializing_if = "Option::is_none")]
	    pub warning_lightningd_sync: Option<String>,
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListpeersPeersLogType {
	    #[serde(rename = "SKIPPED")]
	    SKIPPED,
	    #[serde(rename = "BROKEN")]
	    BROKEN,
	    #[serde(rename = "UNUSUAL")]
	    UNUSUAL,
	    #[serde(rename = "INFO")]
	    INFO,
	    #[serde(rename = "DEBUG")]
	    DEBUG,
	    #[serde(rename = "IO_IN")]
	    IO_IN,
	    #[serde(rename = "IO_OUT")]
	    IO_OUT,
	}

	impl TryFrom<i32> for ListpeersPeersLogType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListpeersPeersLogType, anyhow::Error> {
	        match c {
	    0 => Ok(ListpeersPeersLogType::SKIPPED),
	    1 => Ok(ListpeersPeersLogType::BROKEN),
	    2 => Ok(ListpeersPeersLogType::UNUSUAL),
	    3 => Ok(ListpeersPeersLogType::INFO),
	    4 => Ok(ListpeersPeersLogType::DEBUG),
	    5 => Ok(ListpeersPeersLogType::IO_IN),
	    6 => Ok(ListpeersPeersLogType::IO_OUT),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListpeersPeersLogType", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeersPeersLog {
	    // Path `ListPeers.peers[].log[].type`
	    #[serde(rename = "type")]
	    pub item_type: ListpeersPeersLogType,
	    #[serde(alias = "num_skipped", skip_serializing_if = "Option::is_none")]
	    pub num_skipped: Option<u32>,
	    #[serde(alias = "time", skip_serializing_if = "Option::is_none")]
	    pub time: Option<String>,
	    #[serde(alias = "source", skip_serializing_if = "Option::is_none")]
	    pub source: Option<String>,
	    #[serde(alias = "log", skip_serializing_if = "Option::is_none")]
	    pub log: Option<String>,
	    #[serde(alias = "node_id", skip_serializing_if = "Option::is_none")]
	    pub node_id: Option<Pubkey>,
	    #[serde(alias = "data", skip_serializing_if = "Option::is_none")]
	    pub data: Option<String>,
	}

	/// the channel state, in particular "CHANNELD_NORMAL" means the channel can be used normally
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListpeersPeersChannelsState {
	    #[serde(rename = "OPENINGD")]
	    OPENINGD,
	    #[serde(rename = "CHANNELD_AWAITING_LOCKIN")]
	    CHANNELD_AWAITING_LOCKIN,
	    #[serde(rename = "CHANNELD_NORMAL")]
	    CHANNELD_NORMAL,
	    #[serde(rename = "CHANNELD_SHUTTING_DOWN")]
	    CHANNELD_SHUTTING_DOWN,
	    #[serde(rename = "CLOSINGD_SIGEXCHANGE")]
	    CLOSINGD_SIGEXCHANGE,
	    #[serde(rename = "CLOSINGD_COMPLETE")]
	    CLOSINGD_COMPLETE,
	    #[serde(rename = "AWAITING_UNILATERAL")]
	    AWAITING_UNILATERAL,
	    #[serde(rename = "FUNDING_SPEND_SEEN")]
	    FUNDING_SPEND_SEEN,
	    #[serde(rename = "ONCHAIN")]
	    ONCHAIN,
	    #[serde(rename = "DUALOPEND_OPEN_INIT")]
	    DUALOPEND_OPEN_INIT,
	    #[serde(rename = "DUALOPEND_AWAITING_LOCKIN")]
	    DUALOPEND_AWAITING_LOCKIN,
	}

	impl TryFrom<i32> for ListpeersPeersChannelsState {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListpeersPeersChannelsState, anyhow::Error> {
	        match c {
	    0 => Ok(ListpeersPeersChannelsState::OPENINGD),
	    1 => Ok(ListpeersPeersChannelsState::CHANNELD_AWAITING_LOCKIN),
	    2 => Ok(ListpeersPeersChannelsState::CHANNELD_NORMAL),
	    3 => Ok(ListpeersPeersChannelsState::CHANNELD_SHUTTING_DOWN),
	    4 => Ok(ListpeersPeersChannelsState::CLOSINGD_SIGEXCHANGE),
	    5 => Ok(ListpeersPeersChannelsState::CLOSINGD_COMPLETE),
	    6 => Ok(ListpeersPeersChannelsState::AWAITING_UNILATERAL),
	    7 => Ok(ListpeersPeersChannelsState::FUNDING_SPEND_SEEN),
	    8 => Ok(ListpeersPeersChannelsState::ONCHAIN),
	    9 => Ok(ListpeersPeersChannelsState::DUALOPEND_OPEN_INIT),
	    10 => Ok(ListpeersPeersChannelsState::DUALOPEND_AWAITING_LOCKIN),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListpeersPeersChannelsState", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeersPeersChannelsFeerate {
	    #[serde(alias = "perkw")]
	    pub perkw: u32,
	    #[serde(alias = "perkb")]
	    pub perkb: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeersPeersChannelsInflight {
	    #[serde(alias = "funding_txid")]
	    pub funding_txid: String,
	    #[serde(alias = "funding_outnum")]
	    pub funding_outnum: u32,
	    #[serde(alias = "feerate")]
	    pub feerate: String,
	    #[serde(alias = "total_funding_msat")]
	    pub total_funding_msat: Amount,
	    #[serde(alias = "our_funding_msat")]
	    pub our_funding_msat: Amount,
	    #[serde(alias = "scratch_txid")]
	    pub scratch_txid: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeersPeersChannelsFunding {
	    #[serde(alias = "local_msat")]
	    pub local_msat: Amount,
	    #[serde(alias = "remote_msat")]
	    pub remote_msat: Amount,
	    #[serde(alias = "pushed_msat")]
	    pub pushed_msat: Amount,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeersPeersChannelsState_changes {
	    #[serde(alias = "timestamp")]
	    pub timestamp: String,
	    // Path `ListPeers.peers[].channels[].state_changes[].old_state`
	    #[serde(rename = "old_state")]
	    pub old_state: ChannelState,
	    // Path `ListPeers.peers[].channels[].state_changes[].new_state`
	    #[serde(rename = "new_state")]
	    pub new_state: ChannelState,
	    // Path `ListPeers.peers[].channels[].state_changes[].cause`
	    #[serde(rename = "cause")]
	    pub cause: ChannelStateChangeCause,
	    #[serde(alias = "message")]
	    pub message: String,
	}

	/// Whether it came from peer, or is going to peer
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListpeersPeersChannelsHtlcsDirection {
	    #[serde(rename = "in")]
	    IN,
	    #[serde(rename = "out")]
	    OUT,
	}

	impl TryFrom<i32> for ListpeersPeersChannelsHtlcsDirection {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListpeersPeersChannelsHtlcsDirection, anyhow::Error> {
	        match c {
	    0 => Ok(ListpeersPeersChannelsHtlcsDirection::IN),
	    1 => Ok(ListpeersPeersChannelsHtlcsDirection::OUT),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListpeersPeersChannelsHtlcsDirection", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeersPeersChannelsHtlcs {
	    // Path `ListPeers.peers[].channels[].htlcs[].direction`
	    #[serde(rename = "direction")]
	    pub direction: ListpeersPeersChannelsHtlcsDirection,
	    #[serde(alias = "id")]
	    pub id: u64,
	    #[serde(alias = "amount_msat")]
	    pub amount_msat: Amount,
	    #[serde(alias = "expiry")]
	    pub expiry: u32,
	    #[serde(alias = "payment_hash")]
	    pub payment_hash: Sha256,
	    #[serde(alias = "local_trimmed", skip_serializing_if = "Option::is_none")]
	    pub local_trimmed: Option<bool>,
	    #[serde(alias = "status", skip_serializing_if = "Option::is_none")]
	    pub status: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeersPeersChannels {
	    // Path `ListPeers.peers[].channels[].state`
	    #[serde(rename = "state")]
	    pub state: ListpeersPeersChannelsState,
	    #[serde(alias = "scratch_txid", skip_serializing_if = "Option::is_none")]
	    pub scratch_txid: Option<String>,
	    #[serde(alias = "owner", skip_serializing_if = "Option::is_none")]
	    pub owner: Option<String>,
	    #[serde(alias = "short_channel_id", skip_serializing_if = "Option::is_none")]
	    pub short_channel_id: Option<ShortChannelId>,
	    #[serde(alias = "channel_id", skip_serializing_if = "Option::is_none")]
	    pub channel_id: Option<Sha256>,
	    #[serde(alias = "funding_txid", skip_serializing_if = "Option::is_none")]
	    pub funding_txid: Option<String>,
	    #[serde(alias = "funding_outnum", skip_serializing_if = "Option::is_none")]
	    pub funding_outnum: Option<u32>,
	    #[serde(alias = "initial_feerate", skip_serializing_if = "Option::is_none")]
	    pub initial_feerate: Option<String>,
	    #[serde(alias = "last_feerate", skip_serializing_if = "Option::is_none")]
	    pub last_feerate: Option<String>,
	    #[serde(alias = "next_feerate", skip_serializing_if = "Option::is_none")]
	    pub next_feerate: Option<String>,
	    #[serde(alias = "next_fee_step", skip_serializing_if = "Option::is_none")]
	    pub next_fee_step: Option<u32>,
	    #[serde(alias = "inflight", skip_serializing_if = "Option::is_none")]
	    pub inflight: Option<Vec<ListpeersPeersChannelsInflight>>,
	    #[serde(alias = "close_to", skip_serializing_if = "Option::is_none")]
	    pub close_to: Option<String>,
	    #[serde(alias = "private", skip_serializing_if = "Option::is_none")]
	    pub private: Option<bool>,
	    // Path `ListPeers.peers[].channels[].opener`
	    #[serde(rename = "opener")]
	    pub opener: ChannelSide,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub closer: Option<ChannelSide>,
	    #[serde(alias = "features")]
	    pub features: Vec<String>,
	    #[serde(alias = "to_us_msat", skip_serializing_if = "Option::is_none")]
	    pub to_us_msat: Option<Amount>,
	    #[serde(alias = "min_to_us_msat", skip_serializing_if = "Option::is_none")]
	    pub min_to_us_msat: Option<Amount>,
	    #[serde(alias = "max_to_us_msat", skip_serializing_if = "Option::is_none")]
	    pub max_to_us_msat: Option<Amount>,
	    #[serde(alias = "total_msat", skip_serializing_if = "Option::is_none")]
	    pub total_msat: Option<Amount>,
	    #[serde(alias = "fee_base_msat", skip_serializing_if = "Option::is_none")]
	    pub fee_base_msat: Option<Amount>,
	    #[serde(alias = "fee_proportional_millionths", skip_serializing_if = "Option::is_none")]
	    pub fee_proportional_millionths: Option<u32>,
	    #[serde(alias = "dust_limit_msat", skip_serializing_if = "Option::is_none")]
	    pub dust_limit_msat: Option<Amount>,
	    #[serde(alias = "max_total_htlc_in_msat", skip_serializing_if = "Option::is_none")]
	    pub max_total_htlc_in_msat: Option<Amount>,
	    #[serde(alias = "their_reserve_msat", skip_serializing_if = "Option::is_none")]
	    pub their_reserve_msat: Option<Amount>,
	    #[serde(alias = "our_reserve_msat", skip_serializing_if = "Option::is_none")]
	    pub our_reserve_msat: Option<Amount>,
	    #[serde(alias = "spendable_msat", skip_serializing_if = "Option::is_none")]
	    pub spendable_msat: Option<Amount>,
	    #[serde(alias = "receivable_msat", skip_serializing_if = "Option::is_none")]
	    pub receivable_msat: Option<Amount>,
	    #[serde(alias = "minimum_htlc_in_msat", skip_serializing_if = "Option::is_none")]
	    pub minimum_htlc_in_msat: Option<Amount>,
	    #[serde(alias = "minimum_htlc_out_msat", skip_serializing_if = "Option::is_none")]
	    pub minimum_htlc_out_msat: Option<Amount>,
	    #[serde(alias = "maximum_htlc_out_msat", skip_serializing_if = "Option::is_none")]
	    pub maximum_htlc_out_msat: Option<Amount>,
	    #[serde(alias = "their_to_self_delay", skip_serializing_if = "Option::is_none")]
	    pub their_to_self_delay: Option<u32>,
	    #[serde(alias = "our_to_self_delay", skip_serializing_if = "Option::is_none")]
	    pub our_to_self_delay: Option<u32>,
	    #[serde(alias = "max_accepted_htlcs", skip_serializing_if = "Option::is_none")]
	    pub max_accepted_htlcs: Option<u32>,
	    #[serde(alias = "state_changes", skip_serializing_if = "Option::is_none")]
	    pub state_changes: Option<Vec<ListpeersPeersChannelsState_changes>>,
	    #[serde(alias = "status", skip_serializing_if = "Option::is_none")]
	    pub status: Option<Vec<String>>,
	    #[serde(alias = "in_payments_offered", skip_serializing_if = "Option::is_none")]
	    pub in_payments_offered: Option<u64>,
	    #[serde(alias = "in_offered_msat", skip_serializing_if = "Option::is_none")]
	    pub in_offered_msat: Option<Amount>,
	    #[serde(alias = "in_payments_fulfilled", skip_serializing_if = "Option::is_none")]
	    pub in_payments_fulfilled: Option<u64>,
	    #[serde(alias = "in_fulfilled_msat", skip_serializing_if = "Option::is_none")]
	    pub in_fulfilled_msat: Option<Amount>,
	    #[serde(alias = "out_payments_offered", skip_serializing_if = "Option::is_none")]
	    pub out_payments_offered: Option<u64>,
	    #[serde(alias = "out_offered_msat", skip_serializing_if = "Option::is_none")]
	    pub out_offered_msat: Option<Amount>,
	    #[serde(alias = "out_payments_fulfilled", skip_serializing_if = "Option::is_none")]
	    pub out_payments_fulfilled: Option<u64>,
	    #[serde(alias = "out_fulfilled_msat", skip_serializing_if = "Option::is_none")]
	    pub out_fulfilled_msat: Option<Amount>,
	    #[serde(alias = "htlcs", skip_serializing_if = "Option::is_none")]
	    pub htlcs: Option<Vec<ListpeersPeersChannelsHtlcs>>,
	    #[serde(alias = "close_to_addr", skip_serializing_if = "Option::is_none")]
	    pub close_to_addr: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeersPeers {
	    #[serde(alias = "id")]
	    pub id: Pubkey,
	    #[serde(alias = "connected")]
	    pub connected: bool,
	    #[serde(alias = "log", skip_serializing_if = "Option::is_none")]
	    pub log: Option<Vec<ListpeersPeersLog>>,
	    #[serde(alias = "channels")]
	    pub channels: Vec<ListpeersPeersChannels>,
	    #[serde(alias = "netaddr", skip_serializing_if = "Option::is_none")]
	    pub netaddr: Option<Vec<String>>,
	    #[serde(alias = "features", skip_serializing_if = "Option::is_none")]
	    pub features: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpeersResponse {
	    #[serde(alias = "peers")]
	    pub peers: Vec<ListpeersPeers>,
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListfundsOutputsStatus {
	    #[serde(rename = "unconfirmed")]
	    UNCONFIRMED,
	    #[serde(rename = "confirmed")]
	    CONFIRMED,
	    #[serde(rename = "spent")]
	    SPENT,
	}

	impl TryFrom<i32> for ListfundsOutputsStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListfundsOutputsStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListfundsOutputsStatus::UNCONFIRMED),
	    1 => Ok(ListfundsOutputsStatus::CONFIRMED),
	    2 => Ok(ListfundsOutputsStatus::SPENT),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListfundsOutputsStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListfundsOutputs {
	    #[serde(alias = "txid")]
	    pub txid: String,
	    #[serde(alias = "output")]
	    pub output: u32,
	    #[serde(alias = "amount_msat")]
	    pub amount_msat: Amount,
	    #[serde(alias = "scriptpubkey")]
	    pub scriptpubkey: String,
	    #[serde(alias = "address", skip_serializing_if = "Option::is_none")]
	    pub address: Option<String>,
	    #[serde(alias = "redeemscript", skip_serializing_if = "Option::is_none")]
	    pub redeemscript: Option<String>,
	    // Path `ListFunds.outputs[].status`
	    #[serde(rename = "status")]
	    pub status: ListfundsOutputsStatus,
	    #[serde(alias = "reserved")]
	    pub reserved: bool,
	    #[serde(alias = "blockheight", skip_serializing_if = "Option::is_none")]
	    pub blockheight: Option<u32>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListfundsChannels {
	    #[serde(alias = "peer_id")]
	    pub peer_id: Pubkey,
	    #[serde(alias = "our_amount_msat")]
	    pub our_amount_msat: Amount,
	    #[serde(alias = "amount_msat")]
	    pub amount_msat: Amount,
	    #[serde(alias = "funding_txid")]
	    pub funding_txid: String,
	    #[serde(alias = "funding_output")]
	    pub funding_output: u32,
	    #[serde(alias = "connected")]
	    pub connected: bool,
	    // Path `ListFunds.channels[].state`
	    #[serde(rename = "state")]
	    pub state: ChannelState,
	    #[serde(alias = "short_channel_id", skip_serializing_if = "Option::is_none")]
	    pub short_channel_id: Option<ShortChannelId>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListfundsResponse {
	    #[serde(alias = "outputs")]
	    pub outputs: Vec<ListfundsOutputs>,
	    #[serde(alias = "channels")]
	    pub channels: Vec<ListfundsChannels>,
	}

	/// status of the payment (could be complete if already sent previously)
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum SendpayStatus {
	    #[serde(rename = "pending")]
	    PENDING,
	    #[serde(rename = "complete")]
	    COMPLETE,
	}

	impl TryFrom<i32> for SendpayStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<SendpayStatus, anyhow::Error> {
	        match c {
	    0 => Ok(SendpayStatus::PENDING),
	    1 => Ok(SendpayStatus::COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum SendpayStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendpayResponse {
	    #[serde(alias = "id")]
	    pub id: u64,
	    #[serde(alias = "groupid", skip_serializing_if = "Option::is_none")]
	    pub groupid: Option<u64>,
	    #[serde(alias = "payment_hash")]
	    pub payment_hash: Sha256,
	    // Path `SendPay.status`
	    #[serde(rename = "status")]
	    pub status: SendpayStatus,
	    #[serde(alias = "amount_msat", skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(alias = "destination", skip_serializing_if = "Option::is_none")]
	    pub destination: Option<Pubkey>,
	    #[serde(alias = "created_at")]
	    pub created_at: u64,
	    #[serde(alias = "amount_sent_msat")]
	    pub amount_sent_msat: Amount,
	    #[serde(alias = "label", skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(alias = "partid", skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u64>,
	    #[serde(alias = "bolt11", skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(alias = "bolt12", skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(alias = "payment_preimage", skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	    #[serde(alias = "message", skip_serializing_if = "Option::is_none")]
	    pub message: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListchannelsChannels {
	    #[serde(alias = "source")]
	    pub source: Pubkey,
	    #[serde(alias = "destination")]
	    pub destination: Pubkey,
	    #[serde(alias = "short_channel_id")]
	    pub short_channel_id: ShortChannelId,
	    #[serde(alias = "public")]
	    pub public: bool,
	    #[serde(alias = "amount_msat")]
	    pub amount_msat: Amount,
	    #[serde(alias = "message_flags")]
	    pub message_flags: u8,
	    #[serde(alias = "channel_flags")]
	    pub channel_flags: u8,
	    #[serde(alias = "active")]
	    pub active: bool,
	    #[serde(alias = "last_update")]
	    pub last_update: u32,
	    #[serde(alias = "base_fee_millisatoshi")]
	    pub base_fee_millisatoshi: u32,
	    #[serde(alias = "fee_per_millionth")]
	    pub fee_per_millionth: u32,
	    #[serde(alias = "delay")]
	    pub delay: u32,
	    #[serde(alias = "htlc_minimum_msat")]
	    pub htlc_minimum_msat: Amount,
	    #[serde(alias = "htlc_maximum_msat", skip_serializing_if = "Option::is_none")]
	    pub htlc_maximum_msat: Option<Amount>,
	    #[serde(alias = "features")]
	    pub features: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListchannelsResponse {
	    #[serde(alias = "channels")]
	    pub channels: Vec<ListchannelsChannels>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AddgossipResponse {
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AutocleaninvoiceResponse {
	    #[serde(alias = "enabled")]
	    pub enabled: bool,
	    #[serde(alias = "expired_by", skip_serializing_if = "Option::is_none")]
	    pub expired_by: Option<u64>,
	    #[serde(alias = "cycle_seconds", skip_serializing_if = "Option::is_none")]
	    pub cycle_seconds: Option<u64>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CheckmessageResponse {
	    #[serde(alias = "verified")]
	    pub verified: bool,
	    #[serde(alias = "pubkey", skip_serializing_if = "Option::is_none")]
	    pub pubkey: Option<Pubkey>,
	}

	/// Whether we successfully negotiated a mutual close, closed without them, or discarded not-yet-opened channel
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum CloseType {
	    #[serde(rename = "mutual")]
	    MUTUAL,
	    #[serde(rename = "unilateral")]
	    UNILATERAL,
	    #[serde(rename = "unopened")]
	    UNOPENED,
	}

	impl TryFrom<i32> for CloseType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<CloseType, anyhow::Error> {
	        match c {
	    0 => Ok(CloseType::MUTUAL),
	    1 => Ok(CloseType::UNILATERAL),
	    2 => Ok(CloseType::UNOPENED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum CloseType", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CloseResponse {
	    // Path `Close.type`
	    #[serde(rename = "type")]
	    pub item_type: CloseType,
	    #[serde(alias = "tx", skip_serializing_if = "Option::is_none")]
	    pub tx: Option<String>,
	    #[serde(alias = "txid", skip_serializing_if = "Option::is_none")]
	    pub txid: Option<String>,
	}

	/// Whether they initiated connection or we did
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ConnectDirection {
	    #[serde(rename = "in")]
	    IN,
	    #[serde(rename = "out")]
	    OUT,
	}

	impl TryFrom<i32> for ConnectDirection {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ConnectDirection, anyhow::Error> {
	        match c {
	    0 => Ok(ConnectDirection::IN),
	    1 => Ok(ConnectDirection::OUT),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ConnectDirection", o)),
	        }
	    }
	}
	/// Type of connection (*torv2*/*torv3* only if **direction** is *out*)
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ConnectAddressType {
	    #[serde(rename = "local socket")]
	    LOCAL_SOCKET,
	    #[serde(rename = "ipv4")]
	    IPV4,
	    #[serde(rename = "ipv6")]
	    IPV6,
	    #[serde(rename = "torv2")]
	    TORV2,
	    #[serde(rename = "torv3")]
	    TORV3,
	}

	impl TryFrom<i32> for ConnectAddressType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ConnectAddressType, anyhow::Error> {
	        match c {
	    0 => Ok(ConnectAddressType::LOCAL_SOCKET),
	    1 => Ok(ConnectAddressType::IPV4),
	    2 => Ok(ConnectAddressType::IPV6),
	    3 => Ok(ConnectAddressType::TORV2),
	    4 => Ok(ConnectAddressType::TORV3),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ConnectAddressType", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ConnectAddress {
	    // Path `Connect.address.type`
	    #[serde(rename = "type")]
	    pub item_type: ConnectAddressType,
	    #[serde(alias = "socket", skip_serializing_if = "Option::is_none")]
	    pub socket: Option<String>,
	    #[serde(alias = "address", skip_serializing_if = "Option::is_none")]
	    pub address: Option<String>,
	    #[serde(alias = "port", skip_serializing_if = "Option::is_none")]
	    pub port: Option<u16>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ConnectResponse {
	    #[serde(alias = "id")]
	    pub id: Pubkey,
	    #[serde(alias = "features")]
	    pub features: String,
	    // Path `Connect.direction`
	    #[serde(rename = "direction")]
	    pub direction: ConnectDirection,
	}

	/// Whether it has been paid, or can no longer be paid
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum CreateinvoiceStatus {
	    #[serde(rename = "paid")]
	    PAID,
	    #[serde(rename = "expired")]
	    EXPIRED,
	    #[serde(rename = "unpaid")]
	    UNPAID,
	}

	impl TryFrom<i32> for CreateinvoiceStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<CreateinvoiceStatus, anyhow::Error> {
	        match c {
	    0 => Ok(CreateinvoiceStatus::PAID),
	    1 => Ok(CreateinvoiceStatus::EXPIRED),
	    2 => Ok(CreateinvoiceStatus::UNPAID),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum CreateinvoiceStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CreateinvoiceResponse {
	    #[serde(alias = "label")]
	    pub label: String,
	    #[serde(alias = "bolt11", skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(alias = "bolt12", skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(alias = "payment_hash")]
	    pub payment_hash: Sha256,
	    #[serde(alias = "amount_msat", skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    // Path `CreateInvoice.status`
	    #[serde(rename = "status")]
	    pub status: CreateinvoiceStatus,
	    #[serde(alias = "description")]
	    pub description: String,
	    #[serde(alias = "expires_at")]
	    pub expires_at: u64,
	    #[serde(alias = "pay_index", skip_serializing_if = "Option::is_none")]
	    pub pay_index: Option<u64>,
	    #[serde(alias = "amount_received_msat", skip_serializing_if = "Option::is_none")]
	    pub amount_received_msat: Option<Amount>,
	    #[serde(alias = "paid_at", skip_serializing_if = "Option::is_none")]
	    pub paid_at: Option<u64>,
	    #[serde(alias = "payment_preimage", skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	    #[serde(alias = "local_offer_id", skip_serializing_if = "Option::is_none")]
	    pub local_offer_id: Option<String>,
	    #[serde(alias = "payer_note", skip_serializing_if = "Option::is_none")]
	    pub payer_note: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DatastoreResponse {
	    #[serde(alias = "key")]
	    pub key: Vec<String>,
	    #[serde(alias = "generation", skip_serializing_if = "Option::is_none")]
	    pub generation: Option<u64>,
	    #[serde(alias = "hex", skip_serializing_if = "Option::is_none")]
	    pub hex: Option<String>,
	    #[serde(alias = "string", skip_serializing_if = "Option::is_none")]
	    pub string: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CreateonionResponse {
	    #[serde(alias = "onion")]
	    pub onion: String,
	    #[serde(alias = "shared_secrets")]
	    pub shared_secrets: Vec<Secret>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DeldatastoreResponse {
	    #[serde(alias = "key")]
	    pub key: Vec<String>,
	    #[serde(alias = "generation", skip_serializing_if = "Option::is_none")]
	    pub generation: Option<u64>,
	    #[serde(alias = "hex", skip_serializing_if = "Option::is_none")]
	    pub hex: Option<String>,
	    #[serde(alias = "string", skip_serializing_if = "Option::is_none")]
	    pub string: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DelexpiredinvoiceResponse {
	}

	/// State of invoice
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum DelinvoiceStatus {
	    #[serde(rename = "paid")]
	    PAID,
	    #[serde(rename = "expired")]
	    EXPIRED,
	    #[serde(rename = "unpaid")]
	    UNPAID,
	}

	impl TryFrom<i32> for DelinvoiceStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<DelinvoiceStatus, anyhow::Error> {
	        match c {
	    0 => Ok(DelinvoiceStatus::PAID),
	    1 => Ok(DelinvoiceStatus::EXPIRED),
	    2 => Ok(DelinvoiceStatus::UNPAID),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum DelinvoiceStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DelinvoiceResponse {
	    #[serde(alias = "label")]
	    pub label: String,
	    #[serde(alias = "bolt11", skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(alias = "bolt12", skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(alias = "amount_msat", skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(alias = "description", skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    #[serde(alias = "payment_hash")]
	    pub payment_hash: Sha256,
	    // Path `DelInvoice.status`
	    #[serde(rename = "status")]
	    pub status: DelinvoiceStatus,
	    #[serde(alias = "expires_at")]
	    pub expires_at: u64,
	    #[serde(alias = "local_offer_id", skip_serializing_if = "Option::is_none")]
	    pub local_offer_id: Option<String>,
	    #[serde(alias = "payer_note", skip_serializing_if = "Option::is_none")]
	    pub payer_note: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct InvoiceResponse {
	    #[serde(alias = "bolt11")]
	    pub bolt11: String,
	    #[serde(alias = "payment_hash")]
	    pub payment_hash: Sha256,
	    #[serde(alias = "payment_secret")]
	    pub payment_secret: Secret,
	    #[serde(alias = "expires_at")]
	    pub expires_at: u64,
	    #[serde(alias = "warning_capacity", skip_serializing_if = "Option::is_none")]
	    pub warning_capacity: Option<String>,
	    #[serde(alias = "warning_offline", skip_serializing_if = "Option::is_none")]
	    pub warning_offline: Option<String>,
	    #[serde(alias = "warning_deadends", skip_serializing_if = "Option::is_none")]
	    pub warning_deadends: Option<String>,
	    #[serde(alias = "warning_private_unused", skip_serializing_if = "Option::is_none")]
	    pub warning_private_unused: Option<String>,
	    #[serde(alias = "warning_mpp", skip_serializing_if = "Option::is_none")]
	    pub warning_mpp: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListdatastoreDatastore {
	    #[serde(alias = "key")]
	    pub key: Vec<String>,
	    #[serde(alias = "generation", skip_serializing_if = "Option::is_none")]
	    pub generation: Option<u64>,
	    #[serde(alias = "hex", skip_serializing_if = "Option::is_none")]
	    pub hex: Option<String>,
	    #[serde(alias = "string", skip_serializing_if = "Option::is_none")]
	    pub string: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListdatastoreResponse {
	    #[serde(alias = "datastore")]
	    pub datastore: Vec<ListdatastoreDatastore>,
	}

	/// Whether it's paid, unpaid or unpayable
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListinvoicesInvoicesStatus {
	    #[serde(rename = "unpaid")]
	    UNPAID,
	    #[serde(rename = "paid")]
	    PAID,
	    #[serde(rename = "expired")]
	    EXPIRED,
	}

	impl TryFrom<i32> for ListinvoicesInvoicesStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListinvoicesInvoicesStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListinvoicesInvoicesStatus::UNPAID),
	    1 => Ok(ListinvoicesInvoicesStatus::PAID),
	    2 => Ok(ListinvoicesInvoicesStatus::EXPIRED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListinvoicesInvoicesStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListinvoicesInvoices {
	    #[serde(alias = "label")]
	    pub label: String,
	    #[serde(alias = "description", skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    #[serde(alias = "payment_hash")]
	    pub payment_hash: Sha256,
	    // Path `ListInvoices.invoices[].status`
	    #[serde(rename = "status")]
	    pub status: ListinvoicesInvoicesStatus,
	    #[serde(alias = "expires_at")]
	    pub expires_at: u64,
	    #[serde(alias = "amount_msat", skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(alias = "bolt11", skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(alias = "bolt12", skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(alias = "local_offer_id", skip_serializing_if = "Option::is_none")]
	    pub local_offer_id: Option<String>,
	    #[serde(alias = "payer_note", skip_serializing_if = "Option::is_none")]
	    pub payer_note: Option<String>,
	    #[serde(alias = "pay_index", skip_serializing_if = "Option::is_none")]
	    pub pay_index: Option<u64>,
	    #[serde(alias = "amount_received_msat", skip_serializing_if = "Option::is_none")]
	    pub amount_received_msat: Option<Amount>,
	    #[serde(alias = "paid_at", skip_serializing_if = "Option::is_none")]
	    pub paid_at: Option<u64>,
	    #[serde(alias = "payment_preimage", skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListinvoicesResponse {
	    #[serde(alias = "invoices")]
	    pub invoices: Vec<ListinvoicesInvoices>,
	}

	/// status of the payment (could be complete if already sent previously)
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum SendonionStatus {
	    #[serde(rename = "pending")]
	    PENDING,
	    #[serde(rename = "complete")]
	    COMPLETE,
	}

	impl TryFrom<i32> for SendonionStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<SendonionStatus, anyhow::Error> {
	        match c {
	    0 => Ok(SendonionStatus::PENDING),
	    1 => Ok(SendonionStatus::COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum SendonionStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendonionResponse {
	    #[serde(alias = "id")]
	    pub id: u64,
	    #[serde(alias = "payment_hash")]
	    pub payment_hash: Sha256,
	    // Path `SendOnion.status`
	    #[serde(rename = "status")]
	    pub status: SendonionStatus,
	    #[serde(alias = "amount_msat", skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(alias = "destination", skip_serializing_if = "Option::is_none")]
	    pub destination: Option<Pubkey>,
	    #[serde(alias = "created_at")]
	    pub created_at: u64,
	    #[serde(alias = "amount_sent_msat")]
	    pub amount_sent_msat: Amount,
	    #[serde(alias = "label", skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(alias = "bolt11", skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(alias = "bolt12", skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(alias = "partid", skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u64>,
	    #[serde(alias = "payment_preimage", skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	    #[serde(alias = "message", skip_serializing_if = "Option::is_none")]
	    pub message: Option<String>,
	}

	/// status of the payment
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListsendpaysPaymentsStatus {
	    #[serde(rename = "pending")]
	    PENDING,
	    #[serde(rename = "failed")]
	    FAILED,
	    #[serde(rename = "complete")]
	    COMPLETE,
	}

	impl TryFrom<i32> for ListsendpaysPaymentsStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListsendpaysPaymentsStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListsendpaysPaymentsStatus::PENDING),
	    1 => Ok(ListsendpaysPaymentsStatus::FAILED),
	    2 => Ok(ListsendpaysPaymentsStatus::COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListsendpaysPaymentsStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListsendpaysPayments {
	    #[serde(alias = "id")]
	    pub id: u64,
	    #[serde(alias = "groupid", skip_serializing_if = "Option::is_none")]
	    pub groupid: Option<u64>,
	    #[serde(alias = "payment_hash")]
	    pub payment_hash: Sha256,
	    // Path `ListSendPays.payments[].status`
	    #[serde(rename = "status")]
	    pub status: ListsendpaysPaymentsStatus,
	    #[serde(alias = "amount_msat", skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(alias = "destination", skip_serializing_if = "Option::is_none")]
	    pub destination: Option<Pubkey>,
	    #[serde(alias = "created_at")]
	    pub created_at: u64,
	    #[serde(alias = "amount_sent_msat")]
	    pub amount_sent_msat: Amount,
	    #[serde(alias = "label", skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(alias = "bolt11", skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(alias = "description", skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    #[serde(alias = "bolt12", skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(alias = "payment_preimage", skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	    #[serde(alias = "erroronion", skip_serializing_if = "Option::is_none")]
	    pub erroronion: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListsendpaysResponse {
	    #[serde(alias = "payments")]
	    pub payments: Vec<ListsendpaysPayments>,
	}

	/// the purpose of this input (*EXPERIMENTAL_FEATURES* only)
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListtransactionsTransactionsInputsType {
	    #[serde(rename = "theirs")]
	    THEIRS,
	    #[serde(rename = "deposit")]
	    DEPOSIT,
	    #[serde(rename = "withdraw")]
	    WITHDRAW,
	    #[serde(rename = "channel_funding")]
	    CHANNEL_FUNDING,
	    #[serde(rename = "channel_mutual_close")]
	    CHANNEL_MUTUAL_CLOSE,
	    #[serde(rename = "channel_unilateral_close")]
	    CHANNEL_UNILATERAL_CLOSE,
	    #[serde(rename = "channel_sweep")]
	    CHANNEL_SWEEP,
	    #[serde(rename = "channel_htlc_success")]
	    CHANNEL_HTLC_SUCCESS,
	    #[serde(rename = "channel_htlc_timeout")]
	    CHANNEL_HTLC_TIMEOUT,
	    #[serde(rename = "channel_penalty")]
	    CHANNEL_PENALTY,
	    #[serde(rename = "channel_unilateral_cheat")]
	    CHANNEL_UNILATERAL_CHEAT,
	}

	impl TryFrom<i32> for ListtransactionsTransactionsInputsType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListtransactionsTransactionsInputsType, anyhow::Error> {
	        match c {
	    0 => Ok(ListtransactionsTransactionsInputsType::THEIRS),
	    1 => Ok(ListtransactionsTransactionsInputsType::DEPOSIT),
	    2 => Ok(ListtransactionsTransactionsInputsType::WITHDRAW),
	    3 => Ok(ListtransactionsTransactionsInputsType::CHANNEL_FUNDING),
	    4 => Ok(ListtransactionsTransactionsInputsType::CHANNEL_MUTUAL_CLOSE),
	    5 => Ok(ListtransactionsTransactionsInputsType::CHANNEL_UNILATERAL_CLOSE),
	    6 => Ok(ListtransactionsTransactionsInputsType::CHANNEL_SWEEP),
	    7 => Ok(ListtransactionsTransactionsInputsType::CHANNEL_HTLC_SUCCESS),
	    8 => Ok(ListtransactionsTransactionsInputsType::CHANNEL_HTLC_TIMEOUT),
	    9 => Ok(ListtransactionsTransactionsInputsType::CHANNEL_PENALTY),
	    10 => Ok(ListtransactionsTransactionsInputsType::CHANNEL_UNILATERAL_CHEAT),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListtransactionsTransactionsInputsType", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListtransactionsTransactionsInputs {
	    #[serde(alias = "txid")]
	    pub txid: String,
	    #[serde(alias = "index")]
	    pub index: u32,
	    #[serde(alias = "sequence")]
	    pub sequence: u32,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub item_type: Option<ListtransactionsTransactionsInputsType>,
	    #[serde(alias = "channel", skip_serializing_if = "Option::is_none")]
	    pub channel: Option<ShortChannelId>,
	}

	/// the purpose of this output (*EXPERIMENTAL_FEATURES* only)
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListtransactionsTransactionsOutputsType {
	    #[serde(rename = "theirs")]
	    THEIRS,
	    #[serde(rename = "deposit")]
	    DEPOSIT,
	    #[serde(rename = "withdraw")]
	    WITHDRAW,
	    #[serde(rename = "channel_funding")]
	    CHANNEL_FUNDING,
	    #[serde(rename = "channel_mutual_close")]
	    CHANNEL_MUTUAL_CLOSE,
	    #[serde(rename = "channel_unilateral_close")]
	    CHANNEL_UNILATERAL_CLOSE,
	    #[serde(rename = "channel_sweep")]
	    CHANNEL_SWEEP,
	    #[serde(rename = "channel_htlc_success")]
	    CHANNEL_HTLC_SUCCESS,
	    #[serde(rename = "channel_htlc_timeout")]
	    CHANNEL_HTLC_TIMEOUT,
	    #[serde(rename = "channel_penalty")]
	    CHANNEL_PENALTY,
	    #[serde(rename = "channel_unilateral_cheat")]
	    CHANNEL_UNILATERAL_CHEAT,
	}

	impl TryFrom<i32> for ListtransactionsTransactionsOutputsType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListtransactionsTransactionsOutputsType, anyhow::Error> {
	        match c {
	    0 => Ok(ListtransactionsTransactionsOutputsType::THEIRS),
	    1 => Ok(ListtransactionsTransactionsOutputsType::DEPOSIT),
	    2 => Ok(ListtransactionsTransactionsOutputsType::WITHDRAW),
	    3 => Ok(ListtransactionsTransactionsOutputsType::CHANNEL_FUNDING),
	    4 => Ok(ListtransactionsTransactionsOutputsType::CHANNEL_MUTUAL_CLOSE),
	    5 => Ok(ListtransactionsTransactionsOutputsType::CHANNEL_UNILATERAL_CLOSE),
	    6 => Ok(ListtransactionsTransactionsOutputsType::CHANNEL_SWEEP),
	    7 => Ok(ListtransactionsTransactionsOutputsType::CHANNEL_HTLC_SUCCESS),
	    8 => Ok(ListtransactionsTransactionsOutputsType::CHANNEL_HTLC_TIMEOUT),
	    9 => Ok(ListtransactionsTransactionsOutputsType::CHANNEL_PENALTY),
	    10 => Ok(ListtransactionsTransactionsOutputsType::CHANNEL_UNILATERAL_CHEAT),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListtransactionsTransactionsOutputsType", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListtransactionsTransactionsOutputs {
	    #[serde(alias = "index")]
	    pub index: u32,
	    #[serde(alias = "amount_msat")]
	    pub amount_msat: Amount,
	    #[serde(alias = "scriptPubKey")]
	    pub script_pub_key: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub item_type: Option<ListtransactionsTransactionsOutputsType>,
	    #[serde(alias = "channel", skip_serializing_if = "Option::is_none")]
	    pub channel: Option<ShortChannelId>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListtransactionsTransactions {
	    #[serde(alias = "hash")]
	    pub hash: String,
	    #[serde(alias = "rawtx")]
	    pub rawtx: String,
	    #[serde(alias = "blockheight")]
	    pub blockheight: u32,
	    #[serde(alias = "txindex")]
	    pub txindex: u32,
	    #[serde(alias = "channel", skip_serializing_if = "Option::is_none")]
	    pub channel: Option<ShortChannelId>,
	    #[serde(alias = "locktime")]
	    pub locktime: u32,
	    #[serde(alias = "version")]
	    pub version: u32,
	    #[serde(alias = "inputs")]
	    pub inputs: Vec<ListtransactionsTransactionsInputs>,
	    #[serde(alias = "outputs")]
	    pub outputs: Vec<ListtransactionsTransactionsOutputs>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListtransactionsResponse {
	    #[serde(alias = "transactions")]
	    pub transactions: Vec<ListtransactionsTransactions>,
	}

	/// status of payment
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum PayStatus {
	    #[serde(rename = "complete")]
	    COMPLETE,
	    #[serde(rename = "pending")]
	    PENDING,
	    #[serde(rename = "failed")]
	    FAILED,
	}

	impl TryFrom<i32> for PayStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<PayStatus, anyhow::Error> {
	        match c {
	    0 => Ok(PayStatus::COMPLETE),
	    1 => Ok(PayStatus::PENDING),
	    2 => Ok(PayStatus::FAILED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum PayStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct PayResponse {
	    #[serde(alias = "payment_preimage")]
	    pub payment_preimage: Secret,
	    #[serde(alias = "destination", skip_serializing_if = "Option::is_none")]
	    pub destination: Option<Pubkey>,
	    #[serde(alias = "payment_hash")]
	    pub payment_hash: Sha256,
	    #[serde(alias = "created_at")]
	    pub created_at: f64,
	    #[serde(alias = "parts")]
	    pub parts: u32,
	    #[serde(alias = "amount_msat")]
	    pub amount_msat: Amount,
	    #[serde(alias = "amount_sent_msat")]
	    pub amount_sent_msat: Amount,
	    #[serde(alias = "warning_partial_completion", skip_serializing_if = "Option::is_none")]
	    pub warning_partial_completion: Option<String>,
	    // Path `Pay.status`
	    #[serde(rename = "status")]
	    pub status: PayStatus,
	}

	/// Type of connection
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListnodesNodesAddressesType {
	    #[serde(rename = "dns")]
	    DNS,
	    #[serde(rename = "ipv4")]
	    IPV4,
	    #[serde(rename = "ipv6")]
	    IPV6,
	    #[serde(rename = "torv2")]
	    TORV2,
	    #[serde(rename = "torv3")]
	    TORV3,
	    #[serde(rename = "websocket")]
	    WEBSOCKET,
	}

	impl TryFrom<i32> for ListnodesNodesAddressesType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListnodesNodesAddressesType, anyhow::Error> {
	        match c {
	    0 => Ok(ListnodesNodesAddressesType::DNS),
	    1 => Ok(ListnodesNodesAddressesType::IPV4),
	    2 => Ok(ListnodesNodesAddressesType::IPV6),
	    3 => Ok(ListnodesNodesAddressesType::TORV2),
	    4 => Ok(ListnodesNodesAddressesType::TORV3),
	    5 => Ok(ListnodesNodesAddressesType::WEBSOCKET),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListnodesNodesAddressesType", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListnodesNodesAddresses {
	    // Path `ListNodes.nodes[].addresses[].type`
	    #[serde(rename = "type")]
	    pub item_type: ListnodesNodesAddressesType,
	    #[serde(alias = "port")]
	    pub port: u16,
	    #[serde(alias = "address", skip_serializing_if = "Option::is_none")]
	    pub address: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListnodesNodes {
	    #[serde(alias = "nodeid")]
	    pub nodeid: Pubkey,
	    #[serde(alias = "last_timestamp", skip_serializing_if = "Option::is_none")]
	    pub last_timestamp: Option<u32>,
	    #[serde(alias = "alias", skip_serializing_if = "Option::is_none")]
	    pub alias: Option<String>,
	    #[serde(alias = "color", skip_serializing_if = "Option::is_none")]
	    pub color: Option<String>,
	    #[serde(alias = "features", skip_serializing_if = "Option::is_none")]
	    pub features: Option<String>,
	    #[serde(alias = "addresses", skip_serializing_if = "Option::is_none")]
	    pub addresses: Option<Vec<ListnodesNodesAddresses>>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListnodesResponse {
	    #[serde(alias = "nodes")]
	    pub nodes: Vec<ListnodesNodes>,
	}

	/// Whether it's paid or expired
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum WaitanyinvoiceStatus {
	    #[serde(rename = "paid")]
	    PAID,
	    #[serde(rename = "expired")]
	    EXPIRED,
	}

	impl TryFrom<i32> for WaitanyinvoiceStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<WaitanyinvoiceStatus, anyhow::Error> {
	        match c {
	    0 => Ok(WaitanyinvoiceStatus::PAID),
	    1 => Ok(WaitanyinvoiceStatus::EXPIRED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum WaitanyinvoiceStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitanyinvoiceResponse {
	    #[serde(alias = "label")]
	    pub label: String,
	    #[serde(alias = "description")]
	    pub description: String,
	    #[serde(alias = "payment_hash")]
	    pub payment_hash: Sha256,
	    // Path `WaitAnyInvoice.status`
	    #[serde(rename = "status")]
	    pub status: WaitanyinvoiceStatus,
	    #[serde(alias = "expires_at")]
	    pub expires_at: u64,
	    #[serde(alias = "amount_msat", skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(alias = "bolt11", skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(alias = "bolt12", skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(alias = "pay_index", skip_serializing_if = "Option::is_none")]
	    pub pay_index: Option<u64>,
	    #[serde(alias = "amount_received_msat", skip_serializing_if = "Option::is_none")]
	    pub amount_received_msat: Option<Amount>,
	    #[serde(alias = "paid_at", skip_serializing_if = "Option::is_none")]
	    pub paid_at: Option<u64>,
	    #[serde(alias = "payment_preimage", skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	}

	/// Whether it's paid or expired
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum WaitinvoiceStatus {
	    #[serde(rename = "paid")]
	    PAID,
	    #[serde(rename = "expired")]
	    EXPIRED,
	}

	impl TryFrom<i32> for WaitinvoiceStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<WaitinvoiceStatus, anyhow::Error> {
	        match c {
	    0 => Ok(WaitinvoiceStatus::PAID),
	    1 => Ok(WaitinvoiceStatus::EXPIRED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum WaitinvoiceStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitinvoiceResponse {
	    #[serde(alias = "label")]
	    pub label: String,
	    #[serde(alias = "description")]
	    pub description: String,
	    #[serde(alias = "payment_hash")]
	    pub payment_hash: Sha256,
	    // Path `WaitInvoice.status`
	    #[serde(rename = "status")]
	    pub status: WaitinvoiceStatus,
	    #[serde(alias = "expires_at")]
	    pub expires_at: u64,
	    #[serde(alias = "amount_msat", skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(alias = "bolt11", skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(alias = "bolt12", skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(alias = "pay_index", skip_serializing_if = "Option::is_none")]
	    pub pay_index: Option<u64>,
	    #[serde(alias = "amount_received_msat", skip_serializing_if = "Option::is_none")]
	    pub amount_received_msat: Option<Amount>,
	    #[serde(alias = "paid_at", skip_serializing_if = "Option::is_none")]
	    pub paid_at: Option<u64>,
	    #[serde(alias = "payment_preimage", skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	}

	/// status of the payment
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum WaitsendpayStatus {
	    #[serde(rename = "complete")]
	    COMPLETE,
	}

	impl TryFrom<i32> for WaitsendpayStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<WaitsendpayStatus, anyhow::Error> {
	        match c {
	    0 => Ok(WaitsendpayStatus::COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum WaitsendpayStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitsendpayResponse {
	    #[serde(alias = "id")]
	    pub id: u64,
	    #[serde(alias = "groupid", skip_serializing_if = "Option::is_none")]
	    pub groupid: Option<u64>,
	    #[serde(alias = "payment_hash")]
	    pub payment_hash: Sha256,
	    // Path `WaitSendPay.status`
	    #[serde(rename = "status")]
	    pub status: WaitsendpayStatus,
	    #[serde(alias = "amount_msat", skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(alias = "destination", skip_serializing_if = "Option::is_none")]
	    pub destination: Option<Pubkey>,
	    #[serde(alias = "created_at")]
	    pub created_at: u64,
	    #[serde(alias = "amount_sent_msat")]
	    pub amount_sent_msat: Amount,
	    #[serde(alias = "label", skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(alias = "partid", skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u64>,
	    #[serde(alias = "bolt11", skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(alias = "bolt12", skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(alias = "payment_preimage", skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct NewaddrResponse {
	    #[serde(alias = "bech32", skip_serializing_if = "Option::is_none")]
	    pub bech32: Option<String>,
	    #[serde(alias = "p2sh-segwit", skip_serializing_if = "Option::is_none")]
	    pub p2sh_segwit: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WithdrawResponse {
	    #[serde(alias = "tx")]
	    pub tx: String,
	    #[serde(alias = "txid")]
	    pub txid: String,
	    #[serde(alias = "psbt")]
	    pub psbt: String,
	}

	/// status of payment
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum KeysendStatus {
	    #[serde(rename = "complete")]
	    COMPLETE,
	}

	impl TryFrom<i32> for KeysendStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<KeysendStatus, anyhow::Error> {
	        match c {
	    0 => Ok(KeysendStatus::COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum KeysendStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct KeysendResponse {
	    #[serde(alias = "payment_preimage")]
	    pub payment_preimage: Secret,
	    #[serde(alias = "destination", skip_serializing_if = "Option::is_none")]
	    pub destination: Option<Pubkey>,
	    #[serde(alias = "payment_hash")]
	    pub payment_hash: Sha256,
	    #[serde(alias = "created_at")]
	    pub created_at: f64,
	    #[serde(alias = "parts")]
	    pub parts: u32,
	    #[serde(alias = "amount_msat")]
	    pub amount_msat: Amount,
	    #[serde(alias = "amount_sent_msat")]
	    pub amount_sent_msat: Amount,
	    #[serde(alias = "warning_partial_completion", skip_serializing_if = "Option::is_none")]
	    pub warning_partial_completion: Option<String>,
	    // Path `KeySend.status`
	    #[serde(rename = "status")]
	    pub status: KeysendStatus,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FundpsbtReservations {
	    #[serde(alias = "txid")]
	    pub txid: String,
	    #[serde(alias = "vout")]
	    pub vout: u32,
	    #[serde(alias = "was_reserved")]
	    pub was_reserved: bool,
	    #[serde(alias = "reserved")]
	    pub reserved: bool,
	    #[serde(alias = "reserved_to_block")]
	    pub reserved_to_block: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FundpsbtResponse {
	    #[serde(alias = "psbt")]
	    pub psbt: String,
	    #[serde(alias = "feerate_per_kw")]
	    pub feerate_per_kw: u32,
	    #[serde(alias = "estimated_final_weight")]
	    pub estimated_final_weight: u32,
	    #[serde(alias = "excess_msat")]
	    pub excess_msat: Amount,
	    #[serde(alias = "change_outnum", skip_serializing_if = "Option::is_none")]
	    pub change_outnum: Option<u32>,
	    #[serde(alias = "reservations", skip_serializing_if = "Option::is_none")]
	    pub reservations: Option<Vec<FundpsbtReservations>>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendpsbtResponse {
	    #[serde(alias = "tx")]
	    pub tx: String,
	    #[serde(alias = "txid")]
	    pub txid: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SignpsbtResponse {
	    #[serde(alias = "signed_psbt")]
	    pub signed_psbt: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct UtxopsbtReservations {
	    #[serde(alias = "txid")]
	    pub txid: String,
	    #[serde(alias = "vout")]
	    pub vout: u32,
	    #[serde(alias = "was_reserved")]
	    pub was_reserved: bool,
	    #[serde(alias = "reserved")]
	    pub reserved: bool,
	    #[serde(alias = "reserved_to_block")]
	    pub reserved_to_block: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct UtxopsbtResponse {
	    #[serde(alias = "psbt")]
	    pub psbt: String,
	    #[serde(alias = "feerate_per_kw")]
	    pub feerate_per_kw: u32,
	    #[serde(alias = "estimated_final_weight")]
	    pub estimated_final_weight: u32,
	    #[serde(alias = "excess_msat")]
	    pub excess_msat: Amount,
	    #[serde(alias = "change_outnum", skip_serializing_if = "Option::is_none")]
	    pub change_outnum: Option<u32>,
	    #[serde(alias = "reservations", skip_serializing_if = "Option::is_none")]
	    pub reservations: Option<Vec<UtxopsbtReservations>>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct TxdiscardResponse {
	    #[serde(alias = "unsigned_tx")]
	    pub unsigned_tx: String,
	    #[serde(alias = "txid")]
	    pub txid: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct TxprepareResponse {
	    #[serde(alias = "psbt")]
	    pub psbt: String,
	    #[serde(alias = "unsigned_tx")]
	    pub unsigned_tx: String,
	    #[serde(alias = "txid")]
	    pub txid: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct TxsendResponse {
	    #[serde(alias = "psbt")]
	    pub psbt: String,
	    #[serde(alias = "tx")]
	    pub tx: String,
	    #[serde(alias = "txid")]
	    pub txid: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DisconnectResponse {
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FeeratesPerkb {
	    #[serde(alias = "min_acceptable")]
	    pub min_acceptable: u32,
	    #[serde(alias = "max_acceptable")]
	    pub max_acceptable: u32,
	    #[serde(alias = "opening", skip_serializing_if = "Option::is_none")]
	    pub opening: Option<u32>,
	    #[serde(alias = "mutual_close", skip_serializing_if = "Option::is_none")]
	    pub mutual_close: Option<u32>,
	    #[serde(alias = "unilateral_close", skip_serializing_if = "Option::is_none")]
	    pub unilateral_close: Option<u32>,
	    #[serde(alias = "delayed_to_us", skip_serializing_if = "Option::is_none")]
	    pub delayed_to_us: Option<u32>,
	    #[serde(alias = "htlc_resolution", skip_serializing_if = "Option::is_none")]
	    pub htlc_resolution: Option<u32>,
	    #[serde(alias = "penalty", skip_serializing_if = "Option::is_none")]
	    pub penalty: Option<u32>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FeeratesPerkw {
	    #[serde(alias = "min_acceptable")]
	    pub min_acceptable: u32,
	    #[serde(alias = "max_acceptable")]
	    pub max_acceptable: u32,
	    #[serde(alias = "opening", skip_serializing_if = "Option::is_none")]
	    pub opening: Option<u32>,
	    #[serde(alias = "mutual_close", skip_serializing_if = "Option::is_none")]
	    pub mutual_close: Option<u32>,
	    #[serde(alias = "unilateral_close", skip_serializing_if = "Option::is_none")]
	    pub unilateral_close: Option<u32>,
	    #[serde(alias = "delayed_to_us", skip_serializing_if = "Option::is_none")]
	    pub delayed_to_us: Option<u32>,
	    #[serde(alias = "htlc_resolution", skip_serializing_if = "Option::is_none")]
	    pub htlc_resolution: Option<u32>,
	    #[serde(alias = "penalty", skip_serializing_if = "Option::is_none")]
	    pub penalty: Option<u32>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FeeratesOnchain_fee_estimates {
	    #[serde(alias = "opening_channel_satoshis")]
	    pub opening_channel_satoshis: u64,
	    #[serde(alias = "mutual_close_satoshis")]
	    pub mutual_close_satoshis: u64,
	    #[serde(alias = "unilateral_close_satoshis")]
	    pub unilateral_close_satoshis: u64,
	    #[serde(alias = "htlc_timeout_satoshis")]
	    pub htlc_timeout_satoshis: u64,
	    #[serde(alias = "htlc_success_satoshis")]
	    pub htlc_success_satoshis: u64,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FeeratesResponse {
	    #[serde(alias = "warning_missing_feerates", skip_serializing_if = "Option::is_none")]
	    pub warning_missing_feerates: Option<String>,
	}

	/// The features understood by the destination node
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum GetrouteRouteStyle {
	    #[serde(rename = "tlv")]
	    TLV,
	}

	impl TryFrom<i32> for GetrouteRouteStyle {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<GetrouteRouteStyle, anyhow::Error> {
	        match c {
	    0 => Ok(GetrouteRouteStyle::TLV),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum GetrouteRouteStyle", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetrouteRoute {
	    #[serde(alias = "id")]
	    pub id: Pubkey,
	    #[serde(alias = "channel")]
	    pub channel: ShortChannelId,
	    #[serde(alias = "direction")]
	    pub direction: u32,
	    #[serde(alias = "amount_msat")]
	    pub amount_msat: Amount,
	    #[serde(alias = "delay")]
	    pub delay: u32,
	    // Path `GetRoute.route[].style`
	    #[serde(rename = "style")]
	    pub style: GetrouteRouteStyle,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetrouteResponse {
	    #[serde(alias = "route")]
	    pub route: Vec<GetrouteRoute>,
	}

	/// still ongoing, completed, failed locally, or failed after forwarding
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListforwardsForwardsStatus {
	    #[serde(rename = "offered")]
	    OFFERED,
	    #[serde(rename = "settled")]
	    SETTLED,
	    #[serde(rename = "local_failed")]
	    LOCAL_FAILED,
	    #[serde(rename = "failed")]
	    FAILED,
	}

	impl TryFrom<i32> for ListforwardsForwardsStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListforwardsForwardsStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListforwardsForwardsStatus::OFFERED),
	    1 => Ok(ListforwardsForwardsStatus::SETTLED),
	    2 => Ok(ListforwardsForwardsStatus::LOCAL_FAILED),
	    3 => Ok(ListforwardsForwardsStatus::FAILED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListforwardsForwardsStatus", o)),
	        }
	    }
	}
	/// Either a legacy onion format or a modern tlv format
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListforwardsForwardsStyle {
	    #[serde(rename = "legacy")]
	    LEGACY,
	    #[serde(rename = "tlv")]
	    TLV,
	}

	impl TryFrom<i32> for ListforwardsForwardsStyle {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListforwardsForwardsStyle, anyhow::Error> {
	        match c {
	    0 => Ok(ListforwardsForwardsStyle::LEGACY),
	    1 => Ok(ListforwardsForwardsStyle::TLV),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListforwardsForwardsStyle", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListforwardsForwards {
	    #[serde(alias = "in_channel")]
	    pub in_channel: ShortChannelId,
	    #[serde(alias = "in_msat")]
	    pub in_msat: Amount,
	    // Path `ListForwards.forwards[].status`
	    #[serde(rename = "status")]
	    pub status: ListforwardsForwardsStatus,
	    #[serde(alias = "received_time")]
	    pub received_time: f64,
	    #[serde(alias = "out_channel", skip_serializing_if = "Option::is_none")]
	    pub out_channel: Option<ShortChannelId>,
	    #[serde(alias = "payment_hash", skip_serializing_if = "Option::is_none")]
	    pub payment_hash: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub style: Option<ListforwardsForwardsStyle>,
	    #[serde(alias = "fee_msat", skip_serializing_if = "Option::is_none")]
	    pub fee_msat: Option<Amount>,
	    #[serde(alias = "out_msat", skip_serializing_if = "Option::is_none")]
	    pub out_msat: Option<Amount>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListforwardsResponse {
	    #[serde(alias = "forwards")]
	    pub forwards: Vec<ListforwardsForwards>,
	}

	/// status of the payment
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListpaysPaysStatus {
	    #[serde(rename = "pending")]
	    PENDING,
	    #[serde(rename = "failed")]
	    FAILED,
	    #[serde(rename = "complete")]
	    COMPLETE,
	}

	impl TryFrom<i32> for ListpaysPaysStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListpaysPaysStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListpaysPaysStatus::PENDING),
	    1 => Ok(ListpaysPaysStatus::FAILED),
	    2 => Ok(ListpaysPaysStatus::COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListpaysPaysStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpaysPays {
	    #[serde(alias = "payment_hash")]
	    pub payment_hash: String,
	    // Path `ListPays.pays[].status`
	    #[serde(rename = "status")]
	    pub status: ListpaysPaysStatus,
	    #[serde(alias = "destination", skip_serializing_if = "Option::is_none")]
	    pub destination: Option<Pubkey>,
	    #[serde(alias = "created_at")]
	    pub created_at: u64,
	    #[serde(alias = "label", skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(alias = "bolt11", skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(alias = "description", skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    #[serde(alias = "bolt12", skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(alias = "amount_msat", skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(alias = "amount_sent_msat", skip_serializing_if = "Option::is_none")]
	    pub amount_sent_msat: Option<Amount>,
	    #[serde(alias = "erroronion", skip_serializing_if = "Option::is_none")]
	    pub erroronion: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListpaysResponse {
	    #[serde(alias = "pays")]
	    pub pays: Vec<ListpaysPays>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct PingResponse {
	    #[serde(alias = "totlen")]
	    pub totlen: u16,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SignmessageResponse {
	    #[serde(alias = "signature")]
	    pub signature: String,
	    #[serde(alias = "recid")]
	    pub recid: String,
	    #[serde(alias = "zbase")]
	    pub zbase: String,
	}

}

