#include "config.h"
#undef CLN_NEXT_VERSION
#define CLN_NEXT_VERSION test_next_version

static const char *test_next_version;

#include "../deprecation.c"
#include <common/amount.h>
#include <common/setup.h>
#include <stdio.h>
#include <wire/wire.h>

/* AUTOGENERATED MOCKS START */
/* Generated stub for amount_asset_is_main */
bool amount_asset_is_main(struct amount_asset *asset UNNEEDED)
{ fprintf(stderr, "amount_asset_is_main called!\n"); abort(); }
/* Generated stub for amount_asset_to_sat */
struct amount_sat amount_asset_to_sat(struct amount_asset *asset UNNEEDED)
{ fprintf(stderr, "amount_asset_to_sat called!\n"); abort(); }
/* Generated stub for amount_feerate */
 bool amount_feerate(u32 *feerate UNNEEDED, struct amount_sat fee UNNEEDED, size_t weight UNNEEDED)
{ fprintf(stderr, "amount_feerate called!\n"); abort(); }
/* Generated stub for amount_sat */
struct amount_sat amount_sat(u64 satoshis UNNEEDED)
{ fprintf(stderr, "amount_sat called!\n"); abort(); }
/* Generated stub for amount_sat_add */
 bool amount_sat_add(struct amount_sat *val UNNEEDED,
				       struct amount_sat a UNNEEDED,
				       struct amount_sat b UNNEEDED)
{ fprintf(stderr, "amount_sat_add called!\n"); abort(); }
/* Generated stub for amount_sat_eq */
bool amount_sat_eq(struct amount_sat a UNNEEDED, struct amount_sat b UNNEEDED)
{ fprintf(stderr, "amount_sat_eq called!\n"); abort(); }
/* Generated stub for amount_sat_greater_eq */
bool amount_sat_greater_eq(struct amount_sat a UNNEEDED, struct amount_sat b UNNEEDED)
{ fprintf(stderr, "amount_sat_greater_eq called!\n"); abort(); }
/* Generated stub for amount_sat_sub */
 bool amount_sat_sub(struct amount_sat *val UNNEEDED,
				       struct amount_sat a UNNEEDED,
				       struct amount_sat b UNNEEDED)
{ fprintf(stderr, "amount_sat_sub called!\n"); abort(); }
/* Generated stub for amount_sat_to_asset */
struct amount_asset amount_sat_to_asset(struct amount_sat *sat UNNEEDED, const u8 *asset UNNEEDED)
{ fprintf(stderr, "amount_sat_to_asset called!\n"); abort(); }
/* Generated stub for amount_tx_fee */
struct amount_sat amount_tx_fee(u32 fee_per_kw UNNEEDED, size_t weight UNNEEDED)
{ fprintf(stderr, "amount_tx_fee called!\n"); abort(); }
/* Generated stub for fromwire */
const u8 *fromwire(const u8 **cursor UNNEEDED, size_t *max UNNEEDED, void *copy UNNEEDED, size_t n UNNEEDED)
{ fprintf(stderr, "fromwire called!\n"); abort(); }
/* Generated stub for fromwire_bool */
bool fromwire_bool(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_bool called!\n"); abort(); }
/* Generated stub for fromwire_fail */
void *fromwire_fail(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_fail called!\n"); abort(); }
/* Generated stub for fromwire_secp256k1_ecdsa_signature */
void fromwire_secp256k1_ecdsa_signature(const u8 **cursor UNNEEDED, size_t *max UNNEEDED,
					secp256k1_ecdsa_signature *signature UNNEEDED)
{ fprintf(stderr, "fromwire_secp256k1_ecdsa_signature called!\n"); abort(); }
/* Generated stub for fromwire_sha256 */
void fromwire_sha256(const u8 **cursor UNNEEDED, size_t *max UNNEEDED, struct sha256 *sha256 UNNEEDED)
{ fprintf(stderr, "fromwire_sha256 called!\n"); abort(); }
/* Generated stub for fromwire_tal_arrn */
u8 *fromwire_tal_arrn(const tal_t *ctx UNNEEDED,
		       const u8 **cursor UNNEEDED, size_t *max UNNEEDED, size_t num UNNEEDED)
{ fprintf(stderr, "fromwire_tal_arrn called!\n"); abort(); }
/* Generated stub for fromwire_u32 */
u32 fromwire_u32(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_u32 called!\n"); abort(); }
/* Generated stub for fromwire_u64 */
u64 fromwire_u64(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_u64 called!\n"); abort(); }
/* Generated stub for fromwire_u8 */
u8 fromwire_u8(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_u8 called!\n"); abort(); }
/* Generated stub for fromwire_u8_array */
void fromwire_u8_array(const u8 **cursor UNNEEDED, size_t *max UNNEEDED, u8 *arr UNNEEDED, size_t num UNNEEDED)
{ fprintf(stderr, "fromwire_u8_array called!\n"); abort(); }
/* Generated stub for towire */
void towire(u8 **pptr UNNEEDED, const void *data UNNEEDED, size_t len UNNEEDED)
{ fprintf(stderr, "towire called!\n"); abort(); }
/* Generated stub for towire_bool */
void towire_bool(u8 **pptr UNNEEDED, bool v UNNEEDED)
{ fprintf(stderr, "towire_bool called!\n"); abort(); }
/* Generated stub for towire_secp256k1_ecdsa_signature */
void towire_secp256k1_ecdsa_signature(u8 **pptr UNNEEDED,
			      const secp256k1_ecdsa_signature *signature UNNEEDED)
{ fprintf(stderr, "towire_secp256k1_ecdsa_signature called!\n"); abort(); }
/* Generated stub for towire_sha256 */
void towire_sha256(u8 **pptr UNNEEDED, const struct sha256 *sha256 UNNEEDED)
{ fprintf(stderr, "towire_sha256 called!\n"); abort(); }
/* Generated stub for towire_u32 */
void towire_u32(u8 **pptr UNNEEDED, u32 v UNNEEDED)
{ fprintf(stderr, "towire_u32 called!\n"); abort(); }
/* Generated stub for towire_u64 */
void towire_u64(u8 **pptr UNNEEDED, u64 v UNNEEDED)
{ fprintf(stderr, "towire_u64 called!\n"); abort(); }
/* Generated stub for towire_u8 */
void towire_u8(u8 **pptr UNNEEDED, u8 v UNNEEDED)
{ fprintf(stderr, "towire_u8 called!\n"); abort(); }
/* Generated stub for towire_u8_array */
void towire_u8_array(u8 **pptr UNNEEDED, const u8 *arr UNNEEDED, size_t num UNNEEDED)
{ fprintf(stderr, "towire_u8_array called!\n"); abort(); }
/* AUTOGENERATED MOCKS END */

int main(int argc, char *argv[])
{
	common_setup(argv[0]);

	assert(version_to_number("v22.11") == 22*YEAR_VAL + 11*MONTH_VAL + 1);

	assert(version_to_number("v22.11rc1") == 22*YEAR_VAL + 11*MONTH_VAL + 1);

	assert(version_to_number("v22.11rc1-1-g123456") == 22*YEAR_VAL + 11*MONTH_VAL + 1);

	/* We insert a 0 so far, but let's check both! */
	assert(version_to_number("v25.1") == 25*YEAR_VAL + 1*MONTH_VAL + 1);
	assert(version_to_number("v25.02") == 25*YEAR_VAL + 2*MONTH_VAL + 1);
	assert(version_to_number("v25.12") == 25*YEAR_VAL + 12*MONTH_VAL + 1);

	assert(version_to_number("v25.12.9") == 25*YEAR_VAL + 12*MONTH_VAL + 9 + 1);

	/* Malformed */
	assert(version_to_number("v25.12.") == 0);
	assert(version_to_number("v25.12.10") == 0);
	assert(version_to_number("v25.0") == 0);
	assert(version_to_number("v25.") == 0);
	assert(version_to_number("v25..") == 0);
	assert(version_to_number("v25.13") == 0);
	assert(version_to_number("v100.12") == 0);
	assert(version_to_number("v25.") == 0);
	assert(version_to_number("v25") == 0);
	assert(version_to_number("v") == 0);
	assert(version_to_number("") == 0);
	assert(version_to_number("25.12") == 0);

	test_next_version = "v23.08";
	/* Deprecated in future */
	assert(deprecation("v24.08", NULL) == DEPRECATED_SOON);
	assert(deprecation("v23.09", NULL) == DEPRECATED_SOON);
	/* Just deprecated for 6 months */
	assert(deprecation("v23.08", NULL) == DEPRECATED);
	assert(deprecation("v23.07", NULL) == DEPRECATED);
	assert(deprecation("v23.06", NULL) == DEPRECATED);
	assert(deprecation("v23.05", NULL) == DEPRECATED);
	assert(deprecation("v23.04", NULL) == DEPRECATED);
	assert(deprecation("v23.03", NULL) == DEPRECATED);
	/* At 6 months, it complains */
	assert(deprecation("v23.02", NULL) == DEPRECATED_COMPLAIN);
	/* After that, you need to switch it on */
	assert(deprecation("v23.01", NULL) == DEPRECATED_BEG);
	assert(deprecation("v22.12", NULL) == DEPRECATED_BEG);
	assert(deprecation("v22.11", NULL) == DEPRECATED_BEG);
	assert(deprecation("v22.01", NULL) == DEPRECATED_BEG);

	/* Non-default end works */
	assert(deprecation("v23.09", "v23.10") == DEPRECATED_SOON);
	assert(deprecation("v23.08", "v23.09") == DEPRECATED);
	assert(deprecation("v23.07", "v23.08") == DEPRECATED_COMPLAIN);
	assert(deprecation("v23.06", "v23.07") == DEPRECATED_BEG);

	common_shutdown();
}
