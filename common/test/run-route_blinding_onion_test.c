#include "config.h"
#include "../../wire/fromwire.c"
#include "../../wire/tlvstream.c"
#include "../../wire/towire.c"
#include "../amount.c"
#include "../bigsize.c"
#include "../blindedpath.c"
#include "../blindedpay.c"
#include "../blinding.c"
#include "../features.c"
#include "../hmac.c"
#include "../json_parse.c"
#include "../json_parse_simple.c"
#include "../onion_encode.c"
#include "../sphinx.c"
#include "../type_to_string.c"
#if EXPERIMENTAL_FEATURES
  #include "../../wire/onion_exp_wiregen.c"
#else
  #include "../../wire/onion_wiregen.c"
#endif
#include <ccan/tal/grab_file/grab_file.h>
#include <ccan/tal/path/path.h>
#include <common/bolt12.h>
#include <common/channel_id.h>
#include <common/json_parse.h>
#include <common/json_stream.h>
#include <common/setup.h>
#include <common/wireaddr.h>
#include <stdio.h>

/* AUTOGENERATED MOCKS START */
/* Generated stub for mvt_tag_str */
const char *mvt_tag_str(enum mvt_tag tag UNNEEDED)
{ fprintf(stderr, "mvt_tag_str called!\n"); abort(); }
/* Generated stub for new_onionreply */
struct onionreply *new_onionreply(const tal_t *ctx UNNEEDED, const u8 *contents TAKES UNNEEDED)
{ fprintf(stderr, "new_onionreply called!\n"); abort(); }
/* Generated stub for node_id_from_hexstr */
bool node_id_from_hexstr(const char *str UNNEEDED, size_t slen UNNEEDED, struct node_id *id UNNEEDED)
{ fprintf(stderr, "node_id_from_hexstr called!\n"); abort(); }
/* Generated stub for pubkey_from_node_id */
bool pubkey_from_node_id(struct pubkey *key UNNEEDED, const struct node_id *id UNNEEDED)
{ fprintf(stderr, "pubkey_from_node_id called!\n"); abort(); }
/* AUTOGENERATED MOCKS END */

static bool json_to_tok(const char *buffer, const jsmntok_t *tok,
			const jsmntok_t **tokp)
{
	*tokp = tok;
	return true;
}

int main(int argc, char *argv[])
{
	char *json;
	size_t i;
	jsmn_parser parser;
	jsmntok_t toks[5000];
	const jsmntok_t *t, *hops_tok;
	struct blinded_path *bpath;
	struct pubkey *ids;
	u8 **onionhops, *associated_data, *onion, *expected_onion;
	struct short_channel_id initscid;
	struct sphinx_path *sp;
	struct secret session_key, *path_secrets;

	common_setup(argv[0]);

	if (argv[1])
		json = grab_file(tmpctx, argv[1]);
	else {
		char *dir = getenv("BOLTDIR");
		json = grab_file(tmpctx,
				 path_join(tmpctx,
					   dir ? dir : "../bolts",
					   "bolt04/onion-route-blinding-test.json"));
		if (!json) {
			printf("test file not found, skipping\n");
			goto out;
		}
	}

	jsmn_init(&parser);
	if (jsmn_parse(&parser, json, strlen(json), toks, ARRAY_SIZE(toks)) < 0)
		abort();

	bpath = tal(tmpctx, struct blinded_path);

	assert(json_scan(tmpctx, json, toks, "{generate:{session_key:%,associated_data:%,blinded_route:{introduction_node_id:%,blinding:%,hops:%}}}",
			 JSON_SCAN(json_to_secret, &session_key),
			 JSON_SCAN_TAL(tmpctx, json_tok_bin_from_hex, &associated_data),
			 JSON_SCAN(json_to_pubkey, &bpath->first_node_id),
			 JSON_SCAN(json_to_pubkey, &bpath->blinding),
			 JSON_SCAN(json_to_tok, &hops_tok)) == NULL);

	bpath->path = tal_arr(bpath, struct onionmsg_hop *, hops_tok->size);
	json_for_each_arr(i, t, hops_tok) {
		bpath->path[i] = tal(bpath->path, struct onionmsg_hop);
		assert(json_scan(tmpctx, json, t, "{blinded_node_id:%,encrypted_data:%}",
				 JSON_SCAN(json_to_pubkey,
					   &bpath->path[i]->blinded_node_id),
				 JSON_SCAN_TAL(bpath->path[i],
					       json_tok_bin_from_hex,
					       &bpath->path[i]->encrypted_recipient_data)) == NULL);
	}

	/* FIXME: These amounts / scid should be in test vectors! */
	onionhops = blinded_onion_hops(tmpctx, AMOUNT_MSAT(200), 700, bpath);
	assert(mk_short_channel_id(&initscid, 0, 0, 10));

	/* Prepend Alice: poor thing doesn't speak blinding! */
	tal_resize(&onionhops, tal_count(onionhops) + 1);
	memmove(onionhops + 1, onionhops,
		(tal_count(onionhops) - 1) * sizeof(*onionhops));
	onionhops[0] = onion_nonfinal_hop(onionhops, &initscid,
					  AMOUNT_MSAT(500), 1000);

	assert(json_scan(tmpctx, json, toks, "{generate:{full_route:{hops:%}}}",
			 JSON_SCAN(json_to_tok, &hops_tok)) == NULL);

	ids = tal_arr(tmpctx, struct pubkey, hops_tok->size);
	json_for_each_arr(i, t, hops_tok) {
		u8 *payload;
		assert(json_scan(tmpctx, json, t, "{payload:%,pubkey:%}",
				 JSON_SCAN_TAL(tmpctx,
					       json_tok_bin_from_hex,
					       &payload),
				 JSON_SCAN(json_to_pubkey, &ids[i])) == NULL);
		assert(memeq(payload, tal_bytelen(payload),
			     onionhops[i], tal_bytelen(onionhops[i])));
	}

	/* Now, create onion! */
	sp = sphinx_path_new_with_key(tmpctx, associated_data, &session_key);
	for (i = 0; i < tal_count(ids); i++)
		sphinx_add_hop(sp, &ids[i], onionhops[i]);

	onion = serialize_onionpacket(tmpctx,
				      create_onionpacket(tmpctx, sp, ROUTING_INFO_SIZE,
							 &path_secrets));
	assert(json_scan(tmpctx, json, toks, "{generate:{onion:%}}",
			 JSON_SCAN_TAL(tmpctx,
				       json_tok_bin_from_hex,
				       &expected_onion)) == NULL);
	assert(memeq(expected_onion, tal_bytelen(expected_onion),
		     onion, tal_bytelen(onion)));

	/* FIXME: unwrap and test! */

out:
	common_shutdown();
}
