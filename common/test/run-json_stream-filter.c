#include "config.h"
#include "../json_filter.c"
#include "../json_stream.c"
#include <assert.h>
#include <ccan/tal/str/str.h>
#include <common/channel_type.h>
#include <common/setup.h>
#include <inttypes.h>
#include <stdio.h>

/* AUTOGENERATED MOCKS START */
/* Generated stub for amount_asset_is_main */
bool amount_asset_is_main(struct amount_asset *asset UNNEEDED)
{ fprintf(stderr, "amount_asset_is_main called!\n"); abort(); }
/* Generated stub for amount_asset_to_sat */
struct amount_sat amount_asset_to_sat(struct amount_asset *asset UNNEEDED)
{ fprintf(stderr, "amount_asset_to_sat called!\n"); abort(); }
/* Generated stub for amount_feerate */
 bool amount_feerate(u32 *feerate UNNEEDED, struct amount_sat fee UNNEEDED, size_t weight UNNEEDED)
{ fprintf(stderr, "amount_feerate called!\n"); abort(); }
/* Generated stub for amount_msat */
struct amount_msat amount_msat(u64 millisatoshis UNNEEDED)
{ fprintf(stderr, "amount_msat called!\n"); abort(); }
/* Generated stub for amount_sat */
struct amount_sat amount_sat(u64 satoshis UNNEEDED)
{ fprintf(stderr, "amount_sat called!\n"); abort(); }
/* Generated stub for amount_sat_add */
 bool amount_sat_add(struct amount_sat *val UNNEEDED,
				       struct amount_sat a UNNEEDED,
				       struct amount_sat b UNNEEDED)
{ fprintf(stderr, "amount_sat_add called!\n"); abort(); }
/* Generated stub for amount_sat_eq */
bool amount_sat_eq(struct amount_sat a UNNEEDED, struct amount_sat b UNNEEDED)
{ fprintf(stderr, "amount_sat_eq called!\n"); abort(); }
/* Generated stub for amount_sat_greater_eq */
bool amount_sat_greater_eq(struct amount_sat a UNNEEDED, struct amount_sat b UNNEEDED)
{ fprintf(stderr, "amount_sat_greater_eq called!\n"); abort(); }
/* Generated stub for amount_sat_sub */
 bool amount_sat_sub(struct amount_sat *val UNNEEDED,
				       struct amount_sat a UNNEEDED,
				       struct amount_sat b UNNEEDED)
{ fprintf(stderr, "amount_sat_sub called!\n"); abort(); }
/* Generated stub for amount_sat_to_asset */
struct amount_asset amount_sat_to_asset(struct amount_sat *sat UNNEEDED, const u8 *asset UNNEEDED)
{ fprintf(stderr, "amount_sat_to_asset called!\n"); abort(); }
/* Generated stub for amount_sat_to_msat */
 bool amount_sat_to_msat(struct amount_msat *msat UNNEEDED,
					   struct amount_sat sat UNNEEDED)
{ fprintf(stderr, "amount_sat_to_msat called!\n"); abort(); }
/* Generated stub for amount_tx_fee */
struct amount_sat amount_tx_fee(u32 fee_per_kw UNNEEDED, size_t weight UNNEEDED)
{ fprintf(stderr, "amount_tx_fee called!\n"); abort(); }
/* Generated stub for command_fail */
struct command_result *command_fail(struct command *cmd UNNEEDED, enum jsonrpc_errcode code UNNEEDED,
				    const char *fmt UNNEEDED, ...)

{ fprintf(stderr, "command_fail called!\n"); abort(); }
/* Generated stub for command_filter_ptr */
struct json_filter **command_filter_ptr(struct command *cmd UNNEEDED)
{ fprintf(stderr, "command_filter_ptr called!\n"); abort(); }
/* Generated stub for fmt_amount_sat */
char *fmt_amount_sat(const tal_t *ctx UNNEEDED, struct amount_sat sat UNNEEDED)
{ fprintf(stderr, "fmt_amount_sat called!\n"); abort(); }
/* Generated stub for fmt_wireaddr_without_port */
char *fmt_wireaddr_without_port(const tal_t *ctx UNNEEDED, const struct wireaddr *a UNNEEDED)
{ fprintf(stderr, "fmt_wireaddr_without_port called!\n"); abort(); }
/* Generated stub for fromwire */
const u8 *fromwire(const u8 **cursor UNNEEDED, size_t *max UNNEEDED, void *copy UNNEEDED, size_t n UNNEEDED)
{ fprintf(stderr, "fromwire called!\n"); abort(); }
/* Generated stub for fromwire_bool */
bool fromwire_bool(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_bool called!\n"); abort(); }
/* Generated stub for fromwire_fail */
void *fromwire_fail(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_fail called!\n"); abort(); }
/* Generated stub for fromwire_secp256k1_ecdsa_signature */
void fromwire_secp256k1_ecdsa_signature(const u8 **cursor UNNEEDED, size_t *max UNNEEDED,
					secp256k1_ecdsa_signature *signature UNNEEDED)
{ fprintf(stderr, "fromwire_secp256k1_ecdsa_signature called!\n"); abort(); }
/* Generated stub for fromwire_sha256 */
void fromwire_sha256(const u8 **cursor UNNEEDED, size_t *max UNNEEDED, struct sha256 *sha256 UNNEEDED)
{ fprintf(stderr, "fromwire_sha256 called!\n"); abort(); }
/* Generated stub for fromwire_tal_arrn */
u8 *fromwire_tal_arrn(const tal_t *ctx UNNEEDED,
		       const u8 **cursor UNNEEDED, size_t *max UNNEEDED, size_t num UNNEEDED)
{ fprintf(stderr, "fromwire_tal_arrn called!\n"); abort(); }
/* Generated stub for fromwire_u32 */
u32 fromwire_u32(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_u32 called!\n"); abort(); }
/* Generated stub for fromwire_u64 */
u64 fromwire_u64(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_u64 called!\n"); abort(); }
/* Generated stub for fromwire_u8 */
u8 fromwire_u8(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_u8 called!\n"); abort(); }
/* Generated stub for fromwire_u8_array */
void fromwire_u8_array(const u8 **cursor UNNEEDED, size_t *max UNNEEDED, u8 *arr UNNEEDED, size_t num UNNEEDED)
{ fprintf(stderr, "fromwire_u8_array called!\n"); abort(); }
/* Generated stub for json_next */
const jsmntok_t *json_next(const jsmntok_t *tok UNNEEDED)
{ fprintf(stderr, "json_next called!\n"); abort(); }
/* Generated stub for json_to_bool */
bool json_to_bool(const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED, bool *b UNNEEDED)
{ fprintf(stderr, "json_to_bool called!\n"); abort(); }
/* Generated stub for json_tok_full */
const char *json_tok_full(const char *buffer UNNEEDED, const jsmntok_t *t UNNEEDED)
{ fprintf(stderr, "json_tok_full called!\n"); abort(); }
/* Generated stub for json_tok_full_len */
int json_tok_full_len(const jsmntok_t *t UNNEEDED)
{ fprintf(stderr, "json_tok_full_len called!\n"); abort(); }
/* Generated stub for towire */
void towire(u8 **pptr UNNEEDED, const void *data UNNEEDED, size_t len UNNEEDED)
{ fprintf(stderr, "towire called!\n"); abort(); }
/* Generated stub for towire_bool */
void towire_bool(u8 **pptr UNNEEDED, bool v UNNEEDED)
{ fprintf(stderr, "towire_bool called!\n"); abort(); }
/* Generated stub for towire_secp256k1_ecdsa_signature */
void towire_secp256k1_ecdsa_signature(u8 **pptr UNNEEDED,
			      const secp256k1_ecdsa_signature *signature UNNEEDED)
{ fprintf(stderr, "towire_secp256k1_ecdsa_signature called!\n"); abort(); }
/* Generated stub for towire_sha256 */
void towire_sha256(u8 **pptr UNNEEDED, const struct sha256 *sha256 UNNEEDED)
{ fprintf(stderr, "towire_sha256 called!\n"); abort(); }
/* Generated stub for towire_u32 */
void towire_u32(u8 **pptr UNNEEDED, u32 v UNNEEDED)
{ fprintf(stderr, "towire_u32 called!\n"); abort(); }
/* Generated stub for towire_u64 */
void towire_u64(u8 **pptr UNNEEDED, u64 v UNNEEDED)
{ fprintf(stderr, "towire_u64 called!\n"); abort(); }
/* Generated stub for towire_u8 */
void towire_u8(u8 **pptr UNNEEDED, u8 v UNNEEDED)
{ fprintf(stderr, "towire_u8 called!\n"); abort(); }
/* Generated stub for towire_u8_array */
void towire_u8_array(u8 **pptr UNNEEDED, const u8 *arr UNNEEDED, size_t num UNNEEDED)
{ fprintf(stderr, "towire_u8_array called!\n"); abort(); }
/* AUTOGENERATED MOCKS END */

int main(int argc, char *argv[])
{
	struct json_stream *js;
	struct json_filter *filter, *subf;
	const char *str;
	size_t len;

	common_setup(argv[0]);

	/* First with an empty filter. */
	js = new_json_stream(tmpctx, NULL, NULL);
	filter = json_filter_new(js);
	/* Filters assume we start inside an object! */
	json_object_start(js, NULL);
	json_stream_attach_filter(js, filter);

	json_object_start(js, "result");
	json_object_start(js, "message");
	json_add_string(js, "string", "string");
	json_object_end(js);
	json_object_end(js);

	str = json_out_contents(js->jout, &len);
	assert(strncmp(str, "{\"result\":{\"message\":{\"string\":\"string\"}}", len) == 0);

	/* Now try a result filter. */
	js = new_json_stream(tmpctx, NULL, NULL);
	filter = json_filter_new(js);
	json_filter_subobj(filter, "result", strlen("result"));
	json_object_start(js, NULL);
	json_stream_attach_filter(js, filter);

	json_object_start(js, "result");
	json_object_start(js, "message");
	json_add_string(js, "string", "string");
	json_object_end(js);
	json_object_end(js);

	str = json_out_contents(js->jout, &len);
	assert(strncmp(str, "{\"result\":{\"message\":{\"string\":\"string\"}}", len) == 0);

	/* Now try a result->message->string filter. */
	js = new_json_stream(tmpctx, NULL, NULL);
	filter = json_filter_new(js);
	subf = json_filter_subobj(filter, "result", strlen("result"));
	subf = json_filter_subobj(subf, "message", strlen("message"));
	json_filter_subobj(subf, "string", strlen("string"));
	json_object_start(js, NULL);
	json_stream_attach_filter(js, filter);

	json_object_start(js, "result");
	json_object_start(js, "message");
	json_add_string(js, "string", "string");
	json_object_end(js);
	json_object_end(js);

	str = json_out_contents(js->jout, &len);
	assert(strncmp(str, "{\"result\":{\"message\":{\"string\":\"string\"}}", len) == 0);

	/* Now a sub-filter which doesn't match */
	js = new_json_stream(tmpctx, NULL, NULL);
	filter = json_filter_new(js);
	subf = json_filter_subobj(filter, "result", strlen("result"));
	subf = json_filter_subobj(subf, "message", strlen("message"));
	json_filter_subobj(subf, "dne", strlen("dne"));
	json_object_start(js, NULL);
	json_stream_attach_filter(js, filter);

	json_object_start(js, "result");
	json_object_start(js, "message");
	json_add_string(js, "string", "string");
	json_object_end(js);
	json_object_end(js);

	str = json_out_contents(js->jout, &len);
	assert(strncmp(str, "{\"result\":{\"message\":{}}", len) == 0);

	/* Multple, one of three matchs */
	js = new_json_stream(tmpctx, NULL, NULL);
	filter = json_filter_new(js);
	subf = json_filter_subobj(filter, "result", strlen("result"));
	subf = json_filter_subobj(subf, "message", strlen("message"));
	json_filter_subobj(subf, "f1", strlen("f1"));
	json_filter_subobj(subf, "f3", strlen("f3"));
	json_object_start(js, NULL);
	json_stream_attach_filter(js, filter);

	json_object_start(js, "result");
	json_object_start(js, "message");
	json_add_string(js, "f1", "f1string");
	json_object_start(js, "f2");
	json_add_string(js, "f2sub", "f2string");
	json_object_end(js);
	json_add_string(js, "f3", "f3string");
	json_object_end(js);
	json_object_end(js);

	str = json_out_contents(js->jout, &len);
	assert(strncmp(str, "{\"result\":{\"message\":{\"f1\":\"f1string\",\"f3\":\"f3string\"}}", len) == 0);

	/* Now inside arrays! */
	js = new_json_stream(tmpctx, NULL, NULL);
	filter = json_filter_new(js);
	subf = json_filter_subobj(filter, "result", strlen("result"));
	subf = json_filter_subobj(subf, "messages", strlen("messages"));
	subf = json_filter_subarr(subf);
	json_filter_subobj(subf, "string", strlen("string"));
	json_object_start(js, NULL);
	json_stream_attach_filter(js, filter);

	json_object_start(js, "result");
	json_array_start(js, "messages");
	json_object_start(js, NULL);
	json_add_string(js, "string", "string1");
	json_object_end(js);
	json_object_start(js, NULL);
	json_add_string(js, "string", "string2");
	json_object_end(js);
	json_array_end(js);
	json_object_end(js);

	str = json_out_contents(js->jout, &len);
	assert(strncmp(str, "{\"result\":{\"messages\":[{\"string\":\"string1\"},{\"string\":\"string2\"}]}",
		       len) == 0);

	/* Now filter out arrays. */
	js = new_json_stream(tmpctx, NULL, NULL);
	filter = json_filter_new(js);
	json_filter_subobj(filter, "result", strlen("result"));
	json_object_start(js, NULL);
	json_stream_attach_filter(js, filter);

	json_add_string(js, "result", "resultstr");
	json_add_string(js, "ignored", "ignoredstr");
	json_array_start(js, "fallbacks");
	json_object_start(js, NULL);
	json_add_string(js, "type", "P2PKH");
	json_object_end(js);
	json_array_end(js);

	str = json_out_contents(js->jout, &len);
	assert(strncmp(str, "{\"result\":\"resultstr\"", len) == 0);
	common_shutdown();
}
