#include "config.h"
#include <bitcoin/chainparams.h>
#include <common/amount.h>
#include <common/randbytes.h>
#include <common/setup.h>
#include <stdio.h>

int simple_get_ln_port(const struct chainparams *params);

#define chainparams_get_ln_port simple_get_ln_port

#include "../wireaddr.c"

#define DEFAULT_PORT simple_get_ln_port(NULL)

int simple_get_ln_port(const struct chainparams *params UNNEEDED)
{
	return 9735;
}

/* AUTOGENERATED MOCKS START */
/* Generated stub for amount_asset_is_main */
bool amount_asset_is_main(struct amount_asset *asset UNNEEDED)
{ fprintf(stderr, "amount_asset_is_main called!\n"); abort(); }
/* Generated stub for amount_asset_to_sat */
struct amount_sat amount_asset_to_sat(struct amount_asset *asset UNNEEDED)
{ fprintf(stderr, "amount_asset_to_sat called!\n"); abort(); }
/* Generated stub for amount_feerate */
 bool amount_feerate(u32 *feerate UNNEEDED, struct amount_sat fee UNNEEDED, size_t weight UNNEEDED)
{ fprintf(stderr, "amount_feerate called!\n"); abort(); }
/* Generated stub for amount_sat */
struct amount_sat amount_sat(u64 satoshis UNNEEDED)
{ fprintf(stderr, "amount_sat called!\n"); abort(); }
/* Generated stub for amount_sat_add */
 bool amount_sat_add(struct amount_sat *val UNNEEDED,
				       struct amount_sat a UNNEEDED,
				       struct amount_sat b UNNEEDED)
{ fprintf(stderr, "amount_sat_add called!\n"); abort(); }
/* Generated stub for amount_sat_eq */
bool amount_sat_eq(struct amount_sat a UNNEEDED, struct amount_sat b UNNEEDED)
{ fprintf(stderr, "amount_sat_eq called!\n"); abort(); }
/* Generated stub for amount_sat_greater_eq */
bool amount_sat_greater_eq(struct amount_sat a UNNEEDED, struct amount_sat b UNNEEDED)
{ fprintf(stderr, "amount_sat_greater_eq called!\n"); abort(); }
/* Generated stub for amount_sat_sub */
 bool amount_sat_sub(struct amount_sat *val UNNEEDED,
				       struct amount_sat a UNNEEDED,
				       struct amount_sat b UNNEEDED)
{ fprintf(stderr, "amount_sat_sub called!\n"); abort(); }
/* Generated stub for amount_sat_to_asset */
struct amount_asset amount_sat_to_asset(struct amount_sat *sat UNNEEDED, const u8 *asset UNNEEDED)
{ fprintf(stderr, "amount_sat_to_asset called!\n"); abort(); }
/* Generated stub for amount_tx_fee */
struct amount_sat amount_tx_fee(u32 fee_per_kw UNNEEDED, size_t weight UNNEEDED)
{ fprintf(stderr, "amount_tx_fee called!\n"); abort(); }
/* Generated stub for b32_decode */
u8 *b32_decode(const tal_t *ctx UNNEEDED, const char *str UNNEEDED, size_t len UNNEEDED)
{ fprintf(stderr, "b32_decode called!\n"); abort(); }
/* Generated stub for b32_encode */
char *b32_encode(const tal_t *ctx UNNEEDED, const void *data UNNEEDED, size_t len UNNEEDED)
{ fprintf(stderr, "b32_encode called!\n"); abort(); }
/* AUTOGENERATED MOCKS END */

int main(int argc, char *argv[])
{
	struct wireaddr_internal addr, *expect = tal(NULL, struct wireaddr_internal);

	common_setup(argv[0]);
	/* Simple IPv4 address. */
	assert(parse_wireaddr_internal(tmpctx, "127.0.0.1", DEFAULT_PORT, false, &addr) == NULL);
	expect->itype = ADDR_INTERNAL_WIREADDR;
	expect->u.wireaddr.is_websocket = false;
	assert(parse_wireaddr(tmpctx, "127.0.0.1:9735", 0, NULL, &expect->u.wireaddr.wireaddr) == NULL);
	assert(wireaddr_internal_eq(&addr, expect));

	/* IPv4 address with port. */
	assert(parse_wireaddr_internal(tmpctx, "127.0.0.1:1", DEFAULT_PORT, false, &addr) == NULL);
	expect->itype = ADDR_INTERNAL_WIREADDR;
	expect->u.wireaddr.is_websocket = false;
	assert(parse_wireaddr(tmpctx, "127.0.0.1:1", 0, NULL, &expect->u.wireaddr.wireaddr) == NULL);
	assert(wireaddr_internal_eq(&addr, expect));

	/* Simple IPv6 address. */
	assert(parse_wireaddr_internal(tmpctx, "::1", DEFAULT_PORT, false, &addr) == NULL);
	expect->itype = ADDR_INTERNAL_WIREADDR;
	expect->u.wireaddr.is_websocket = false;
	assert(parse_wireaddr(tmpctx, "::1", DEFAULT_PORT, NULL, &expect->u.wireaddr.wireaddr) == NULL);
	assert(wireaddr_internal_eq(&addr, expect));

	/* IPv6 address with port. */
	assert(parse_wireaddr_internal(tmpctx, "[::1]:1", DEFAULT_PORT, false, &addr) == NULL);
	expect->itype = ADDR_INTERNAL_WIREADDR;
	expect->u.wireaddr.is_websocket = false;
	assert(parse_wireaddr(tmpctx, "::1", 1, NULL, &expect->u.wireaddr.wireaddr) == NULL);
	assert(wireaddr_internal_eq(&addr, expect));

	/* autotor address */
	assert(parse_wireaddr_internal(tmpctx, "autotor:127.0.0.1", DEFAULT_PORT, false, &addr) == NULL);
	expect->itype = ADDR_INTERNAL_AUTOTOR;
	expect->u.torservice.port = DEFAULT_PORT;
	assert(parse_wireaddr(tmpctx, "127.0.0.1", 9051, NULL, &expect->u.torservice.address) == NULL);
	assert(wireaddr_internal_eq(&addr, expect));

	/* autotor address with port */
	assert(parse_wireaddr_internal(tmpctx, "autotor:127.0.0.1:9055", DEFAULT_PORT, false, &addr) == NULL);
	expect->itype = ADDR_INTERNAL_AUTOTOR;
	expect->u.torservice.port = DEFAULT_PORT;
	assert(parse_wireaddr(tmpctx, "127.0.0.1", 9055, NULL, &expect->u.torservice.address) == NULL);
	assert(wireaddr_internal_eq(&addr, expect));

	/* autotor address with torport */
	assert(parse_wireaddr_internal(tmpctx, "autotor:127.0.0.1/torport=9055", DEFAULT_PORT, false, &addr) == NULL);
	expect->itype = ADDR_INTERNAL_AUTOTOR;
	expect->u.torservice.port = 9055;
	assert(parse_wireaddr(tmpctx, "127.0.0.1", 9051, NULL, &expect->u.torservice.address) == NULL);
	assert(wireaddr_internal_eq(&addr, expect));

	/* autotor address with port and torport */
	assert(parse_wireaddr_internal(tmpctx, "autotor:127.0.0.1:9055/torport=10055", DEFAULT_PORT, false, &addr) == NULL);
	expect->itype = ADDR_INTERNAL_AUTOTOR;
	expect->u.torservice.port = 10055;
	assert(parse_wireaddr(tmpctx, "127.0.0.1", 9055, NULL, &expect->u.torservice.address) == NULL);
	assert(wireaddr_internal_eq(&addr, expect));

	/* statictor address */
	assert(parse_wireaddr_internal(tmpctx, "statictor:127.0.0.1", DEFAULT_PORT, false, &addr) == NULL);
	expect->itype = ADDR_INTERNAL_STATICTOR;
	expect->u.torservice.port = DEFAULT_PORT;
	memset(expect->u.torservice.blob, 0, sizeof(expect->u.torservice.blob));
	strcpy((char *)expect->u.torservice.blob, STATIC_TOR_MAGIC_STRING);
	assert(parse_wireaddr(tmpctx, "127.0.0.1", 9051, NULL, &expect->u.torservice.address) == NULL);
	assert(wireaddr_internal_eq(&addr, expect));

	/* statictor address with port */
	assert(parse_wireaddr_internal(tmpctx, "statictor:127.0.0.1:9055", DEFAULT_PORT, false, &addr) == NULL);
	expect->itype = ADDR_INTERNAL_STATICTOR;
	expect->u.torservice.port = DEFAULT_PORT;
	assert(parse_wireaddr(tmpctx, "127.0.0.1", 9055, NULL, &expect->u.torservice.address) == NULL);
	assert(wireaddr_internal_eq(&addr, expect));

	/* statictor address with torport */
	assert(parse_wireaddr_internal(tmpctx, "statictor:127.0.0.1/torport=9055", DEFAULT_PORT, false, &addr) == NULL);
	expect->itype = ADDR_INTERNAL_STATICTOR;
	expect->u.torservice.port = 9055;
	assert(parse_wireaddr(tmpctx, "127.0.0.1", 9051, NULL, &expect->u.torservice.address) == NULL);
	assert(wireaddr_internal_eq(&addr, expect));

	/* statictor address with port and torport */
	assert(parse_wireaddr_internal(tmpctx, "statictor:127.0.0.1:9055/torport=10055", DEFAULT_PORT, false, &addr) == NULL);
	expect->itype = ADDR_INTERNAL_STATICTOR;
	expect->u.torservice.port = 10055;
	assert(parse_wireaddr(tmpctx, "127.0.0.1", 9055, NULL, &expect->u.torservice.address) == NULL);
	assert(wireaddr_internal_eq(&addr, expect));

	/* statictor address with port and torport and torblob */
	assert(parse_wireaddr_internal(tmpctx, "statictor:127.0.0.1:9055/torport=10055/torblob=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx", DEFAULT_PORT, false, &addr) == NULL);
	expect->itype = ADDR_INTERNAL_STATICTOR;
	expect->u.torservice.port = 10055;
	/* This is actually nul terminated */
	memset(expect->u.torservice.blob, 'x', sizeof(expect->u.torservice.blob)-1);
	assert(parse_wireaddr(tmpctx, "127.0.0.1", 9055, NULL, &expect->u.torservice.address) == NULL);
	assert(wireaddr_internal_eq(&addr, expect));

	/* local socket path */
	assert(parse_wireaddr_internal(tmpctx, "/tmp/foo.sock", DEFAULT_PORT, false, &addr) == NULL);
	expect->itype = ADDR_INTERNAL_SOCKNAME;
	strcpy(expect->u.sockname, "/tmp/foo.sock");
	assert(wireaddr_internal_eq(&addr, expect));

	/* Websocket (only for IP addresses) */
	assert(parse_wireaddr_internal(tmpctx, "ws:/tmp/foo.sock", DEFAULT_PORT, false, &addr) != NULL);

	assert(parse_wireaddr_internal(tmpctx, "ws:127.0.0.1", DEFAULT_PORT, false, &addr) == NULL);
	expect->itype = ADDR_INTERNAL_WIREADDR;
	expect->u.wireaddr.is_websocket = true;
 	assert(parse_wireaddr(tmpctx, "127.0.0.1:9735", 0, NULL, &expect->u.wireaddr.wireaddr) == NULL);
	assert(wireaddr_internal_eq(&addr, expect));

	/* Websocket: IPv4 address with port. */
	assert(parse_wireaddr_internal(tmpctx, "ws:127.0.0.1:1", DEFAULT_PORT, false, &addr) == NULL);
	expect->itype = ADDR_INTERNAL_WIREADDR;
	expect->u.wireaddr.is_websocket = true;
 	assert(parse_wireaddr(tmpctx, "127.0.0.1:1", 0, NULL, &expect->u.wireaddr.wireaddr) == NULL);
	assert(wireaddr_internal_eq(&addr, expect));

	/* Websocket: Simple IPv6 address. */
	assert(parse_wireaddr_internal(tmpctx, "ws:::1", DEFAULT_PORT, false, &addr) == NULL);
	expect->itype = ADDR_INTERNAL_WIREADDR;
	expect->u.wireaddr.is_websocket = true;
	assert(parse_wireaddr(tmpctx, "::1", DEFAULT_PORT, NULL, &expect->u.wireaddr.wireaddr) == NULL);
	assert(wireaddr_internal_eq(&addr, expect));

	/* Websocket: IPv6 address with port. */
	assert(parse_wireaddr_internal(tmpctx, "ws:[::1]:1", DEFAULT_PORT, false, &addr) == NULL);
	expect->itype = ADDR_INTERNAL_WIREADDR;
	expect->u.wireaddr.is_websocket = true;
	assert(parse_wireaddr(tmpctx, "::1", 1, NULL, &expect->u.wireaddr.wireaddr) == NULL);
	assert(wireaddr_internal_eq(&addr, expect));

	/* Websocket: IPv4 & v6 address. */
	assert(parse_wireaddr_internal(tmpctx, "ws:", DEFAULT_PORT, false, &addr) == NULL);
	expect->itype = ADDR_INTERNAL_ALLPROTO;
	expect->u.allproto.is_websocket = true;
	expect->u.allproto.port = DEFAULT_PORT;
	assert(wireaddr_internal_eq(&addr, expect));

	/* Websocket: IPv4 & v6 address with port */
	assert(parse_wireaddr_internal(tmpctx, "ws::1", DEFAULT_PORT, false, &addr) == NULL);
	expect->itype = ADDR_INTERNAL_ALLPROTO;
	expect->u.allproto.is_websocket = true;
	expect->u.allproto.port = 1;
	assert(wireaddr_internal_eq(&addr, expect));

	/* Unresolved */
	assert(parse_wireaddr_internal(tmpctx, "ozlabs.org", DEFAULT_PORT, false, &addr) == NULL);
	expect->itype = ADDR_INTERNAL_FORPROXY;
	strcpy(expect->u.unresolved.name, "ozlabs.org");
	expect->u.unresolved.port = DEFAULT_PORT;
	assert(wireaddr_internal_eq(&addr, expect));

	/* Unresolved with port */
	assert(parse_wireaddr_internal(tmpctx, "ozlabs.org:1234", DEFAULT_PORT, false, &addr) == NULL);
	expect->itype = ADDR_INTERNAL_FORPROXY;
	strcpy(expect->u.unresolved.name, "ozlabs.org");
	expect->u.unresolved.port = 1234;
	assert(wireaddr_internal_eq(&addr, expect));

	/*
	 * Test for an out-of-bounds bug in fromwire_wireaddr().
	 *
	 * This test reproduces a bug that occurs when decoding a DNS wireaddr
	 * of the maximum possible length (255 bytes). fromwire_wireaddr()
	 * would correctly read the 255 bytes of the address, but then attempt
	 * to write a null terminator at index 255, causing a one-byte
	 * overflow on the 255-byte destination buffer.
	 *
	 * The expected UBSan error is:
	 * common/wireaddr.c:51:3: runtime error: index 255 out of bounds for type 'u8[255]'
	 */

	 const char *dnsaddr =
	/*  63 'a' */  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa."
	/*  63 'b' */  "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb."
	/*  63 'c' */  "ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc."
	/*  63 'd' */  "ddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd";

	struct wireaddr wa = {
		.type = ADDR_TYPE_DNS,
		.addrlen = 255,
		.port = DEFAULT_PORT
	};

	memcpy(wa.addr, dnsaddr, wa.addrlen);

	u8 *encoded_wa = tal_arr(tmpctx, u8, 0);
	towire_wireaddr(&encoded_wa, &wa);
	size_t encoded_wa_len = tal_bytelen(encoded_wa);

	struct wireaddr decoded_wa;
	assert(fromwire_wireaddr((const u8 **) &encoded_wa, &encoded_wa_len, &decoded_wa));
	assert(wireaddr_eq(&wa, &decoded_wa));

	tal_free(expect);
	common_shutdown();
}
