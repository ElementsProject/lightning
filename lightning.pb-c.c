/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: lightning.proto */

/* Do not generate deprecated warnings for self */
#ifndef PROTOBUF_C__NO_DEPRECATED
#define PROTOBUF_C__NO_DEPRECATED
#endif

#include "lightning.pb-c.h"
void   sha256_hash__init
                     (Sha256Hash         *message)
{
  static Sha256Hash init_value = SHA256_HASH__INIT;
  *message = init_value;
}
size_t sha256_hash__get_packed_size
                     (const Sha256Hash *message)
{
  assert(message->base.descriptor == &sha256_hash__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t sha256_hash__pack
                     (const Sha256Hash *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &sha256_hash__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t sha256_hash__pack_to_buffer
                     (const Sha256Hash *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &sha256_hash__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Sha256Hash *
       sha256_hash__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Sha256Hash *)
     protobuf_c_message_unpack (&sha256_hash__descriptor,
                                allocator, len, data);
}
void   sha256_hash__free_unpacked
                     (Sha256Hash *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &sha256_hash__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   preimage__init
                     (Preimage         *message)
{
  static Preimage init_value = PREIMAGE__INIT;
  *message = init_value;
}
size_t preimage__get_packed_size
                     (const Preimage *message)
{
  assert(message->base.descriptor == &preimage__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t preimage__pack
                     (const Preimage *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &preimage__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t preimage__pack_to_buffer
                     (const Preimage *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &preimage__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Preimage *
       preimage__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Preimage *)
     protobuf_c_message_unpack (&preimage__descriptor,
                                allocator, len, data);
}
void   preimage__free_unpacked
                     (Preimage *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &preimage__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   signature__init
                     (Signature         *message)
{
  static Signature init_value = SIGNATURE__INIT;
  *message = init_value;
}
size_t signature__get_packed_size
                     (const Signature *message)
{
  assert(message->base.descriptor == &signature__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t signature__pack
                     (const Signature *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &signature__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t signature__pack_to_buffer
                     (const Signature *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &signature__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Signature *
       signature__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Signature *)
     protobuf_c_message_unpack (&signature__descriptor,
                                allocator, len, data);
}
void   signature__free_unpacked
                     (Signature *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &signature__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   locktime__init
                     (Locktime         *message)
{
  static Locktime init_value = LOCKTIME__INIT;
  *message = init_value;
}
size_t locktime__get_packed_size
                     (const Locktime *message)
{
  assert(message->base.descriptor == &locktime__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t locktime__pack
                     (const Locktime *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &locktime__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t locktime__pack_to_buffer
                     (const Locktime *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &locktime__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Locktime *
       locktime__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Locktime *)
     protobuf_c_message_unpack (&locktime__descriptor,
                                allocator, len, data);
}
void   locktime__free_unpacked
                     (Locktime *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &locktime__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   bitcoin_pubkey__init
                     (BitcoinPubkey         *message)
{
  static BitcoinPubkey init_value = BITCOIN_PUBKEY__INIT;
  *message = init_value;
}
size_t bitcoin_pubkey__get_packed_size
                     (const BitcoinPubkey *message)
{
  assert(message->base.descriptor == &bitcoin_pubkey__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t bitcoin_pubkey__pack
                     (const BitcoinPubkey *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &bitcoin_pubkey__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t bitcoin_pubkey__pack_to_buffer
                     (const BitcoinPubkey *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &bitcoin_pubkey__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
BitcoinPubkey *
       bitcoin_pubkey__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (BitcoinPubkey *)
     protobuf_c_message_unpack (&bitcoin_pubkey__descriptor,
                                allocator, len, data);
}
void   bitcoin_pubkey__free_unpacked
                     (BitcoinPubkey *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &bitcoin_pubkey__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   funding__init
                     (Funding         *message)
{
  static Funding init_value = FUNDING__INIT;
  *message = init_value;
}
size_t funding__get_packed_size
                     (const Funding *message)
{
  assert(message->base.descriptor == &funding__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t funding__pack
                     (const Funding *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &funding__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t funding__pack_to_buffer
                     (const Funding *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &funding__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Funding *
       funding__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Funding *)
     protobuf_c_message_unpack (&funding__descriptor,
                                allocator, len, data);
}
void   funding__free_unpacked
                     (Funding *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &funding__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   authenticate__init
                     (Authenticate         *message)
{
  static Authenticate init_value = AUTHENTICATE__INIT;
  *message = init_value;
}
size_t authenticate__get_packed_size
                     (const Authenticate *message)
{
  assert(message->base.descriptor == &authenticate__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t authenticate__pack
                     (const Authenticate *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &authenticate__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t authenticate__pack_to_buffer
                     (const Authenticate *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &authenticate__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Authenticate *
       authenticate__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Authenticate *)
     protobuf_c_message_unpack (&authenticate__descriptor,
                                allocator, len, data);
}
void   authenticate__free_unpacked
                     (Authenticate *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &authenticate__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   init__init
                     (Init         *message)
{
  static Init init_value = INIT__INIT;
  *message = init_value;
}
size_t init__get_packed_size
                     (const Init *message)
{
  assert(message->base.descriptor == &init__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t init__pack
                     (const Init *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &init__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t init__pack_to_buffer
                     (const Init *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &init__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Init *
       init__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Init *)
     protobuf_c_message_unpack (&init__descriptor,
                                allocator, len, data);
}
void   init__free_unpacked
                     (Init *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &init__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   open_channel__init
                     (OpenChannel         *message)
{
  static OpenChannel init_value = OPEN_CHANNEL__INIT;
  *message = init_value;
}
size_t open_channel__get_packed_size
                     (const OpenChannel *message)
{
  assert(message->base.descriptor == &open_channel__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t open_channel__pack
                     (const OpenChannel *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &open_channel__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t open_channel__pack_to_buffer
                     (const OpenChannel *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &open_channel__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
OpenChannel *
       open_channel__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (OpenChannel *)
     protobuf_c_message_unpack (&open_channel__descriptor,
                                allocator, len, data);
}
void   open_channel__free_unpacked
                     (OpenChannel *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &open_channel__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   open_anchor__init
                     (OpenAnchor         *message)
{
  static OpenAnchor init_value = OPEN_ANCHOR__INIT;
  *message = init_value;
}
size_t open_anchor__get_packed_size
                     (const OpenAnchor *message)
{
  assert(message->base.descriptor == &open_anchor__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t open_anchor__pack
                     (const OpenAnchor *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &open_anchor__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t open_anchor__pack_to_buffer
                     (const OpenAnchor *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &open_anchor__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
OpenAnchor *
       open_anchor__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (OpenAnchor *)
     protobuf_c_message_unpack (&open_anchor__descriptor,
                                allocator, len, data);
}
void   open_anchor__free_unpacked
                     (OpenAnchor *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &open_anchor__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   open_commit_sig__init
                     (OpenCommitSig         *message)
{
  static OpenCommitSig init_value = OPEN_COMMIT_SIG__INIT;
  *message = init_value;
}
size_t open_commit_sig__get_packed_size
                     (const OpenCommitSig *message)
{
  assert(message->base.descriptor == &open_commit_sig__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t open_commit_sig__pack
                     (const OpenCommitSig *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &open_commit_sig__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t open_commit_sig__pack_to_buffer
                     (const OpenCommitSig *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &open_commit_sig__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
OpenCommitSig *
       open_commit_sig__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (OpenCommitSig *)
     protobuf_c_message_unpack (&open_commit_sig__descriptor,
                                allocator, len, data);
}
void   open_commit_sig__free_unpacked
                     (OpenCommitSig *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &open_commit_sig__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   open_complete__init
                     (OpenComplete         *message)
{
  static OpenComplete init_value = OPEN_COMPLETE__INIT;
  *message = init_value;
}
size_t open_complete__get_packed_size
                     (const OpenComplete *message)
{
  assert(message->base.descriptor == &open_complete__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t open_complete__pack
                     (const OpenComplete *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &open_complete__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t open_complete__pack_to_buffer
                     (const OpenComplete *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &open_complete__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
OpenComplete *
       open_complete__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (OpenComplete *)
     protobuf_c_message_unpack (&open_complete__descriptor,
                                allocator, len, data);
}
void   open_complete__free_unpacked
                     (OpenComplete *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &open_complete__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   route_step__init
                     (RouteStep         *message)
{
  static RouteStep init_value = ROUTE_STEP__INIT;
  *message = init_value;
}
size_t route_step__get_packed_size
                     (const RouteStep *message)
{
  assert(message->base.descriptor == &route_step__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t route_step__pack
                     (const RouteStep *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &route_step__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t route_step__pack_to_buffer
                     (const RouteStep *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &route_step__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
RouteStep *
       route_step__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (RouteStep *)
     protobuf_c_message_unpack (&route_step__descriptor,
                                allocator, len, data);
}
void   route_step__free_unpacked
                     (RouteStep *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &route_step__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   route__init
                     (Route         *message)
{
  static Route init_value = ROUTE__INIT;
  *message = init_value;
}
size_t route__get_packed_size
                     (const Route *message)
{
  assert(message->base.descriptor == &route__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t route__pack
                     (const Route *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &route__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t route__pack_to_buffer
                     (const Route *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &route__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Route *
       route__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Route *)
     protobuf_c_message_unpack (&route__descriptor,
                                allocator, len, data);
}
void   route__free_unpacked
                     (Route *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &route__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   routing__init
                     (Routing         *message)
{
  static Routing init_value = ROUTING__INIT;
  *message = init_value;
}
size_t routing__get_packed_size
                     (const Routing *message)
{
  assert(message->base.descriptor == &routing__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t routing__pack
                     (const Routing *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &routing__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t routing__pack_to_buffer
                     (const Routing *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &routing__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Routing *
       routing__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Routing *)
     protobuf_c_message_unpack (&routing__descriptor,
                                allocator, len, data);
}
void   routing__free_unpacked
                     (Routing *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &routing__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   update_add_htlc__init
                     (UpdateAddHtlc         *message)
{
  static UpdateAddHtlc init_value = UPDATE_ADD_HTLC__INIT;
  *message = init_value;
}
size_t update_add_htlc__get_packed_size
                     (const UpdateAddHtlc *message)
{
  assert(message->base.descriptor == &update_add_htlc__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t update_add_htlc__pack
                     (const UpdateAddHtlc *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &update_add_htlc__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t update_add_htlc__pack_to_buffer
                     (const UpdateAddHtlc *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &update_add_htlc__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
UpdateAddHtlc *
       update_add_htlc__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (UpdateAddHtlc *)
     protobuf_c_message_unpack (&update_add_htlc__descriptor,
                                allocator, len, data);
}
void   update_add_htlc__free_unpacked
                     (UpdateAddHtlc *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &update_add_htlc__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   update_fulfill_htlc__init
                     (UpdateFulfillHtlc         *message)
{
  static UpdateFulfillHtlc init_value = UPDATE_FULFILL_HTLC__INIT;
  *message = init_value;
}
size_t update_fulfill_htlc__get_packed_size
                     (const UpdateFulfillHtlc *message)
{
  assert(message->base.descriptor == &update_fulfill_htlc__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t update_fulfill_htlc__pack
                     (const UpdateFulfillHtlc *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &update_fulfill_htlc__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t update_fulfill_htlc__pack_to_buffer
                     (const UpdateFulfillHtlc *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &update_fulfill_htlc__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
UpdateFulfillHtlc *
       update_fulfill_htlc__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (UpdateFulfillHtlc *)
     protobuf_c_message_unpack (&update_fulfill_htlc__descriptor,
                                allocator, len, data);
}
void   update_fulfill_htlc__free_unpacked
                     (UpdateFulfillHtlc *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &update_fulfill_htlc__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   fail_info__init
                     (FailInfo         *message)
{
  static FailInfo init_value = FAIL_INFO__INIT;
  *message = init_value;
}
size_t fail_info__get_packed_size
                     (const FailInfo *message)
{
  assert(message->base.descriptor == &fail_info__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t fail_info__pack
                     (const FailInfo *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &fail_info__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t fail_info__pack_to_buffer
                     (const FailInfo *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &fail_info__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
FailInfo *
       fail_info__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (FailInfo *)
     protobuf_c_message_unpack (&fail_info__descriptor,
                                allocator, len, data);
}
void   fail_info__free_unpacked
                     (FailInfo *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &fail_info__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   fail_reason__init
                     (FailReason         *message)
{
  static FailReason init_value = FAIL_REASON__INIT;
  *message = init_value;
}
size_t fail_reason__get_packed_size
                     (const FailReason *message)
{
  assert(message->base.descriptor == &fail_reason__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t fail_reason__pack
                     (const FailReason *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &fail_reason__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t fail_reason__pack_to_buffer
                     (const FailReason *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &fail_reason__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
FailReason *
       fail_reason__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (FailReason *)
     protobuf_c_message_unpack (&fail_reason__descriptor,
                                allocator, len, data);
}
void   fail_reason__free_unpacked
                     (FailReason *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &fail_reason__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   update_fail_htlc__init
                     (UpdateFailHtlc         *message)
{
  static UpdateFailHtlc init_value = UPDATE_FAIL_HTLC__INIT;
  *message = init_value;
}
size_t update_fail_htlc__get_packed_size
                     (const UpdateFailHtlc *message)
{
  assert(message->base.descriptor == &update_fail_htlc__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t update_fail_htlc__pack
                     (const UpdateFailHtlc *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &update_fail_htlc__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t update_fail_htlc__pack_to_buffer
                     (const UpdateFailHtlc *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &update_fail_htlc__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
UpdateFailHtlc *
       update_fail_htlc__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (UpdateFailHtlc *)
     protobuf_c_message_unpack (&update_fail_htlc__descriptor,
                                allocator, len, data);
}
void   update_fail_htlc__free_unpacked
                     (UpdateFailHtlc *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &update_fail_htlc__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   update_fee__init
                     (UpdateFee         *message)
{
  static UpdateFee init_value = UPDATE_FEE__INIT;
  *message = init_value;
}
size_t update_fee__get_packed_size
                     (const UpdateFee *message)
{
  assert(message->base.descriptor == &update_fee__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t update_fee__pack
                     (const UpdateFee *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &update_fee__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t update_fee__pack_to_buffer
                     (const UpdateFee *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &update_fee__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
UpdateFee *
       update_fee__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (UpdateFee *)
     protobuf_c_message_unpack (&update_fee__descriptor,
                                allocator, len, data);
}
void   update_fee__free_unpacked
                     (UpdateFee *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &update_fee__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   update_commit__init
                     (UpdateCommit         *message)
{
  static UpdateCommit init_value = UPDATE_COMMIT__INIT;
  *message = init_value;
}
size_t update_commit__get_packed_size
                     (const UpdateCommit *message)
{
  assert(message->base.descriptor == &update_commit__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t update_commit__pack
                     (const UpdateCommit *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &update_commit__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t update_commit__pack_to_buffer
                     (const UpdateCommit *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &update_commit__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
UpdateCommit *
       update_commit__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (UpdateCommit *)
     protobuf_c_message_unpack (&update_commit__descriptor,
                                allocator, len, data);
}
void   update_commit__free_unpacked
                     (UpdateCommit *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &update_commit__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   update_revocation__init
                     (UpdateRevocation         *message)
{
  static UpdateRevocation init_value = UPDATE_REVOCATION__INIT;
  *message = init_value;
}
size_t update_revocation__get_packed_size
                     (const UpdateRevocation *message)
{
  assert(message->base.descriptor == &update_revocation__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t update_revocation__pack
                     (const UpdateRevocation *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &update_revocation__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t update_revocation__pack_to_buffer
                     (const UpdateRevocation *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &update_revocation__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
UpdateRevocation *
       update_revocation__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (UpdateRevocation *)
     protobuf_c_message_unpack (&update_revocation__descriptor,
                                allocator, len, data);
}
void   update_revocation__free_unpacked
                     (UpdateRevocation *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &update_revocation__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   close_shutdown__init
                     (CloseShutdown         *message)
{
  static CloseShutdown init_value = CLOSE_SHUTDOWN__INIT;
  *message = init_value;
}
size_t close_shutdown__get_packed_size
                     (const CloseShutdown *message)
{
  assert(message->base.descriptor == &close_shutdown__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t close_shutdown__pack
                     (const CloseShutdown *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &close_shutdown__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t close_shutdown__pack_to_buffer
                     (const CloseShutdown *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &close_shutdown__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
CloseShutdown *
       close_shutdown__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (CloseShutdown *)
     protobuf_c_message_unpack (&close_shutdown__descriptor,
                                allocator, len, data);
}
void   close_shutdown__free_unpacked
                     (CloseShutdown *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &close_shutdown__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   close_signature__init
                     (CloseSignature         *message)
{
  static CloseSignature init_value = CLOSE_SIGNATURE__INIT;
  *message = init_value;
}
size_t close_signature__get_packed_size
                     (const CloseSignature *message)
{
  assert(message->base.descriptor == &close_signature__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t close_signature__pack
                     (const CloseSignature *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &close_signature__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t close_signature__pack_to_buffer
                     (const CloseSignature *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &close_signature__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
CloseSignature *
       close_signature__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (CloseSignature *)
     protobuf_c_message_unpack (&close_signature__descriptor,
                                allocator, len, data);
}
void   close_signature__free_unpacked
                     (CloseSignature *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &close_signature__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   error__init
                     (Error         *message)
{
  static Error init_value = ERROR__INIT;
  *message = init_value;
}
size_t error__get_packed_size
                     (const Error *message)
{
  assert(message->base.descriptor == &error__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t error__pack
                     (const Error *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &error__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t error__pack_to_buffer
                     (const Error *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &error__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Error *
       error__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Error *)
     protobuf_c_message_unpack (&error__descriptor,
                                allocator, len, data);
}
void   error__free_unpacked
                     (Error *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &error__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   nested_pkt__init
                     (NestedPkt         *message)
{
  static NestedPkt init_value = NESTED_PKT__INIT;
  *message = init_value;
}
size_t nested_pkt__get_packed_size
                     (const NestedPkt *message)
{
  assert(message->base.descriptor == &nested_pkt__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t nested_pkt__pack
                     (const NestedPkt *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &nested_pkt__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t nested_pkt__pack_to_buffer
                     (const NestedPkt *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &nested_pkt__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
NestedPkt *
       nested_pkt__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (NestedPkt *)
     protobuf_c_message_unpack (&nested_pkt__descriptor,
                                allocator, len, data);
}
void   nested_pkt__free_unpacked
                     (NestedPkt *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &nested_pkt__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   pkt__init
                     (Pkt         *message)
{
  static Pkt init_value = PKT__INIT;
  *message = init_value;
}
size_t pkt__get_packed_size
                     (const Pkt *message)
{
  assert(message->base.descriptor == &pkt__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t pkt__pack
                     (const Pkt *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &pkt__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t pkt__pack_to_buffer
                     (const Pkt *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &pkt__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Pkt *
       pkt__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Pkt *)
     protobuf_c_message_unpack (&pkt__descriptor,
                                allocator, len, data);
}
void   pkt__free_unpacked
                     (Pkt *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &pkt__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
static const ProtobufCFieldDescriptor sha256_hash__field_descriptors[4] =
{
  {
    "a",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_FIXED64,
    0,   /* quantifier_offset */
    offsetof(Sha256Hash, a),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "b",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_FIXED64,
    0,   /* quantifier_offset */
    offsetof(Sha256Hash, b),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "c",
    3,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_FIXED64,
    0,   /* quantifier_offset */
    offsetof(Sha256Hash, c),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "d",
    4,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_FIXED64,
    0,   /* quantifier_offset */
    offsetof(Sha256Hash, d),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned sha256_hash__field_indices_by_name[] = {
  0,   /* field[0] = a */
  1,   /* field[1] = b */
  2,   /* field[2] = c */
  3,   /* field[3] = d */
};
static const ProtobufCIntRange sha256_hash__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor sha256_hash__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "sha256_hash",
  "Sha256Hash",
  "Sha256Hash",
  "",
  sizeof(Sha256Hash),
  4,
  sha256_hash__field_descriptors,
  sha256_hash__field_indices_by_name,
  1,  sha256_hash__number_ranges,
  (ProtobufCMessageInit) sha256_hash__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor preimage__field_descriptors[4] =
{
  {
    "a",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_FIXED64,
    0,   /* quantifier_offset */
    offsetof(Preimage, a),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "b",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_FIXED64,
    0,   /* quantifier_offset */
    offsetof(Preimage, b),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "c",
    3,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_FIXED64,
    0,   /* quantifier_offset */
    offsetof(Preimage, c),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "d",
    4,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_FIXED64,
    0,   /* quantifier_offset */
    offsetof(Preimage, d),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned preimage__field_indices_by_name[] = {
  0,   /* field[0] = a */
  1,   /* field[1] = b */
  2,   /* field[2] = c */
  3,   /* field[3] = d */
};
static const ProtobufCIntRange preimage__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor preimage__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "preimage",
  "Preimage",
  "Preimage",
  "",
  sizeof(Preimage),
  4,
  preimage__field_descriptors,
  preimage__field_indices_by_name,
  1,  preimage__number_ranges,
  (ProtobufCMessageInit) preimage__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor signature__field_descriptors[8] =
{
  {
    "r1",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_FIXED64,
    0,   /* quantifier_offset */
    offsetof(Signature, r1),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "r2",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_FIXED64,
    0,   /* quantifier_offset */
    offsetof(Signature, r2),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "r3",
    3,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_FIXED64,
    0,   /* quantifier_offset */
    offsetof(Signature, r3),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "r4",
    4,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_FIXED64,
    0,   /* quantifier_offset */
    offsetof(Signature, r4),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "s1",
    5,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_FIXED64,
    0,   /* quantifier_offset */
    offsetof(Signature, s1),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "s2",
    6,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_FIXED64,
    0,   /* quantifier_offset */
    offsetof(Signature, s2),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "s3",
    7,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_FIXED64,
    0,   /* quantifier_offset */
    offsetof(Signature, s3),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "s4",
    8,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_FIXED64,
    0,   /* quantifier_offset */
    offsetof(Signature, s4),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned signature__field_indices_by_name[] = {
  0,   /* field[0] = r1 */
  1,   /* field[1] = r2 */
  2,   /* field[2] = r3 */
  3,   /* field[3] = r4 */
  4,   /* field[4] = s1 */
  5,   /* field[5] = s2 */
  6,   /* field[6] = s3 */
  7,   /* field[7] = s4 */
};
static const ProtobufCIntRange signature__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 8 }
};
const ProtobufCMessageDescriptor signature__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "signature",
  "Signature",
  "Signature",
  "",
  sizeof(Signature),
  8,
  signature__field_descriptors,
  signature__field_indices_by_name,
  1,  signature__number_ranges,
  (ProtobufCMessageInit) signature__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor locktime__field_descriptors[2] =
{
  {
    "seconds",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(Locktime, locktime_case),
    offsetof(Locktime, seconds),
    NULL,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "blocks",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(Locktime, locktime_case),
    offsetof(Locktime, blocks),
    NULL,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned locktime__field_indices_by_name[] = {
  1,   /* field[1] = blocks */
  0,   /* field[0] = seconds */
};
static const ProtobufCIntRange locktime__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor locktime__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "locktime",
  "Locktime",
  "Locktime",
  "",
  sizeof(Locktime),
  2,
  locktime__field_descriptors,
  locktime__field_indices_by_name,
  1,  locktime__number_ranges,
  (ProtobufCMessageInit) locktime__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor bitcoin_pubkey__field_descriptors[1] =
{
  {
    "key",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(BitcoinPubkey, key),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned bitcoin_pubkey__field_indices_by_name[] = {
  0,   /* field[0] = key */
};
static const ProtobufCIntRange bitcoin_pubkey__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor bitcoin_pubkey__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "bitcoin_pubkey",
  "BitcoinPubkey",
  "BitcoinPubkey",
  "",
  sizeof(BitcoinPubkey),
  1,
  bitcoin_pubkey__field_descriptors,
  bitcoin_pubkey__field_indices_by_name,
  1,  bitcoin_pubkey__number_ranges,
  (ProtobufCMessageInit) bitcoin_pubkey__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const int64_t funding__fixed__default_value = 0ll;
static const int32_t funding__per_micro_satoshi__default_value = 0;
static const ProtobufCFieldDescriptor funding__field_descriptors[2] =
{
  {
    "fixed",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_INT64,
    offsetof(Funding, has_fixed),
    offsetof(Funding, fixed),
    NULL,
    &funding__fixed__default_value,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "per_micro_satoshi",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_INT32,
    offsetof(Funding, has_per_micro_satoshi),
    offsetof(Funding, per_micro_satoshi),
    NULL,
    &funding__per_micro_satoshi__default_value,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned funding__field_indices_by_name[] = {
  0,   /* field[0] = fixed */
  1,   /* field[1] = per_micro_satoshi */
};
static const ProtobufCIntRange funding__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor funding__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "funding",
  "Funding",
  "Funding",
  "",
  sizeof(Funding),
  2,
  funding__field_descriptors,
  funding__field_indices_by_name,
  1,  funding__number_ranges,
  (ProtobufCMessageInit) funding__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor authenticate__field_descriptors[2] =
{
  {
    "node_id",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(Authenticate, node_id),
    &bitcoin_pubkey__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "session_sig",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(Authenticate, session_sig),
    &signature__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned authenticate__field_indices_by_name[] = {
  0,   /* field[0] = node_id */
  1,   /* field[1] = session_sig */
};
static const ProtobufCIntRange authenticate__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor authenticate__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "authenticate",
  "Authenticate",
  "Authenticate",
  "",
  sizeof(Authenticate),
  2,
  authenticate__field_descriptors,
  authenticate__field_indices_by_name,
  1,  authenticate__number_ranges,
  (ProtobufCMessageInit) authenticate__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor init__field_descriptors[2] =
{
  {
    "ack",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT64,
    0,   /* quantifier_offset */
    offsetof(Init, ack),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "features",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(Init, has_features),
    offsetof(Init, features),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned init__field_indices_by_name[] = {
  0,   /* field[0] = ack */
  1,   /* field[1] = features */
};
static const ProtobufCIntRange init__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor init__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "init",
  "Init",
  "Init",
  "",
  sizeof(Init),
  2,
  init__field_descriptors,
  init__field_indices_by_name,
  1,  init__number_ranges,
  (ProtobufCMessageInit) init__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCEnumValue open_channel__anchor_offer__enum_values_by_number[2] =
{
  { "WILL_CREATE_ANCHOR", "OPEN_CHANNEL__ANCHOR_OFFER__WILL_CREATE_ANCHOR", 1 },
  { "WONT_CREATE_ANCHOR", "OPEN_CHANNEL__ANCHOR_OFFER__WONT_CREATE_ANCHOR", 2 },
};
static const ProtobufCIntRange open_channel__anchor_offer__value_ranges[] = {
{1, 0},{0, 2}
};
static const ProtobufCEnumValueIndex open_channel__anchor_offer__enum_values_by_name[2] =
{
  { "WILL_CREATE_ANCHOR", 0 },
  { "WONT_CREATE_ANCHOR", 1 },
};
const ProtobufCEnumDescriptor open_channel__anchor_offer__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "open_channel.anchor_offer",
  "anchor_offer",
  "OpenChannel__AnchorOffer",
  "",
  2,
  open_channel__anchor_offer__enum_values_by_number,
  2,
  open_channel__anchor_offer__enum_values_by_name,
  1,
  open_channel__anchor_offer__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const uint32_t open_channel__min_depth__default_value = 0u;
static const ProtobufCFieldDescriptor open_channel__field_descriptors[8] =
{
  {
    "delay",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(OpenChannel, delay),
    &locktime__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "revocation_hash",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(OpenChannel, revocation_hash),
    &sha256_hash__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "commit_key",
    3,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(OpenChannel, commit_key),
    &bitcoin_pubkey__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "final_key",
    4,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(OpenChannel, final_key),
    &bitcoin_pubkey__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "anch",
    5,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    offsetof(OpenChannel, anch),
    &open_channel__anchor_offer__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "min_depth",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(OpenChannel, has_min_depth),
    offsetof(OpenChannel, min_depth),
    NULL,
    &open_channel__min_depth__default_value,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "initial_fee_rate",
    7,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT64,
    0,   /* quantifier_offset */
    offsetof(OpenChannel, initial_fee_rate),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "next_revocation_hash",
    8,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(OpenChannel, next_revocation_hash),
    &sha256_hash__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned open_channel__field_indices_by_name[] = {
  4,   /* field[4] = anch */
  2,   /* field[2] = commit_key */
  0,   /* field[0] = delay */
  3,   /* field[3] = final_key */
  6,   /* field[6] = initial_fee_rate */
  5,   /* field[5] = min_depth */
  7,   /* field[7] = next_revocation_hash */
  1,   /* field[1] = revocation_hash */
};
static const ProtobufCIntRange open_channel__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 8 }
};
const ProtobufCMessageDescriptor open_channel__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "open_channel",
  "OpenChannel",
  "OpenChannel",
  "",
  sizeof(OpenChannel),
  8,
  open_channel__field_descriptors,
  open_channel__field_indices_by_name,
  1,  open_channel__number_ranges,
  (ProtobufCMessageInit) open_channel__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor open_anchor__field_descriptors[3] =
{
  {
    "txid",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(OpenAnchor, txid),
    &sha256_hash__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "output_index",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(OpenAnchor, output_index),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "amount",
    3,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT64,
    0,   /* quantifier_offset */
    offsetof(OpenAnchor, amount),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned open_anchor__field_indices_by_name[] = {
  2,   /* field[2] = amount */
  1,   /* field[1] = output_index */
  0,   /* field[0] = txid */
};
static const ProtobufCIntRange open_anchor__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor open_anchor__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "open_anchor",
  "OpenAnchor",
  "OpenAnchor",
  "",
  sizeof(OpenAnchor),
  3,
  open_anchor__field_descriptors,
  open_anchor__field_indices_by_name,
  1,  open_anchor__number_ranges,
  (ProtobufCMessageInit) open_anchor__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor open_commit_sig__field_descriptors[1] =
{
  {
    "sig",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(OpenCommitSig, sig),
    &signature__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned open_commit_sig__field_indices_by_name[] = {
  0,   /* field[0] = sig */
};
static const ProtobufCIntRange open_commit_sig__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor open_commit_sig__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "open_commit_sig",
  "OpenCommitSig",
  "OpenCommitSig",
  "",
  sizeof(OpenCommitSig),
  1,
  open_commit_sig__field_descriptors,
  open_commit_sig__field_indices_by_name,
  1,  open_commit_sig__number_ranges,
  (ProtobufCMessageInit) open_commit_sig__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor open_complete__field_descriptors[1] =
{
  {
    "blockid",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(OpenComplete, blockid),
    &sha256_hash__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned open_complete__field_indices_by_name[] = {
  0,   /* field[0] = blockid */
};
static const ProtobufCIntRange open_complete__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor open_complete__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "open_complete",
  "OpenComplete",
  "OpenComplete",
  "",
  sizeof(OpenComplete),
  1,
  open_complete__field_descriptors,
  open_complete__field_indices_by_name,
  1,  open_complete__number_ranges,
  (ProtobufCMessageInit) open_complete__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor route_step__field_descriptors[3] =
{
  {
    "end",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(RouteStep, next_case),
    offsetof(RouteStep, end),
    NULL,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "bitcoin",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(RouteStep, next_case),
    offsetof(RouteStep, bitcoin),
    &bitcoin_pubkey__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "amount",
    4,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(RouteStep, amount),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned route_step__field_indices_by_name[] = {
  2,   /* field[2] = amount */
  1,   /* field[1] = bitcoin */
  0,   /* field[0] = end */
};
static const ProtobufCIntRange route_step__number_ranges[2 + 1] =
{
  { 1, 0 },
  { 4, 2 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor route_step__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "route_step",
  "RouteStep",
  "RouteStep",
  "",
  sizeof(RouteStep),
  3,
  route_step__field_descriptors,
  route_step__field_indices_by_name,
  2,  route_step__number_ranges,
  (ProtobufCMessageInit) route_step__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor route__field_descriptors[1] =
{
  {
    "steps",
    1,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Route, n_steps),
    offsetof(Route, steps),
    &route_step__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned route__field_indices_by_name[] = {
  0,   /* field[0] = steps */
};
static const ProtobufCIntRange route__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor route__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "route",
  "Route",
  "Route",
  "",
  sizeof(Route),
  1,
  route__field_descriptors,
  route__field_indices_by_name,
  1,  route__number_ranges,
  (ProtobufCMessageInit) route__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor routing__field_descriptors[1] =
{
  {
    "info",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(Routing, info),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned routing__field_indices_by_name[] = {
  0,   /* field[0] = info */
};
static const ProtobufCIntRange routing__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor routing__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "routing",
  "Routing",
  "Routing",
  "",
  sizeof(Routing),
  1,
  routing__field_descriptors,
  routing__field_indices_by_name,
  1,  routing__number_ranges,
  (ProtobufCMessageInit) routing__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor update_add_htlc__field_descriptors[5] =
{
  {
    "id",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT64,
    0,   /* quantifier_offset */
    offsetof(UpdateAddHtlc, id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "amount_msat",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(UpdateAddHtlc, amount_msat),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "r_hash",
    3,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(UpdateAddHtlc, r_hash),
    &sha256_hash__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "expiry",
    4,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(UpdateAddHtlc, expiry),
    &locktime__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "route",
    5,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(UpdateAddHtlc, route),
    &routing__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned update_add_htlc__field_indices_by_name[] = {
  1,   /* field[1] = amount_msat */
  3,   /* field[3] = expiry */
  0,   /* field[0] = id */
  2,   /* field[2] = r_hash */
  4,   /* field[4] = route */
};
static const ProtobufCIntRange update_add_htlc__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 5 }
};
const ProtobufCMessageDescriptor update_add_htlc__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "update_add_htlc",
  "UpdateAddHtlc",
  "UpdateAddHtlc",
  "",
  sizeof(UpdateAddHtlc),
  5,
  update_add_htlc__field_descriptors,
  update_add_htlc__field_indices_by_name,
  1,  update_add_htlc__number_ranges,
  (ProtobufCMessageInit) update_add_htlc__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor update_fulfill_htlc__field_descriptors[2] =
{
  {
    "id",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT64,
    0,   /* quantifier_offset */
    offsetof(UpdateFulfillHtlc, id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "r",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(UpdateFulfillHtlc, r),
    &preimage__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned update_fulfill_htlc__field_indices_by_name[] = {
  0,   /* field[0] = id */
  1,   /* field[1] = r */
};
static const ProtobufCIntRange update_fulfill_htlc__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor update_fulfill_htlc__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "update_fulfill_htlc",
  "UpdateFulfillHtlc",
  "UpdateFulfillHtlc",
  "",
  sizeof(UpdateFulfillHtlc),
  2,
  update_fulfill_htlc__field_descriptors,
  update_fulfill_htlc__field_indices_by_name,
  1,  update_fulfill_htlc__number_ranges,
  (ProtobufCMessageInit) update_fulfill_htlc__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor fail_info__field_descriptors[3] =
{
  {
    "id",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(FailInfo, id),
    &bitcoin_pubkey__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "error_code",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(FailInfo, error_code),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "reason",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(FailInfo, reason),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned fail_info__field_indices_by_name[] = {
  1,   /* field[1] = error_code */
  0,   /* field[0] = id */
  2,   /* field[2] = reason */
};
static const ProtobufCIntRange fail_info__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor fail_info__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "fail_info",
  "FailInfo",
  "FailInfo",
  "",
  sizeof(FailInfo),
  3,
  fail_info__field_descriptors,
  fail_info__field_indices_by_name,
  1,  fail_info__number_ranges,
  (ProtobufCMessageInit) fail_info__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor fail_reason__field_descriptors[1] =
{
  {
    "info",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(FailReason, info),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned fail_reason__field_indices_by_name[] = {
  0,   /* field[0] = info */
};
static const ProtobufCIntRange fail_reason__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor fail_reason__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "fail_reason",
  "FailReason",
  "FailReason",
  "",
  sizeof(FailReason),
  1,
  fail_reason__field_descriptors,
  fail_reason__field_indices_by_name,
  1,  fail_reason__number_ranges,
  (ProtobufCMessageInit) fail_reason__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor update_fail_htlc__field_descriptors[2] =
{
  {
    "id",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT64,
    0,   /* quantifier_offset */
    offsetof(UpdateFailHtlc, id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "reason",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(UpdateFailHtlc, reason),
    &fail_reason__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned update_fail_htlc__field_indices_by_name[] = {
  0,   /* field[0] = id */
  1,   /* field[1] = reason */
};
static const ProtobufCIntRange update_fail_htlc__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor update_fail_htlc__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "update_fail_htlc",
  "UpdateFailHtlc",
  "UpdateFailHtlc",
  "",
  sizeof(UpdateFailHtlc),
  2,
  update_fail_htlc__field_descriptors,
  update_fail_htlc__field_indices_by_name,
  1,  update_fail_htlc__number_ranges,
  (ProtobufCMessageInit) update_fail_htlc__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor update_fee__field_descriptors[1] =
{
  {
    "fee_rate",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(UpdateFee, fee_rate),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned update_fee__field_indices_by_name[] = {
  0,   /* field[0] = fee_rate */
};
static const ProtobufCIntRange update_fee__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor update_fee__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "update_fee",
  "UpdateFee",
  "UpdateFee",
  "",
  sizeof(UpdateFee),
  1,
  update_fee__field_descriptors,
  update_fee__field_indices_by_name,
  1,  update_fee__number_ranges,
  (ProtobufCMessageInit) update_fee__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor update_commit__field_descriptors[1] =
{
  {
    "sig",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(UpdateCommit, sig),
    &signature__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned update_commit__field_indices_by_name[] = {
  0,   /* field[0] = sig */
};
static const ProtobufCIntRange update_commit__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor update_commit__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "update_commit",
  "UpdateCommit",
  "UpdateCommit",
  "",
  sizeof(UpdateCommit),
  1,
  update_commit__field_descriptors,
  update_commit__field_indices_by_name,
  1,  update_commit__number_ranges,
  (ProtobufCMessageInit) update_commit__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor update_revocation__field_descriptors[2] =
{
  {
    "revocation_preimage",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(UpdateRevocation, revocation_preimage),
    &sha256_hash__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "next_revocation_hash",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(UpdateRevocation, next_revocation_hash),
    &sha256_hash__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned update_revocation__field_indices_by_name[] = {
  1,   /* field[1] = next_revocation_hash */
  0,   /* field[0] = revocation_preimage */
};
static const ProtobufCIntRange update_revocation__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor update_revocation__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "update_revocation",
  "UpdateRevocation",
  "UpdateRevocation",
  "",
  sizeof(UpdateRevocation),
  2,
  update_revocation__field_descriptors,
  update_revocation__field_indices_by_name,
  1,  update_revocation__number_ranges,
  (ProtobufCMessageInit) update_revocation__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor close_shutdown__field_descriptors[1] =
{
  {
    "scriptPubkey",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(CloseShutdown, scriptpubkey),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned close_shutdown__field_indices_by_name[] = {
  0,   /* field[0] = scriptPubkey */
};
static const ProtobufCIntRange close_shutdown__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor close_shutdown__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "close_shutdown",
  "CloseShutdown",
  "CloseShutdown",
  "",
  sizeof(CloseShutdown),
  1,
  close_shutdown__field_descriptors,
  close_shutdown__field_indices_by_name,
  1,  close_shutdown__number_ranges,
  (ProtobufCMessageInit) close_shutdown__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor close_signature__field_descriptors[2] =
{
  {
    "close_fee",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT64,
    0,   /* quantifier_offset */
    offsetof(CloseSignature, close_fee),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "sig",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(CloseSignature, sig),
    &signature__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned close_signature__field_indices_by_name[] = {
  0,   /* field[0] = close_fee */
  1,   /* field[1] = sig */
};
static const ProtobufCIntRange close_signature__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor close_signature__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "close_signature",
  "CloseSignature",
  "CloseSignature",
  "",
  sizeof(CloseSignature),
  2,
  close_signature__field_descriptors,
  close_signature__field_indices_by_name,
  1,  close_signature__number_ranges,
  (ProtobufCMessageInit) close_signature__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor error__field_descriptors[1] =
{
  {
    "problem",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(Error, problem),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned error__field_indices_by_name[] = {
  0,   /* field[0] = problem */
};
static const ProtobufCIntRange error__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor error__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "error",
  "Error",
  "Error",
  "",
  sizeof(Error),
  1,
  error__field_descriptors,
  error__field_indices_by_name,
  1,  error__number_ranges,
  (ProtobufCMessageInit) error__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor nested_pkt__field_descriptors[2] =
{
  {
    "type",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(NestedPkt, type),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "inner_pkt",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(NestedPkt, inner_pkt),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned nested_pkt__field_indices_by_name[] = {
  1,   /* field[1] = inner_pkt */
  0,   /* field[0] = type */
};
static const ProtobufCIntRange nested_pkt__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor nested_pkt__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "nested_pkt",
  "NestedPkt",
  "NestedPkt",
  "",
  sizeof(NestedPkt),
  2,
  nested_pkt__field_descriptors,
  nested_pkt__field_indices_by_name,
  1,  nested_pkt__number_ranges,
  (ProtobufCMessageInit) nested_pkt__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor pkt__field_descriptors[16] =
{
  {
    "update_add_htlc",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, update_add_htlc),
    &update_add_htlc__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "update_fulfill_htlc",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, update_fulfill_htlc),
    &update_fulfill_htlc__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "update_fail_htlc",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, update_fail_htlc),
    &update_fail_htlc__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "update_fee",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, update_fee),
    &update_fee__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "update_commit",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, update_commit),
    &update_commit__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "update_revocation",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, update_revocation),
    &update_revocation__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "open",
    20,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, open),
    &open_channel__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "open_anchor",
    21,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, open_anchor),
    &open_anchor__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "open_commit_sig",
    22,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, open_commit_sig),
    &open_commit_sig__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "open_complete",
    23,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, open_complete),
    &open_complete__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "close_shutdown",
    30,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, close_shutdown),
    &close_shutdown__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "close_signature",
    31,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, close_signature),
    &close_signature__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "error",
    40,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, error),
    &error__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "auth",
    50,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, auth),
    &authenticate__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "init",
    51,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, init),
    &init__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "nested",
    128,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, nested),
    &nested_pkt__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned pkt__field_indices_by_name[] = {
  13,   /* field[13] = auth */
  10,   /* field[10] = close_shutdown */
  11,   /* field[11] = close_signature */
  12,   /* field[12] = error */
  14,   /* field[14] = init */
  15,   /* field[15] = nested */
  6,   /* field[6] = open */
  7,   /* field[7] = open_anchor */
  8,   /* field[8] = open_commit_sig */
  9,   /* field[9] = open_complete */
  0,   /* field[0] = update_add_htlc */
  4,   /* field[4] = update_commit */
  2,   /* field[2] = update_fail_htlc */
  3,   /* field[3] = update_fee */
  1,   /* field[1] = update_fulfill_htlc */
  5,   /* field[5] = update_revocation */
};
static const ProtobufCIntRange pkt__number_ranges[6 + 1] =
{
  { 2, 0 },
  { 20, 6 },
  { 30, 10 },
  { 40, 12 },
  { 50, 13 },
  { 128, 15 },
  { 0, 16 }
};
const ProtobufCMessageDescriptor pkt__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "pkt",
  "Pkt",
  "Pkt",
  "",
  sizeof(Pkt),
  16,
  pkt__field_descriptors,
  pkt__field_indices_by_name,
  6,  pkt__number_ranges,
  (ProtobufCMessageInit) pkt__init,
  NULL,NULL,NULL    /* reserved[123] */
};
