// This file was automatically derived from the JSON-RPC schemas in
// `doc/schemas`. Do not edit this file manually as it would get
// overwritten.

use crate::pb;
#[allow(unused_imports)]
use cln_rpc::model::{requests, responses};
use std::convert::From;

#[allow(unused_variables, deprecated)]
impl From<requests::InvoiceRequest> for pb::InvoiceRequest {
    fn from(c: requests::InvoiceRequest) -> Self {
        Self {
            amount_msat: Some(c.amount_msat.into()), // Rule #2 for type msat_or_any
            description: c.description,              // Rule #2 for type string
            label: c.label,                          // Rule #2 for type string
            expiry: c.expiry,                        // Rule #2 for type u64?
            // Field: Invoice.fallbacks[]
            fallbacks: c
                .fallbacks
                .map(|arr| arr.into_iter().map(|i| i.into()).collect())
                .unwrap_or(vec![]), // Rule #3
            preimage: c.preimage.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            cltv: c.cltv,                                          // Rule #2 for type u32?
            deschashonly: c.deschashonly,                          // Rule #2 for type boolean?
        }
    }
}

#[allow(unused_variables, deprecated)]
impl From<pb::InvoiceRequest> for requests::InvoiceRequest {
    fn from(c: pb::InvoiceRequest) -> Self {
        Self {
            amount_msat: c.amount_msat.unwrap().into(), // Rule #1 for type msat_or_any
            description: c.description,                 // Rule #1 for type string
            label: c.label,                             // Rule #1 for type string
            expiry: c.expiry,                           // Rule #1 for type u64?
            fallbacks: Some(c.fallbacks.into_iter().map(|s| s.into()).collect()), // Rule #4
            preimage: c.preimage.map(|v| hex::encode(v)), // Rule #1 for type hex?
            cltv: c.cltv,                               // Rule #1 for type u32?
            deschashonly: c.deschashonly,               // Rule #1 for type boolean?
        }
    }
}

#[allow(unused_variables, deprecated)]
impl From<responses::InvoiceResponse> for pb::InvoiceResponse {
    fn from(c: responses::InvoiceResponse) -> Self {
        Self {
            bolt11: c.bolt11,                                 // Rule #2 for type string
            payment_hash: c.payment_hash.to_vec(),            // Rule #2 for type hash
            payment_secret: c.payment_secret.to_vec(),        // Rule #2 for type secret
            expires_at: c.expires_at,                         // Rule #2 for type u64
            warning_capacity: c.warning_capacity,             // Rule #2 for type string?
            warning_offline: c.warning_offline,               // Rule #2 for type string?
            warning_deadends: c.warning_deadends,             // Rule #2 for type string?
            warning_private_unused: c.warning_private_unused, // Rule #2 for type string?
            warning_mpp: c.warning_mpp,                       // Rule #2 for type string?
        }
    }
}
