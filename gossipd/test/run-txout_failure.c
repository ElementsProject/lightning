#include "config.h"
#include "../txout_failures.c"
#include "../common/timeout.c"
#include <common/blinding.h>
#include <common/channel_type.h>
#include <common/daemon_conn.h>
#include <common/ecdh.h>
#include <common/json_stream.h>
#include <common/onionreply.h>
#include <common/sciddir_or_pubkey.h>
#include <common/setup.h>
#include <gossipd/gossip_store.h>
#include <gossipd/queries.h>
#include <stdio.h>

/* AUTOGENERATED MOCKS START */
/* Generated stub for blinding_hash_e_and_ss */
void blinding_hash_e_and_ss(const struct pubkey *e UNNEEDED,
			    const struct secret *ss UNNEEDED,
			    struct sha256 *sha UNNEEDED)
{ fprintf(stderr, "blinding_hash_e_and_ss called!\n"); abort(); }
/* Generated stub for blinding_next_privkey */
bool blinding_next_privkey(const struct privkey *e UNNEEDED,
			   const struct sha256 *h UNNEEDED,
			   struct privkey *next UNNEEDED)
{ fprintf(stderr, "blinding_next_privkey called!\n"); abort(); }
/* Generated stub for blinding_next_pubkey */
bool blinding_next_pubkey(const struct pubkey *pk UNNEEDED,
			  const struct sha256 *h UNNEEDED,
			  struct pubkey *next UNNEEDED)
{ fprintf(stderr, "blinding_next_pubkey called!\n"); abort(); }
/* Generated stub for fromwire_sciddir_or_pubkey */
void fromwire_sciddir_or_pubkey(const u8 **cursor UNNEEDED, size_t *max UNNEEDED,
				struct sciddir_or_pubkey *sciddpk UNNEEDED)
{ fprintf(stderr, "fromwire_sciddir_or_pubkey called!\n"); abort(); }
/* Generated stub for towire_sciddir_or_pubkey */
void towire_sciddir_or_pubkey(u8 **pptr UNNEEDED,
			      const struct sciddir_or_pubkey *sciddpk UNNEEDED)
{ fprintf(stderr, "towire_sciddir_or_pubkey called!\n"); abort(); }
/* AUTOGENERATED MOCKS END */

int main(int argc, char *argv[])
{
	struct txout_failures *txf;
	struct timer *t;
	struct short_channel_id scid1, scid2;
	struct daemon *daemon;

	common_setup(argv[0]);

	daemon = tal(tmpctx, struct daemon);
	timers_init(&daemon->timers, time_mono());
	txf = txout_failures_new(tmpctx, daemon);

	scid1.u64 = 100;
	scid2.u64 = 200;
	assert(!in_txout_failures(txf, scid1));
	assert(!in_txout_failures(txf, scid2));

	txout_failures_add(txf, scid1);
	assert(in_txout_failures(txf, scid1));
	assert(!in_txout_failures(txf, scid2));
	assert(txf->num == 1);

	txout_failures_add(txf, scid2);
	assert(in_txout_failures(txf, scid1));
	assert(in_txout_failures(txf, scid2));
	assert(txf->num == 2);

	/* Move time forward 1 hour. */
	t = timers_expire(&daemon->timers,
			  timemono_add(time_mono(),
				       time_from_sec(3601)));
	assert(t);
	timer_expired(t);

	/* Still there, just old.  Refresh scid1 */
	assert(txf->num == 0);
	assert(in_txout_failures(txf, scid1));
	assert(txf->num == 1);

	t = timers_expire(&daemon->timers,
			  timemono_add(time_mono(),
				       time_from_sec(3601)));
	assert(t);
	timer_expired(t);

	assert(txf->num == 0);
	assert(in_txout_failures(txf, scid1));
	assert(txf->num == 1);
	assert(!in_txout_failures(txf, scid2));

	tal_free(txf);
	timers_cleanup(&daemon->timers);
	common_shutdown();

	return 0;
}
