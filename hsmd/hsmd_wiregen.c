/* This file was generated by generate-wire.py */
/* Do not modify this file! Modify the .csv file it was generated from. */
/* Original template can be found at tools/gen/impl_template */

#include <hsmd/hsmd_wiregen.h>
#include <assert.h>
#include <ccan/array_size/array_size.h>
#include <ccan/mem/mem.h>
#include <ccan/tal/str/str.h>
#include <common/utils.h>
#include <stdio.h>

#ifndef SUPERVERBOSE
#define SUPERVERBOSE(...)
#endif

/* Return signature for a funding tx. */

const char *hsmd_wire_name(int e)
{
	static char invalidbuf[sizeof("INVALID ") + STR_MAX_CHARS(e)];

	switch ((enum hsmd_wire)e) {
	case WIRE_HSMSTATUS_CLIENT_BAD_REQUEST: return "WIRE_HSMSTATUS_CLIENT_BAD_REQUEST";
	case WIRE_HSMD_INIT: return "WIRE_HSMD_INIT";
	case WIRE_HSMD_INIT_REPLY: return "WIRE_HSMD_INIT_REPLY";
	case WIRE_HSMD_CLIENT_HSMFD: return "WIRE_HSMD_CLIENT_HSMFD";
	case WIRE_HSMD_CLIENT_HSMFD_REPLY: return "WIRE_HSMD_CLIENT_HSMFD_REPLY";
	case WIRE_HSMD_GET_CHANNEL_BASEPOINTS: return "WIRE_HSMD_GET_CHANNEL_BASEPOINTS";
	case WIRE_HSMD_GET_CHANNEL_BASEPOINTS_REPLY: return "WIRE_HSMD_GET_CHANNEL_BASEPOINTS_REPLY";
	case WIRE_HSMD_NODE_ANNOUNCEMENT_SIG_REQ: return "WIRE_HSMD_NODE_ANNOUNCEMENT_SIG_REQ";
	case WIRE_HSMD_NODE_ANNOUNCEMENT_SIG_REPLY: return "WIRE_HSMD_NODE_ANNOUNCEMENT_SIG_REPLY";
	case WIRE_HSMD_SIGN_WITHDRAWAL: return "WIRE_HSMD_SIGN_WITHDRAWAL";
	case WIRE_HSMD_SIGN_WITHDRAWAL_REPLY: return "WIRE_HSMD_SIGN_WITHDRAWAL_REPLY";
	case WIRE_HSMD_SIGN_INVOICE: return "WIRE_HSMD_SIGN_INVOICE";
	case WIRE_HSMD_SIGN_INVOICE_REPLY: return "WIRE_HSMD_SIGN_INVOICE_REPLY";
	case WIRE_HSMD_ECDH_REQ: return "WIRE_HSMD_ECDH_REQ";
	case WIRE_HSMD_ECDH_RESP: return "WIRE_HSMD_ECDH_RESP";
	case WIRE_HSMD_CANNOUNCEMENT_SIG_REQ: return "WIRE_HSMD_CANNOUNCEMENT_SIG_REQ";
	case WIRE_HSMD_CANNOUNCEMENT_SIG_REPLY: return "WIRE_HSMD_CANNOUNCEMENT_SIG_REPLY";
	case WIRE_HSMD_CUPDATE_SIG_REQ: return "WIRE_HSMD_CUPDATE_SIG_REQ";
	case WIRE_HSMD_CUPDATE_SIG_REPLY: return "WIRE_HSMD_CUPDATE_SIG_REPLY";
	case WIRE_HSMD_SIGN_COMMITMENT_TX: return "WIRE_HSMD_SIGN_COMMITMENT_TX";
	case WIRE_HSMD_SIGN_COMMITMENT_TX_REPLY: return "WIRE_HSMD_SIGN_COMMITMENT_TX_REPLY";
	case WIRE_HSMD_SIGN_DELAYED_PAYMENT_TO_US: return "WIRE_HSMD_SIGN_DELAYED_PAYMENT_TO_US";
	case WIRE_HSMD_SIGN_REMOTE_HTLC_TO_US: return "WIRE_HSMD_SIGN_REMOTE_HTLC_TO_US";
	case WIRE_HSMD_SIGN_PENALTY_TO_US: return "WIRE_HSMD_SIGN_PENALTY_TO_US";
	case WIRE_HSMD_SIGN_LOCAL_HTLC_TX: return "WIRE_HSMD_SIGN_LOCAL_HTLC_TX";
	case WIRE_HSMD_SIGN_REMOTE_COMMITMENT_TX: return "WIRE_HSMD_SIGN_REMOTE_COMMITMENT_TX";
	case WIRE_HSMD_SIGN_REMOTE_HTLC_TX: return "WIRE_HSMD_SIGN_REMOTE_HTLC_TX";
	case WIRE_HSMD_SIGN_MUTUAL_CLOSE_TX: return "WIRE_HSMD_SIGN_MUTUAL_CLOSE_TX";
	case WIRE_HSMD_SIGN_TX_REPLY: return "WIRE_HSMD_SIGN_TX_REPLY";
	case WIRE_HSMD_GET_PER_COMMITMENT_POINT: return "WIRE_HSMD_GET_PER_COMMITMENT_POINT";
	case WIRE_HSMD_GET_PER_COMMITMENT_POINT_REPLY: return "WIRE_HSMD_GET_PER_COMMITMENT_POINT_REPLY";
	case WIRE_HSMD_DEV_MEMLEAK: return "WIRE_HSMD_DEV_MEMLEAK";
	case WIRE_HSMD_DEV_MEMLEAK_REPLY: return "WIRE_HSMD_DEV_MEMLEAK_REPLY";
	case WIRE_HSMD_CHECK_FUTURE_SECRET: return "WIRE_HSMD_CHECK_FUTURE_SECRET";
	case WIRE_HSMD_CHECK_FUTURE_SECRET_REPLY: return "WIRE_HSMD_CHECK_FUTURE_SECRET_REPLY";
	case WIRE_HSMD_SIGN_MESSAGE: return "WIRE_HSMD_SIGN_MESSAGE";
	case WIRE_HSMD_SIGN_MESSAGE_REPLY: return "WIRE_HSMD_SIGN_MESSAGE_REPLY";
	case WIRE_HSMD_GET_OUTPUT_SCRIPTPUBKEY: return "WIRE_HSMD_GET_OUTPUT_SCRIPTPUBKEY";
	case WIRE_HSMD_GET_OUTPUT_SCRIPTPUBKEY_REPLY: return "WIRE_HSMD_GET_OUTPUT_SCRIPTPUBKEY_REPLY";
	case WIRE_HSMD_SIGN_BOLT12: return "WIRE_HSMD_SIGN_BOLT12";
	case WIRE_HSMD_SIGN_BOLT12_REPLY: return "WIRE_HSMD_SIGN_BOLT12_REPLY";
	}

	snprintf(invalidbuf, sizeof(invalidbuf), "INVALID %i", e);
	return invalidbuf;
}

bool hsmd_wire_is_defined(u16 type)
{
	switch ((enum hsmd_wire)type) {
	case WIRE_HSMSTATUS_CLIENT_BAD_REQUEST:;
	case WIRE_HSMD_INIT:;
	case WIRE_HSMD_INIT_REPLY:;
	case WIRE_HSMD_CLIENT_HSMFD:;
	case WIRE_HSMD_CLIENT_HSMFD_REPLY:;
	case WIRE_HSMD_GET_CHANNEL_BASEPOINTS:;
	case WIRE_HSMD_GET_CHANNEL_BASEPOINTS_REPLY:;
	case WIRE_HSMD_NODE_ANNOUNCEMENT_SIG_REQ:;
	case WIRE_HSMD_NODE_ANNOUNCEMENT_SIG_REPLY:;
	case WIRE_HSMD_SIGN_WITHDRAWAL:;
	case WIRE_HSMD_SIGN_WITHDRAWAL_REPLY:;
	case WIRE_HSMD_SIGN_INVOICE:;
	case WIRE_HSMD_SIGN_INVOICE_REPLY:;
	case WIRE_HSMD_ECDH_REQ:;
	case WIRE_HSMD_ECDH_RESP:;
	case WIRE_HSMD_CANNOUNCEMENT_SIG_REQ:;
	case WIRE_HSMD_CANNOUNCEMENT_SIG_REPLY:;
	case WIRE_HSMD_CUPDATE_SIG_REQ:;
	case WIRE_HSMD_CUPDATE_SIG_REPLY:;
	case WIRE_HSMD_SIGN_COMMITMENT_TX:;
	case WIRE_HSMD_SIGN_COMMITMENT_TX_REPLY:;
	case WIRE_HSMD_SIGN_DELAYED_PAYMENT_TO_US:;
	case WIRE_HSMD_SIGN_REMOTE_HTLC_TO_US:;
	case WIRE_HSMD_SIGN_PENALTY_TO_US:;
	case WIRE_HSMD_SIGN_LOCAL_HTLC_TX:;
	case WIRE_HSMD_SIGN_REMOTE_COMMITMENT_TX:;
	case WIRE_HSMD_SIGN_REMOTE_HTLC_TX:;
	case WIRE_HSMD_SIGN_MUTUAL_CLOSE_TX:;
	case WIRE_HSMD_SIGN_TX_REPLY:;
	case WIRE_HSMD_GET_PER_COMMITMENT_POINT:;
	case WIRE_HSMD_GET_PER_COMMITMENT_POINT_REPLY:;
	case WIRE_HSMD_DEV_MEMLEAK:;
	case WIRE_HSMD_DEV_MEMLEAK_REPLY:;
	case WIRE_HSMD_CHECK_FUTURE_SECRET:;
	case WIRE_HSMD_CHECK_FUTURE_SECRET_REPLY:;
	case WIRE_HSMD_SIGN_MESSAGE:;
	case WIRE_HSMD_SIGN_MESSAGE_REPLY:;
	case WIRE_HSMD_GET_OUTPUT_SCRIPTPUBKEY:;
	case WIRE_HSMD_GET_OUTPUT_SCRIPTPUBKEY_REPLY:;
	case WIRE_HSMD_SIGN_BOLT12:;
	case WIRE_HSMD_SIGN_BOLT12_REPLY:;
	      return true;
	}
	return false;
}





/* WIRE: HSMSTATUS_CLIENT_BAD_REQUEST */
/* Clients should not give a bad request but not the HSM's decision to crash. */
u8 *towire_hsmstatus_client_bad_request(const tal_t *ctx, const struct node_id *id, const wirestring *description, const u8 *msg)
{
	u16 len = tal_count(msg);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMSTATUS_CLIENT_BAD_REQUEST);
	towire_node_id(&p, id);
	towire_wirestring(&p, description);
	towire_u16(&p, len);
	towire_u8_array(&p, msg, len);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmstatus_client_bad_request(const tal_t *ctx, const void *p, struct node_id *id, wirestring **description, u8 **msg)
{
	u16 len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMSTATUS_CLIENT_BAD_REQUEST)
		return false;
 	fromwire_node_id(&cursor, &plen, id);
 	*description = fromwire_wirestring(ctx, &cursor, &plen);
 	len = fromwire_u16(&cursor, &plen);
 	// 2nd case msg
	*msg = len ? tal_arr(ctx, u8, len) : NULL;
	fromwire_u8_array(&cursor, &plen, *msg, len);
	return cursor != NULL;
}

/* WIRE: HSMD_INIT */
/* Start the HSM. */
u8 *towire_hsmd_init(const tal_t *ctx, const struct bip32_key_version *bip32_key_version, const struct chainparams *chainparams, const struct secret *hsm_encryption_key, const struct privkey *dev_force_privkey, const struct secret *dev_force_bip32_seed, const struct secrets *dev_force_channel_secrets, const struct sha256 *dev_force_channel_secrets_shaseed)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_INIT);
	towire_bip32_key_version(&p, bip32_key_version);
	towire_chainparams(&p, chainparams);
	if (!hsm_encryption_key)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_secret(&p, hsm_encryption_key);
	}
	if (!dev_force_privkey)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_privkey(&p, dev_force_privkey);
	}
	if (!dev_force_bip32_seed)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_secret(&p, dev_force_bip32_seed);
	}
	if (!dev_force_channel_secrets)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_secrets(&p, dev_force_channel_secrets);
	}
	if (!dev_force_channel_secrets_shaseed)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_sha256(&p, dev_force_channel_secrets_shaseed);
	}

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_init(const tal_t *ctx, const void *p, struct bip32_key_version *bip32_key_version, const struct chainparams **chainparams, struct secret **hsm_encryption_key, struct privkey **dev_force_privkey, struct secret **dev_force_bip32_seed, struct secrets **dev_force_channel_secrets, struct sha256 **dev_force_channel_secrets_shaseed)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_INIT)
		return false;
 	fromwire_bip32_key_version(&cursor, &plen, bip32_key_version);
 	fromwire_chainparams(&cursor, &plen, chainparams);
 	if (!fromwire_bool(&cursor, &plen))
		*hsm_encryption_key = NULL;
	else {
		*hsm_encryption_key = tal(ctx, struct secret);
		fromwire_secret(&cursor, &plen, *hsm_encryption_key);
	}
 	if (!fromwire_bool(&cursor, &plen))
		*dev_force_privkey = NULL;
	else {
		*dev_force_privkey = tal(ctx, struct privkey);
		fromwire_privkey(&cursor, &plen, *dev_force_privkey);
	}
 	if (!fromwire_bool(&cursor, &plen))
		*dev_force_bip32_seed = NULL;
	else {
		*dev_force_bip32_seed = tal(ctx, struct secret);
		fromwire_secret(&cursor, &plen, *dev_force_bip32_seed);
	}
 	if (!fromwire_bool(&cursor, &plen))
		*dev_force_channel_secrets = NULL;
	else {
		*dev_force_channel_secrets = tal(ctx, struct secrets);
		fromwire_secrets(&cursor, &plen, *dev_force_channel_secrets);
	}
 	if (!fromwire_bool(&cursor, &plen))
		*dev_force_channel_secrets_shaseed = NULL;
	else {
		*dev_force_channel_secrets_shaseed = tal(ctx, struct sha256);
		fromwire_sha256(&cursor, &plen, *dev_force_channel_secrets_shaseed);
	}
	return cursor != NULL;
}

/* WIRE: HSMD_INIT_REPLY */
u8 *towire_hsmd_init_reply(const tal_t *ctx, const struct node_id *node_id, const struct ext_key *bip32, const struct pubkey32 *bolt12)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_INIT_REPLY);
	towire_node_id(&p, node_id);
	towire_ext_key(&p, bip32);
	towire_pubkey32(&p, bolt12);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_init_reply(const void *p, struct node_id *node_id, struct ext_key *bip32, struct pubkey32 *bolt12)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_INIT_REPLY)
		return false;
 	fromwire_node_id(&cursor, &plen, node_id);
 	fromwire_ext_key(&cursor, &plen, bip32);
 	fromwire_pubkey32(&cursor, &plen, bolt12);
	return cursor != NULL;
}

/* WIRE: HSMD_CLIENT_HSMFD */
/* Get a new HSM FD */
u8 *towire_hsmd_client_hsmfd(const tal_t *ctx, const struct node_id *id, u64 dbid, u64 capabilities)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_CLIENT_HSMFD);
	/* Which identity to use for requests */
	towire_node_id(&p, id);
	/* Database id for this client */
	towire_u64(&p, dbid);
	towire_u64(&p, capabilities);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_client_hsmfd(const void *p, struct node_id *id, u64 *dbid, u64 *capabilities)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_CLIENT_HSMFD)
		return false;
 	/* Which identity to use for requests */
	fromwire_node_id(&cursor, &plen, id);
 	/* Database id for this client */
	*dbid = fromwire_u64(&cursor, &plen);
 	*capabilities = fromwire_u64(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: HSMD_CLIENT_HSMFD_REPLY */
/* No content */
u8 *towire_hsmd_client_hsmfd_reply(const tal_t *ctx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_CLIENT_HSMFD_REPLY);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_client_hsmfd_reply(const void *p)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_CLIENT_HSMFD_REPLY)
		return false;
	return cursor != NULL;
}

/* WIRE: HSMD_GET_CHANNEL_BASEPOINTS */
/* Get the basepoints and funding key for this specific channel. */
u8 *towire_hsmd_get_channel_basepoints(const tal_t *ctx, const struct node_id *peerid, u64 dbid)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_GET_CHANNEL_BASEPOINTS);
	towire_node_id(&p, peerid);
	towire_u64(&p, dbid);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_get_channel_basepoints(const void *p, struct node_id *peerid, u64 *dbid)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_GET_CHANNEL_BASEPOINTS)
		return false;
 	fromwire_node_id(&cursor, &plen, peerid);
 	*dbid = fromwire_u64(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: HSMD_GET_CHANNEL_BASEPOINTS_REPLY */
u8 *towire_hsmd_get_channel_basepoints_reply(const tal_t *ctx, const struct basepoints *basepoints, const struct pubkey *funding_pubkey)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_GET_CHANNEL_BASEPOINTS_REPLY);
	towire_basepoints(&p, basepoints);
	towire_pubkey(&p, funding_pubkey);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_get_channel_basepoints_reply(const void *p, struct basepoints *basepoints, struct pubkey *funding_pubkey)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_GET_CHANNEL_BASEPOINTS_REPLY)
		return false;
 	fromwire_basepoints(&cursor, &plen, basepoints);
 	fromwire_pubkey(&cursor, &plen, funding_pubkey);
	return cursor != NULL;
}

/* WIRE: HSMD_NODE_ANNOUNCEMENT_SIG_REQ */
/* Master asks the HSM to sign a node_announcement */
u8 *towire_hsmd_node_announcement_sig_req(const tal_t *ctx, const u8 *announcement)
{
	u16 annlen = tal_count(announcement);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_NODE_ANNOUNCEMENT_SIG_REQ);
	towire_u16(&p, annlen);
	towire_u8_array(&p, announcement, annlen);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_node_announcement_sig_req(const tal_t *ctx, const void *p, u8 **announcement)
{
	u16 annlen;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_NODE_ANNOUNCEMENT_SIG_REQ)
		return false;
 	annlen = fromwire_u16(&cursor, &plen);
 	// 2nd case announcement
	*announcement = annlen ? tal_arr(ctx, u8, annlen) : NULL;
	fromwire_u8_array(&cursor, &plen, *announcement, annlen);
	return cursor != NULL;
}

/* WIRE: HSMD_NODE_ANNOUNCEMENT_SIG_REPLY */
u8 *towire_hsmd_node_announcement_sig_reply(const tal_t *ctx, const secp256k1_ecdsa_signature *signature)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_NODE_ANNOUNCEMENT_SIG_REPLY);
	towire_secp256k1_ecdsa_signature(&p, signature);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_node_announcement_sig_reply(const void *p, secp256k1_ecdsa_signature *signature)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_NODE_ANNOUNCEMENT_SIG_REPLY)
		return false;
 	fromwire_secp256k1_ecdsa_signature(&cursor, &plen, signature);
	return cursor != NULL;
}

/* WIRE: HSMD_SIGN_WITHDRAWAL */
/* Sign a withdrawal request */
u8 *towire_hsmd_sign_withdrawal(const tal_t *ctx, const struct utxo **inputs, const struct wally_psbt *psbt)
{
	u16 num_inputs = tal_count(inputs);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_SIGN_WITHDRAWAL);
	towire_u16(&p, num_inputs);
	for (size_t i = 0; i < num_inputs; i++)
		towire_utxo(&p, inputs[i]);
	towire_wally_psbt(&p, psbt);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_sign_withdrawal(const tal_t *ctx, const void *p, struct utxo ***inputs, struct wally_psbt **psbt)
{
	u16 num_inputs;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_SIGN_WITHDRAWAL)
		return false;
 	num_inputs = fromwire_u16(&cursor, &plen);
 	// 2nd case inputs
	*inputs = num_inputs ? tal_arr(ctx, struct utxo *, num_inputs) : NULL;
	for (size_t i = 0; i < num_inputs; i++)
		(*inputs)[i] = fromwire_utxo(*inputs, &cursor, &plen);
 	*psbt = fromwire_wally_psbt(ctx, &cursor, &plen);
	return cursor != NULL;
}

/* WIRE: HSMD_SIGN_WITHDRAWAL_REPLY */
u8 *towire_hsmd_sign_withdrawal_reply(const tal_t *ctx, const struct wally_psbt *psbt)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_SIGN_WITHDRAWAL_REPLY);
	towire_wally_psbt(&p, psbt);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_sign_withdrawal_reply(const tal_t *ctx, const void *p, struct wally_psbt **psbt)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_SIGN_WITHDRAWAL_REPLY)
		return false;
 	*psbt = fromwire_wally_psbt(ctx, &cursor, &plen);
	return cursor != NULL;
}

/* WIRE: HSMD_SIGN_INVOICE */
/* Sign an invoice */
u8 *towire_hsmd_sign_invoice(const tal_t *ctx, const u8 *u5bytes, const u8 *hrp)
{
	u16 len = tal_count(u5bytes);
	u16 hrplen = tal_count(hrp);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_SIGN_INVOICE);
	towire_u16(&p, len);
	towire_u8_array(&p, u5bytes, len);
	towire_u16(&p, hrplen);
	towire_u8_array(&p, hrp, hrplen);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_sign_invoice(const tal_t *ctx, const void *p, u8 **u5bytes, u8 **hrp)
{
	u16 len;
	u16 hrplen;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_SIGN_INVOICE)
		return false;
 	len = fromwire_u16(&cursor, &plen);
 	// 2nd case u5bytes
	*u5bytes = len ? tal_arr(ctx, u8, len) : NULL;
	fromwire_u8_array(&cursor, &plen, *u5bytes, len);
 	hrplen = fromwire_u16(&cursor, &plen);
 	// 2nd case hrp
	*hrp = hrplen ? tal_arr(ctx, u8, hrplen) : NULL;
	fromwire_u8_array(&cursor, &plen, *hrp, hrplen);
	return cursor != NULL;
}

/* WIRE: HSMD_SIGN_INVOICE_REPLY */
u8 *towire_hsmd_sign_invoice_reply(const tal_t *ctx, const secp256k1_ecdsa_recoverable_signature *sig)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_SIGN_INVOICE_REPLY);
	towire_secp256k1_ecdsa_recoverable_signature(&p, sig);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_sign_invoice_reply(const void *p, secp256k1_ecdsa_recoverable_signature *sig)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_SIGN_INVOICE_REPLY)
		return false;
 	fromwire_secp256k1_ecdsa_recoverable_signature(&cursor, &plen, sig);
	return cursor != NULL;
}

/* WIRE: HSMD_ECDH_REQ */
/* Give me ECDH(node-id-secret */
u8 *towire_hsmd_ecdh_req(const tal_t *ctx, const struct pubkey *point)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_ECDH_REQ);
	towire_pubkey(&p, point);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_ecdh_req(const void *p, struct pubkey *point)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_ECDH_REQ)
		return false;
 	fromwire_pubkey(&cursor, &plen, point);
	return cursor != NULL;
}

/* WIRE: HSMD_ECDH_RESP */
u8 *towire_hsmd_ecdh_resp(const tal_t *ctx, const struct secret *ss)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_ECDH_RESP);
	towire_secret(&p, ss);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_ecdh_resp(const void *p, struct secret *ss)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_ECDH_RESP)
		return false;
 	fromwire_secret(&cursor, &plen, ss);
	return cursor != NULL;
}

/* WIRE: HSMD_CANNOUNCEMENT_SIG_REQ */
u8 *towire_hsmd_cannouncement_sig_req(const tal_t *ctx, const u8 *ca)
{
	u16 calen = tal_count(ca);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_CANNOUNCEMENT_SIG_REQ);
	towire_u16(&p, calen);
	towire_u8_array(&p, ca, calen);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_cannouncement_sig_req(const tal_t *ctx, const void *p, u8 **ca)
{
	u16 calen;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_CANNOUNCEMENT_SIG_REQ)
		return false;
 	calen = fromwire_u16(&cursor, &plen);
 	// 2nd case ca
	*ca = calen ? tal_arr(ctx, u8, calen) : NULL;
	fromwire_u8_array(&cursor, &plen, *ca, calen);
	return cursor != NULL;
}

/* WIRE: HSMD_CANNOUNCEMENT_SIG_REPLY */
u8 *towire_hsmd_cannouncement_sig_reply(const tal_t *ctx, const secp256k1_ecdsa_signature *node_signature, const secp256k1_ecdsa_signature *bitcoin_signature)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_CANNOUNCEMENT_SIG_REPLY);
	towire_secp256k1_ecdsa_signature(&p, node_signature);
	towire_secp256k1_ecdsa_signature(&p, bitcoin_signature);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_cannouncement_sig_reply(const void *p, secp256k1_ecdsa_signature *node_signature, secp256k1_ecdsa_signature *bitcoin_signature)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_CANNOUNCEMENT_SIG_REPLY)
		return false;
 	fromwire_secp256k1_ecdsa_signature(&cursor, &plen, node_signature);
 	fromwire_secp256k1_ecdsa_signature(&cursor, &plen, bitcoin_signature);
	return cursor != NULL;
}

/* WIRE: HSMD_CUPDATE_SIG_REQ */
u8 *towire_hsmd_cupdate_sig_req(const tal_t *ctx, const u8 *cu)
{
	u16 culen = tal_count(cu);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_CUPDATE_SIG_REQ);
	towire_u16(&p, culen);
	towire_u8_array(&p, cu, culen);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_cupdate_sig_req(const tal_t *ctx, const void *p, u8 **cu)
{
	u16 culen;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_CUPDATE_SIG_REQ)
		return false;
 	culen = fromwire_u16(&cursor, &plen);
 	// 2nd case cu
	*cu = culen ? tal_arr(ctx, u8, culen) : NULL;
	fromwire_u8_array(&cursor, &plen, *cu, culen);
	return cursor != NULL;
}

/* WIRE: HSMD_CUPDATE_SIG_REPLY */
u8 *towire_hsmd_cupdate_sig_reply(const tal_t *ctx, const u8 *cu)
{
	u16 culen = tal_count(cu);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_CUPDATE_SIG_REPLY);
	towire_u16(&p, culen);
	towire_u8_array(&p, cu, culen);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_cupdate_sig_reply(const tal_t *ctx, const void *p, u8 **cu)
{
	u16 culen;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_CUPDATE_SIG_REPLY)
		return false;
 	culen = fromwire_u16(&cursor, &plen);
 	// 2nd case cu
	*cu = culen ? tal_arr(ctx, u8, culen) : NULL;
	fromwire_u8_array(&cursor, &plen, *cu, culen);
	return cursor != NULL;
}

/* WIRE: HSMD_SIGN_COMMITMENT_TX */
/* Master asks HSM to sign a commitment transaction. */
u8 *towire_hsmd_sign_commitment_tx(const tal_t *ctx, const struct node_id *peer_id, u64 channel_dbid, const struct bitcoin_tx *tx, const struct pubkey *remote_funding_key)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_SIGN_COMMITMENT_TX);
	towire_node_id(&p, peer_id);
	towire_u64(&p, channel_dbid);
	towire_bitcoin_tx(&p, tx);
	towire_pubkey(&p, remote_funding_key);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_sign_commitment_tx(const tal_t *ctx, const void *p, struct node_id *peer_id, u64 *channel_dbid, struct bitcoin_tx **tx, struct pubkey *remote_funding_key)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_SIGN_COMMITMENT_TX)
		return false;
 	fromwire_node_id(&cursor, &plen, peer_id);
 	*channel_dbid = fromwire_u64(&cursor, &plen);
 	*tx = fromwire_bitcoin_tx(ctx, &cursor, &plen);
 	fromwire_pubkey(&cursor, &plen, remote_funding_key);
	return cursor != NULL;
}

/* WIRE: HSMD_SIGN_COMMITMENT_TX_REPLY */
u8 *towire_hsmd_sign_commitment_tx_reply(const tal_t *ctx, const struct bitcoin_signature *sig)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_SIGN_COMMITMENT_TX_REPLY);
	towire_bitcoin_signature(&p, sig);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_sign_commitment_tx_reply(const void *p, struct bitcoin_signature *sig)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_SIGN_COMMITMENT_TX_REPLY)
		return false;
 	fromwire_bitcoin_signature(&cursor, &plen, sig);
	return cursor != NULL;
}

/* WIRE: HSMD_SIGN_DELAYED_PAYMENT_TO_US */
/* Onchaind asks HSM to sign a spend to-us.  Four variants */
/* of keys is derived differently... */
/* FIXME: Have master tell hsmd the keyindex */
u8 *towire_hsmd_sign_delayed_payment_to_us(const tal_t *ctx, u64 commit_num, const struct bitcoin_tx *tx, const u8 *wscript)
{
	u16 wscript_len = tal_count(wscript);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_SIGN_DELAYED_PAYMENT_TO_US);
	towire_u64(&p, commit_num);
	towire_bitcoin_tx(&p, tx);
	towire_u16(&p, wscript_len);
	towire_u8_array(&p, wscript, wscript_len);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_sign_delayed_payment_to_us(const tal_t *ctx, const void *p, u64 *commit_num, struct bitcoin_tx **tx, u8 **wscript)
{
	u16 wscript_len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_SIGN_DELAYED_PAYMENT_TO_US)
		return false;
 	*commit_num = fromwire_u64(&cursor, &plen);
 	*tx = fromwire_bitcoin_tx(ctx, &cursor, &plen);
 	wscript_len = fromwire_u16(&cursor, &plen);
 	// 2nd case wscript
	*wscript = wscript_len ? tal_arr(ctx, u8, wscript_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *wscript, wscript_len);
	return cursor != NULL;
}

/* WIRE: HSMD_SIGN_REMOTE_HTLC_TO_US */
u8 *towire_hsmd_sign_remote_htlc_to_us(const tal_t *ctx, const struct pubkey *remote_per_commitment_point, const struct bitcoin_tx *tx, const u8 *wscript, bool option_anchor_outputs)
{
	u16 wscript_len = tal_count(wscript);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_SIGN_REMOTE_HTLC_TO_US);
	towire_pubkey(&p, remote_per_commitment_point);
	towire_bitcoin_tx(&p, tx);
	towire_u16(&p, wscript_len);
	towire_u8_array(&p, wscript, wscript_len);
	towire_bool(&p, option_anchor_outputs);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_sign_remote_htlc_to_us(const tal_t *ctx, const void *p, struct pubkey *remote_per_commitment_point, struct bitcoin_tx **tx, u8 **wscript, bool *option_anchor_outputs)
{
	u16 wscript_len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_SIGN_REMOTE_HTLC_TO_US)
		return false;
 	fromwire_pubkey(&cursor, &plen, remote_per_commitment_point);
 	*tx = fromwire_bitcoin_tx(ctx, &cursor, &plen);
 	wscript_len = fromwire_u16(&cursor, &plen);
 	// 2nd case wscript
	*wscript = wscript_len ? tal_arr(ctx, u8, wscript_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *wscript, wscript_len);
 	*option_anchor_outputs = fromwire_bool(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: HSMD_SIGN_PENALTY_TO_US */
u8 *towire_hsmd_sign_penalty_to_us(const tal_t *ctx, const struct secret *revocation_secret, const struct bitcoin_tx *tx, const u8 *wscript)
{
	u16 wscript_len = tal_count(wscript);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_SIGN_PENALTY_TO_US);
	towire_secret(&p, revocation_secret);
	towire_bitcoin_tx(&p, tx);
	towire_u16(&p, wscript_len);
	towire_u8_array(&p, wscript, wscript_len);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_sign_penalty_to_us(const tal_t *ctx, const void *p, struct secret *revocation_secret, struct bitcoin_tx **tx, u8 **wscript)
{
	u16 wscript_len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_SIGN_PENALTY_TO_US)
		return false;
 	fromwire_secret(&cursor, &plen, revocation_secret);
 	*tx = fromwire_bitcoin_tx(ctx, &cursor, &plen);
 	wscript_len = fromwire_u16(&cursor, &plen);
 	// 2nd case wscript
	*wscript = wscript_len ? tal_arr(ctx, u8, wscript_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *wscript, wscript_len);
	return cursor != NULL;
}

/* WIRE: HSMD_SIGN_LOCAL_HTLC_TX */
/* Onchaind asks HSM to sign a local HTLC success or HTLC timeout tx. */
u8 *towire_hsmd_sign_local_htlc_tx(const tal_t *ctx, u64 commit_num, const struct bitcoin_tx *tx, const u8 *wscript, bool option_anchor_outputs)
{
	u16 wscript_len = tal_count(wscript);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_SIGN_LOCAL_HTLC_TX);
	towire_u64(&p, commit_num);
	towire_bitcoin_tx(&p, tx);
	towire_u16(&p, wscript_len);
	towire_u8_array(&p, wscript, wscript_len);
	towire_bool(&p, option_anchor_outputs);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_sign_local_htlc_tx(const tal_t *ctx, const void *p, u64 *commit_num, struct bitcoin_tx **tx, u8 **wscript, bool *option_anchor_outputs)
{
	u16 wscript_len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_SIGN_LOCAL_HTLC_TX)
		return false;
 	*commit_num = fromwire_u64(&cursor, &plen);
 	*tx = fromwire_bitcoin_tx(ctx, &cursor, &plen);
 	wscript_len = fromwire_u16(&cursor, &plen);
 	// 2nd case wscript
	*wscript = wscript_len ? tal_arr(ctx, u8, wscript_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *wscript, wscript_len);
 	*option_anchor_outputs = fromwire_bool(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: HSMD_SIGN_REMOTE_COMMITMENT_TX */
/* Openingd/channeld asks HSM to sign the other sides' commitment tx. */
u8 *towire_hsmd_sign_remote_commitment_tx(const tal_t *ctx, const struct bitcoin_tx *tx, const struct pubkey *remote_funding_key, const struct pubkey *remote_per_commit, bool option_static_remotekey)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_SIGN_REMOTE_COMMITMENT_TX);
	towire_bitcoin_tx(&p, tx);
	towire_pubkey(&p, remote_funding_key);
	towire_pubkey(&p, remote_per_commit);
	towire_bool(&p, option_static_remotekey);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_sign_remote_commitment_tx(const tal_t *ctx, const void *p, struct bitcoin_tx **tx, struct pubkey *remote_funding_key, struct pubkey *remote_per_commit, bool *option_static_remotekey)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_SIGN_REMOTE_COMMITMENT_TX)
		return false;
 	*tx = fromwire_bitcoin_tx(ctx, &cursor, &plen);
 	fromwire_pubkey(&cursor, &plen, remote_funding_key);
 	fromwire_pubkey(&cursor, &plen, remote_per_commit);
 	*option_static_remotekey = fromwire_bool(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: HSMD_SIGN_REMOTE_HTLC_TX */
/* channeld asks HSM to sign remote HTLC tx. */
u8 *towire_hsmd_sign_remote_htlc_tx(const tal_t *ctx, const struct bitcoin_tx *tx, const u8 *wscript, const struct pubkey *remote_per_commit_point, bool option_anchor_outputs)
{
	u16 len = tal_count(wscript);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_SIGN_REMOTE_HTLC_TX);
	towire_bitcoin_tx(&p, tx);
	towire_u16(&p, len);
	towire_u8_array(&p, wscript, len);
	towire_pubkey(&p, remote_per_commit_point);
	towire_bool(&p, option_anchor_outputs);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_sign_remote_htlc_tx(const tal_t *ctx, const void *p, struct bitcoin_tx **tx, u8 **wscript, struct pubkey *remote_per_commit_point, bool *option_anchor_outputs)
{
	u16 len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_SIGN_REMOTE_HTLC_TX)
		return false;
 	*tx = fromwire_bitcoin_tx(ctx, &cursor, &plen);
 	len = fromwire_u16(&cursor, &plen);
 	// 2nd case wscript
	*wscript = len ? tal_arr(ctx, u8, len) : NULL;
	fromwire_u8_array(&cursor, &plen, *wscript, len);
 	fromwire_pubkey(&cursor, &plen, remote_per_commit_point);
 	*option_anchor_outputs = fromwire_bool(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: HSMD_SIGN_MUTUAL_CLOSE_TX */
/* closingd asks HSM to sign mutual close tx. */
u8 *towire_hsmd_sign_mutual_close_tx(const tal_t *ctx, const struct bitcoin_tx *tx, const struct pubkey *remote_funding_key)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_SIGN_MUTUAL_CLOSE_TX);
	towire_bitcoin_tx(&p, tx);
	towire_pubkey(&p, remote_funding_key);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_sign_mutual_close_tx(const tal_t *ctx, const void *p, struct bitcoin_tx **tx, struct pubkey *remote_funding_key)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_SIGN_MUTUAL_CLOSE_TX)
		return false;
 	*tx = fromwire_bitcoin_tx(ctx, &cursor, &plen);
 	fromwire_pubkey(&cursor, &plen, remote_funding_key);
	return cursor != NULL;
}

/* WIRE: HSMD_SIGN_TX_REPLY */
/* Reply for all the above requests. */
u8 *towire_hsmd_sign_tx_reply(const tal_t *ctx, const struct bitcoin_signature *sig)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_SIGN_TX_REPLY);
	towire_bitcoin_signature(&p, sig);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_sign_tx_reply(const void *p, struct bitcoin_signature *sig)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_SIGN_TX_REPLY)
		return false;
 	fromwire_bitcoin_signature(&cursor, &plen, sig);
	return cursor != NULL;
}

/* WIRE: HSMD_GET_PER_COMMITMENT_POINT */
/* Openingd/channeld/onchaind asks for Nth per_commitment_point */
u8 *towire_hsmd_get_per_commitment_point(const tal_t *ctx, u64 n)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_GET_PER_COMMITMENT_POINT);
	towire_u64(&p, n);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_get_per_commitment_point(const void *p, u64 *n)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_GET_PER_COMMITMENT_POINT)
		return false;
 	*n = fromwire_u64(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: HSMD_GET_PER_COMMITMENT_POINT_REPLY */
u8 *towire_hsmd_get_per_commitment_point_reply(const tal_t *ctx, const struct pubkey *per_commitment_point, const struct secret *old_commitment_secret)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_GET_PER_COMMITMENT_POINT_REPLY);
	towire_pubkey(&p, per_commitment_point);
	if (!old_commitment_secret)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_secret(&p, old_commitment_secret);
	}

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_get_per_commitment_point_reply(const tal_t *ctx, const void *p, struct pubkey *per_commitment_point, struct secret **old_commitment_secret)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_GET_PER_COMMITMENT_POINT_REPLY)
		return false;
 	fromwire_pubkey(&cursor, &plen, per_commitment_point);
 	if (!fromwire_bool(&cursor, &plen))
		*old_commitment_secret = NULL;
	else {
		*old_commitment_secret = tal(ctx, struct secret);
		fromwire_secret(&cursor, &plen, *old_commitment_secret);
	}
	return cursor != NULL;
}

/* WIRE: HSMD_DEV_MEMLEAK */
/* master -> hsmd: do you have a memleak? */
u8 *towire_hsmd_dev_memleak(const tal_t *ctx)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_DEV_MEMLEAK);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_dev_memleak(const void *p)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_DEV_MEMLEAK)
		return false;
	return cursor != NULL;
}

/* WIRE: HSMD_DEV_MEMLEAK_REPLY */
u8 *towire_hsmd_dev_memleak_reply(const tal_t *ctx, bool leak)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_DEV_MEMLEAK_REPLY);
	towire_bool(&p, leak);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_dev_memleak_reply(const void *p, bool *leak)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_DEV_MEMLEAK_REPLY)
		return false;
 	*leak = fromwire_bool(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: HSMD_CHECK_FUTURE_SECRET */
/* channeld asks to check if claimed future commitment_secret is correct. */
u8 *towire_hsmd_check_future_secret(const tal_t *ctx, u64 n, const struct secret *commitment_secret)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_CHECK_FUTURE_SECRET);
	towire_u64(&p, n);
	towire_secret(&p, commitment_secret);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_check_future_secret(const void *p, u64 *n, struct secret *commitment_secret)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_CHECK_FUTURE_SECRET)
		return false;
 	*n = fromwire_u64(&cursor, &plen);
 	fromwire_secret(&cursor, &plen, commitment_secret);
	return cursor != NULL;
}

/* WIRE: HSMD_CHECK_FUTURE_SECRET_REPLY */
u8 *towire_hsmd_check_future_secret_reply(const tal_t *ctx, bool correct)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_CHECK_FUTURE_SECRET_REPLY);
	towire_bool(&p, correct);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_check_future_secret_reply(const void *p, bool *correct)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_CHECK_FUTURE_SECRET_REPLY)
		return false;
 	*correct = fromwire_bool(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: HSMD_SIGN_MESSAGE */
/* lightningd asks us to sign a string. */
u8 *towire_hsmd_sign_message(const tal_t *ctx, const u8 *msg)
{
	u16 len = tal_count(msg);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_SIGN_MESSAGE);
	towire_u16(&p, len);
	towire_u8_array(&p, msg, len);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_sign_message(const tal_t *ctx, const void *p, u8 **msg)
{
	u16 len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_SIGN_MESSAGE)
		return false;
 	len = fromwire_u16(&cursor, &plen);
 	// 2nd case msg
	*msg = len ? tal_arr(ctx, u8, len) : NULL;
	fromwire_u8_array(&cursor, &plen, *msg, len);
	return cursor != NULL;
}

/* WIRE: HSMD_SIGN_MESSAGE_REPLY */
u8 *towire_hsmd_sign_message_reply(const tal_t *ctx, const secp256k1_ecdsa_recoverable_signature *sig)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_SIGN_MESSAGE_REPLY);
	towire_secp256k1_ecdsa_recoverable_signature(&p, sig);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_sign_message_reply(const void *p, secp256k1_ecdsa_recoverable_signature *sig)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_SIGN_MESSAGE_REPLY)
		return false;
 	fromwire_secp256k1_ecdsa_recoverable_signature(&cursor, &plen, sig);
	return cursor != NULL;
}

/* WIRE: HSMD_GET_OUTPUT_SCRIPTPUBKEY */
/* lightningd needs to get a scriptPubkey for a utxo with closeinfo */
u8 *towire_hsmd_get_output_scriptpubkey(const tal_t *ctx, u64 channel_id, const struct node_id *peer_id, const struct pubkey *commitment_point)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_GET_OUTPUT_SCRIPTPUBKEY);
	towire_u64(&p, channel_id);
	towire_node_id(&p, peer_id);
	if (!commitment_point)
		towire_bool(&p, false);
	else {
		towire_bool(&p, true);
		towire_pubkey(&p, commitment_point);
	}

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_get_output_scriptpubkey(const tal_t *ctx, const void *p, u64 *channel_id, struct node_id *peer_id, struct pubkey **commitment_point)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_GET_OUTPUT_SCRIPTPUBKEY)
		return false;
 	*channel_id = fromwire_u64(&cursor, &plen);
 	fromwire_node_id(&cursor, &plen, peer_id);
 	if (!fromwire_bool(&cursor, &plen))
		*commitment_point = NULL;
	else {
		*commitment_point = tal(ctx, struct pubkey);
		fromwire_pubkey(&cursor, &plen, *commitment_point);
	}
	return cursor != NULL;
}

/* WIRE: HSMD_GET_OUTPUT_SCRIPTPUBKEY_REPLY */
u8 *towire_hsmd_get_output_scriptpubkey_reply(const tal_t *ctx, const u8 *script)
{
	u16 script_len = tal_count(script);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_GET_OUTPUT_SCRIPTPUBKEY_REPLY);
	towire_u16(&p, script_len);
	towire_u8_array(&p, script, script_len);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_get_output_scriptpubkey_reply(const tal_t *ctx, const void *p, u8 **script)
{
	u16 script_len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_GET_OUTPUT_SCRIPTPUBKEY_REPLY)
		return false;
 	script_len = fromwire_u16(&cursor, &plen);
 	// 2nd case script
	*script = script_len ? tal_arr(ctx, u8, script_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *script, script_len);
	return cursor != NULL;
}

/* WIRE: HSMD_SIGN_BOLT12 */
/* Sign a bolt12-style merkle hash */
u8 *towire_hsmd_sign_bolt12(const tal_t *ctx, const wirestring *messagename, const wirestring *fieldname, const struct sha256 *merkleroot, const u8 *publictweak)
{
	u16 publictweaklen = tal_count(publictweak);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_SIGN_BOLT12);
	towire_wirestring(&p, messagename);
	towire_wirestring(&p, fieldname);
	towire_sha256(&p, merkleroot);
	/* This is for invreq payer_id (temporary keys) */
	towire_u16(&p, publictweaklen);
	towire_u8_array(&p, publictweak, publictweaklen);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_sign_bolt12(const tal_t *ctx, const void *p, wirestring **messagename, wirestring **fieldname, struct sha256 *merkleroot, u8 **publictweak)
{
	u16 publictweaklen;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_SIGN_BOLT12)
		return false;
 	*messagename = fromwire_wirestring(ctx, &cursor, &plen);
 	*fieldname = fromwire_wirestring(ctx, &cursor, &plen);
 	fromwire_sha256(&cursor, &plen, merkleroot);
 	/* This is for invreq payer_id (temporary keys) */
	publictweaklen = fromwire_u16(&cursor, &plen);
 	// 2nd case publictweak
	*publictweak = publictweaklen ? tal_arr(ctx, u8, publictweaklen) : NULL;
	fromwire_u8_array(&cursor, &plen, *publictweak, publictweaklen);
	return cursor != NULL;
}

/* WIRE: HSMD_SIGN_BOLT12_REPLY */
u8 *towire_hsmd_sign_bolt12_reply(const tal_t *ctx, const struct bip340sig *sig)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_HSMD_SIGN_BOLT12_REPLY);
	towire_bip340sig(&p, sig);

	return memcheck(p, tal_count(p));
}
bool fromwire_hsmd_sign_bolt12_reply(const void *p, struct bip340sig *sig)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_HSMD_SIGN_BOLT12_REPLY)
		return false;
 	fromwire_bip340sig(&cursor, &plen, sig);
	return cursor != NULL;
}
// SHA256STAMP:535c69a065c06a2e2ea151154ae83b53283d1c5b34e18b43a2c12c9444472548
