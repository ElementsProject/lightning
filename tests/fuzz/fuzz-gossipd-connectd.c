#include "config.h"
#include <fcntl.h>
#include <stdio.h>
#include <common/decode_array.h>
#include <ccan/ccan/mem/mem.h>
#include <ccan/ccan/intmap/intmap.h>
#include <common/setup.h>
#include <common/utils.h>
#include <common/json_parse.h>
#include <tests/fuzz/libfuzz.h>

#define main gossipd_main
int main(int argc, char *argv[]);
#include "../../gossipd/seeker.c"
#include "../../gossipd/gossmap_manage.c"
#include "../../gossipd/gossipd.c"
#undef main

/* AUTOGENERATED MOCKS START */
/* Generated stub for ecdh_hsmd_setup */
void ecdh_hsmd_setup(int hsm_fd UNNEEDED,
		     void (*failed)(enum status_failreason UNNEEDED,
				    const char *fmt UNNEEDED, ...))
{ fprintf(stderr, "ecdh_hsmd_setup called!\n"); abort(); }
/* Generated stub for json_get_member */
const jsmntok_t *json_get_member(const char *buffer UNNEEDED, const jsmntok_t tok[] UNNEEDED,
				 const char *label UNNEEDED)
{ fprintf(stderr, "json_get_member called!\n"); abort(); }
/* Generated stub for json_next */
const jsmntok_t *json_next(const jsmntok_t *tok UNNEEDED)
{ fprintf(stderr, "json_next called!\n"); abort(); }
/* Generated stub for json_scan */
const char *json_scan(const tal_t *ctx UNNEEDED,
		      const char *buffer UNNEEDED,
		      const jsmntok_t *tok UNNEEDED,
		      const char *guide UNNEEDED,
		      ...)
{ fprintf(stderr, "json_scan called!\n"); abort(); }
/* Generated stub for json_strdup */
char *json_strdup(const tal_t *ctx UNNEEDED, const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED)
{ fprintf(stderr, "json_strdup called!\n"); abort(); }
/* Generated stub for json_to_bool */
bool json_to_bool(const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED, bool *b UNNEEDED)
{ fprintf(stderr, "json_to_bool called!\n"); abort(); }
/* Generated stub for json_to_int */
bool json_to_int(const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED, int *num UNNEEDED)
{ fprintf(stderr, "json_to_int called!\n"); abort(); }
/* Generated stub for json_to_msat */
bool json_to_msat(const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED,
		  struct amount_msat *msat UNNEEDED)
{ fprintf(stderr, "json_to_msat called!\n"); abort(); }
/* Generated stub for json_to_node_id */
bool json_to_node_id(const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED,
			       struct node_id *id UNNEEDED)
{ fprintf(stderr, "json_to_node_id called!\n"); abort(); }
/* Generated stub for json_to_short_channel_id */
bool json_to_short_channel_id(const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED,
			      struct short_channel_id *scid UNNEEDED)
{ fprintf(stderr, "json_to_short_channel_id called!\n"); abort(); }
/* Generated stub for json_to_u32 */
bool json_to_u32(const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED, u32 *num UNNEEDED)
{ fprintf(stderr, "json_to_u32 called!\n"); abort(); }
/* Generated stub for pseudorand_u64 */
uint64_t pseudorand_u64(void)
{ fprintf(stderr, "pseudorand_u64 called!\n"); abort(); }
/* Generated stub for subdaemon_setup */
bool subdaemon_setup(int argc UNNEEDED, char *argv[])
{ fprintf(stderr, "subdaemon_setup called!\n"); abort(); }
/* AUTOGENERATED MOCKS END */

static int connectd_fd;
static struct privkey funding_pkey;

const struct siphash_seed *siphash_seed(void)
{
	struct siphash_seed *siphashseed = tal(tmpctx, struct siphash_seed);
	memset(siphashseed->u.u8, 1, sizeof(siphashseed->u.u8));
	return siphashseed;
}

static struct daemon *new_daemon(const tal_t *ctx, const u8 **cursor, size_t *max)
{
	struct daemon *daemon;
	u32 *dev_gossip_time;

	daemon = talz(ctx, struct daemon);

	daemon->peers = talz(daemon, struct peer_node_id_map);
	daemon->deferred_txouts = tal_arrz(ctx, struct short_channel_id, 0);

	peer_node_id_map_init(daemon->peers);
	timers_init(&daemon->timers, time_mono());

	daemon->current_blockheight = 0;
	daemon->dev_gossip_time = NULL;
	daemon->master = NULL;

	size_t len = fromwire_u16(cursor, max);
	if (len > *max)
		len = *max;

	u8 *msg = tal_dup_arr(ctx, u8, *cursor, len, 0);
	if (*max)
		*cursor += len, *max -= len;

	const struct chainparams *chprms;
	if (!fromwire_gossipd_init(ctx, msg,
				     &chprms,
				     &daemon->our_features,
				     &daemon->id,
				     &dev_gossip_time,
				     &daemon->dev_fast_gossip,
				     &daemon->dev_fast_gossip_prune,
				     &daemon->autoconnect_seeker_peers))
		return NULL;

	/* Too many seekers can cause out of memory errors */
	daemon->autoconnect_seeker_peers %= 1001;

	/* Set developer options to false. */
	daemon->developer = false;
	daemon->dev_gossip_time = NULL;
	daemon->dev_fast_gossip = NULL;
	daemon->dev_fast_gossip_prune = NULL;

	daemon->gm = gossmap_manage_new(ctx, daemon);
	daemon->seeker = new_seeker(daemon);
	daemon->connectd = daemon_conn_new(ctx, connectd_fd, NULL, NULL, daemon);

	return daemon;
}

static struct privkey privkey_from_index(size_t index)
{
	struct privkey pkey;
	memset(&pkey, 0, sizeof(pkey));
	/* Set first 8 bytes to index bytes */
	pkey.secret.data[0] = (index >> 56) & 0xFF;
	pkey.secret.data[1] = (index >> 48) & 0xFF;
	pkey.secret.data[2] = (index >> 40) & 0xFF;
	pkey.secret.data[3] = (index >> 32) & 0xFF;
	pkey.secret.data[4] = (index >> 24) & 0xFF;
	pkey.secret.data[5] = (index >> 16) & 0xFF;
	pkey.secret.data[6] = (index >> 8) & 0xFF;
	pkey.secret.data[7] = index & 0xFF;

    /* Ensure key is not all zeros */
    if (memeqzero(pkey.secret.data, PRIVKEY_LEN))
        pkey.secret.data[31] = 1;

    return pkey;
}

static struct node_id node_id(struct privkey pkey)
{
	struct pubkey k;
	struct node_id id;
	pubkey_from_privkey(&pkey, &k);
	node_id_from_pubkey(&id, &k);
	return id;
}

#define MAX_NODES 1000000
#define MAX_PEERS 1000

#define MAX_FEE_BASE_MSAT 100000UL    /* Max base fee in msat (10k sat) */
#define MAX_DELAY 144UL                /* Max CLTV delay for a channel policy */
#define MAX_PROP_FEE_MILLIONTHS 100000UL /* Max proportional fee (10%) */
#define MAX_CAPACITY_SAT 100000000UL    /* Max channel capacity in satoshis (1 BTC) */
#define MAX_MSAT (MAX_CAPACITY_SAT * 1000UL) /* Max msat value for HTLCs or payments */

struct channel_info {
    struct short_channel_id_dir scidd;
    size_t from_idx, to_idx;
};

/* Arrays to store gossip information. */
struct node_id *peer_ids;
struct node_id *node_ids;
struct channel_info *channels;

static u8 *create_gossip_msg(const tal_t *ctx, const u8 **cursor, size_t *max)
{
	u8 *gossip_msg = tal_arr(ctx, u8, 0);
	int op = fromwire_u8(cursor, max) % 5;
	switch (op)
	{
		case 0: /* WIRE_CHANNEL_ANNOUNCEMENT */
		{
			secp256k1_ecdsa_signature dummy_sig;
			struct pubkey funding_pubkey;
			struct privkey from_pkey, to_pkey;
			struct node_id from_id, to_id;
			size_t from_idx, to_idx;
			static struct short_channel_id_dir scidd;

			memset(&dummy_sig, 0, sizeof(dummy_sig));
			pubkey_from_privkey(&funding_pkey, &funding_pubkey);

			from_idx = tal_count(node_ids);
			from_pkey = privkey_from_index(from_idx);
			from_id = node_id(from_pkey);
			tal_arr_expand(&node_ids, from_id);

			to_idx = tal_count(node_ids);
			to_pkey = privkey_from_index(to_idx);
			to_id = node_id(to_pkey);
			tal_arr_expand(&node_ids, to_id);

			if (node_id_cmp(&from_id, &to_id) > 0) {
				scidd.dir = 1;
				struct node_id tmp_id = from_id;
				from_id = to_id;
				to_id = tmp_id;
			} else
				scidd.dir = 0;
			scidd.scid.u64++;

			struct channel_info new_channel_info = {.scidd = scidd,
								.from_idx = from_idx,
								.to_idx = to_idx};

			tal_arr_expand(&channels, new_channel_info);

			u8 *cannounce = towire_channel_announcement(ctx,
								&dummy_sig, &dummy_sig,
								&dummy_sig, &dummy_sig,
								NULL,
								&chainparams->genesis_blockhash,
								scidd.scid,
								&from_id, &to_id,
								&funding_pubkey,
								&funding_pubkey);

			/* Sign the message. */
			struct sha256_double hash;
			u8 compact_sig[64];
			size_t offset = 2 + 4 * sizeof(compact_sig);
			if (tal_count(cannounce) < offset)
				assert(false && "Channel announce too short!");
			sha256_double(&hash, cannounce + offset, tal_count(cannounce) - offset);

			secp256k1_ecdsa_signature node_sig1, node_sig2, bitcoin_sig1, bitcoin_sig2;
			sign_hash(&from_pkey, &hash, &node_sig1);
			sign_hash(&funding_pkey, &hash, &bitcoin_sig1);
			sign_hash(&to_pkey, &hash, &node_sig2);
			sign_hash(&funding_pkey, &hash, &bitcoin_sig2);

			secp256k1_ecdsa_signature_serialize_compact(secp256k1_ctx, compact_sig, &node_sig1);
			memcpy(cannounce + 2, compact_sig, 64);

			secp256k1_ecdsa_signature_serialize_compact(secp256k1_ctx, compact_sig, &node_sig2);
			memcpy(cannounce + 66, compact_sig, 64);

			secp256k1_ecdsa_signature_serialize_compact(secp256k1_ctx, compact_sig, &bitcoin_sig1);
			memcpy(cannounce + 130, compact_sig, 64);

			secp256k1_ecdsa_signature_serialize_compact(secp256k1_ctx, compact_sig, &bitcoin_sig2);
			memcpy(cannounce + 194, compact_sig, 64);

			gossip_msg = cannounce;
			break;
		}
		case 1: /* WIRE_CHANNEL_UPDATE */
		{
			/*Need atleast one channel. */
			if (tal_count(channels) < 1)
				return NULL;

			struct channel_info *channel_to_update;
			secp256k1_ecdsa_signature dummy_sig;
			u32 timestamp;
			u8 channel_flags;
			u16 cltv_expiry_delta;
			u32 fee_base_msat, fee_proportional_millionths;
			struct privkey node_pkey;
			struct amount_msat htlc_max_msat, htlc_min_msat;

			memset(&dummy_sig, 0, sizeof(dummy_sig));
			channel_to_update = &channels[fromwire_u64(cursor, max) % tal_count(channels)];
			if (fromwire_u8(cursor, max) % 2) {
				node_pkey = privkey_from_index(channel_to_update->from_idx);
				channel_flags = 0;
			} else {
				node_pkey = privkey_from_index(channel_to_update->to_idx);
				channel_flags = 1;
			}

			/* Choose between a valid timestamp and a random one. */
			if (fromwire_u8(cursor, max) % 2)
				timestamp = fromwire_u32(cursor, max);
			else
				timestamp = time_now().ts.tv_sec - fromwire_s16(cursor, max);
			cltv_expiry_delta = fromwire_u32(cursor, max) % (MAX_DELAY + 1);

			fee_base_msat = fromwire_u32(cursor, max) % (MAX_FEE_BASE_MSAT + 1);
			fee_proportional_millionths = fromwire_s32(cursor, max);

			if (fee_proportional_millionths < 0) /* Ensure non-negative  */
				fee_proportional_millionths = 0;
			fee_proportional_millionths %= (MAX_PROP_FEE_MILLIONTHS + 1);

			/* Ensure that min_msat <= max_msat holds. */
			htlc_min_msat = fromwire_amount_msat(cursor, max);
			htlc_min_msat.millisatoshis %= (MAX_MSAT + 1);

			htlc_max_msat = fromwire_amount_msat(cursor, max);
			htlc_max_msat.millisatoshis %= (MAX_MSAT + 1);

			if (amount_msat_greater(htlc_min_msat, htlc_max_msat)) {
				struct amount_msat temp = htlc_min_msat;
				htlc_min_msat = htlc_max_msat;
				htlc_max_msat = temp;
			}

			u8 *cupdate = towire_channel_update(ctx,
							&dummy_sig,
							&chainparams->genesis_blockhash,
							channel_to_update->scidd.scid,
							timestamp,
							ROUTING_OPT_HTLC_MAX_MSAT,
							channel_flags,
							cltv_expiry_delta,
							htlc_min_msat,
							fee_base_msat,
							fee_proportional_millionths,
							htlc_max_msat);

			/* Sign the update. */
			struct sha256_double hash;
			secp256k1_ecdsa_signature sig;
			u8 compact_sig[64];

			if (tal_count(cupdate) < sizeof(compact_sig))
				assert(false && "Channel update too short.");

			sha256_double(&hash, cupdate + sizeof(compact_sig),
					tal_count(cupdate) - sizeof(compact_sig));
			sign_hash(&node_pkey, &hash, &sig);
			secp256k1_ecdsa_signature_serialize_compact(secp256k1_ctx,
								compact_sig,
								&sig);
			memcpy(cupdate + 2, compact_sig, sizeof(compact_sig));

			gossip_msg = cupdate;
			break;
		}
		case 2: /* WIRE_NODE_ANNOUNCEMENT */
		{
			/* Need atleast one node to announce. */
			if (tal_count(node_ids) < 1)
				return NULL;

			secp256k1_ecdsa_signature sig;
			u32 timestamp;
			u8 alias[32];
			u8 *addresses = tal_arr(ctx, u8, 0);
			struct privkey node_pkey;
			size_t node_idx;
			struct wireaddr waddr;
			struct sha256_double hash;
			struct tlv_node_ann_tlvs *tlvs;

			timestamp = fromwire_u32(cursor, max);
			fromwire_u8_array(cursor, max, alias, sizeof(alias));
			tlvs = tlv_node_ann_tlvs_new(ctx);

			node_idx = fromwire_u64(cursor, max) % tal_count(node_ids);
			struct node_id *node_to_ann = &node_ids[node_idx];
			node_pkey = privkey_from_index(node_idx);

			/* Create an address */
			waddr.type = ADDR_TYPE_IPV4;
			waddr.addrlen = 4;
			fromwire_u8_array(cursor, max, waddr.addr, waddr.addrlen);
			waddr.port = fromwire_u16(cursor, max);
			towire_wireaddr(&addresses, &waddr);

			/* Sign the announcement */
			u8 compact[64];
			size_t offset = 2 + sizeof(offset);
			memset(&sig, 0, sizeof(sig));

			u8 *nannounce = towire_node_announcement(ctx,
								&sig,
								NULL,
								timestamp,
								node_to_ann,
								node_to_ann->k,
								alias,
								addresses,
								tlvs);

			if (tal_count(nannounce) < offset)
				assert(false && "Node announcement too short!");

			sha256_double(&hash, nannounce + offset, tal_count(nannounce) - offset);
			sign_hash(&node_pkey, &hash, &sig);
			secp256k1_ecdsa_signature_serialize_compact(secp256k1_ctx, compact, &sig);
			assert(tal_count(nannounce) > 2 + sizeof(compact));
			memcpy(nannounce + 2, compact, sizeof(compact));

			gossip_msg = nannounce;
			break;
		}
		case 3: /* WIRE_REPLY_CHANNEL_RANGE */
		{
			/* Need atleast one channel. */
			if (tal_count(channels) < 1)
				return NULL;

			u32 first_blocknum, number_of_blocks;
			u8 sync_complete;
			u8 *encoded_short_ids = tal_arr(ctx, u8, 0);
			struct tlv_reply_channel_range_tlvs *tlvs;
			size_t start, end;

			first_blocknum = fromwire_u32(cursor, max);
			number_of_blocks = fromwire_u32(cursor, max);
			sync_complete = fromwire_u8(cursor, max);
			tlvs = tlv_reply_channel_range_tlvs_new(ctx);

			start = fromwire_u64(cursor, max) % tal_count(channels);
			end = fromwire_u64(cursor, max) % tal_count(channels);
			if (start > end) {
				size_t tmp = start;
				start = end;
				end = tmp;
			}
			towire_u8(&encoded_short_ids, ARR_UNCOMPRESSED);
			for (size_t i = start; i != end; i++)
				towire_short_channel_id(&encoded_short_ids,
							channels[i].scidd.scid);

			gossip_msg = towire_reply_channel_range(ctx,
								&chainparams->genesis_blockhash,
								first_blocknum,
								number_of_blocks,
								sync_complete,
								encoded_short_ids,
								tlvs);
			break;
		}
		case 4: /* WIRE_REPLY_SHORT_CHANNEL_IDS_END */
		{
			u8 full_info = fromwire_u8(cursor, max);
			gossip_msg = towire_reply_short_channel_ids_end(ctx,
						&chainparams->genesis_blockhash, full_info);
			break;
		}
		default:
			break;
	}
	return gossip_msg;
}

void init(int *argc, char ***argv)
{
	char *filename;
	connectd_fd = tmpdir_mkstemp(NULL, "fuzz-gossipd-connectd.XXXXXX", &filename);
	int devnull = open("/dev/null", O_WRONLY);

	common_setup("fuzzer");
	status_setup_sync(devnull);
	chainparams = chainparams_for_network("bitcoin");
	memset(&funding_pkey, 'F', sizeof(funding_pkey));
}

void run(const uint8_t *data, size_t size)
{
	struct daemon *daemon = new_daemon(tmpctx, &data, &size);
	if (!daemon)
		goto cleanup;

	peer_ids = tal_arr(tmpctx, struct node_id, 0);
	node_ids = tal_arr(tmpctx, struct node_id, 0);
	channels = tal_arr(tmpctx, struct channel_info, 0);

	/* Reset the gossip store file. */
	unlink(GOSSIP_STORE_FILENAME);

	/* Simulate gossipd's handler for connectd messages: connectd_req() */
	while (size > sizeof(u8)) {

		u8 *msg = tal_arr(tmpctx, u8, 0);

		int op = fromwire_u8(&data, &size) % 3;
		switch (op) {
		case 0: /* WIRE_GOSSIPD_NEW_PEER */
		{
			if (tal_count(peer_ids) >= MAX_PEERS)
				break;

			struct node_id id = node_id(privkey_from_index(tal_count(peer_ids)));
			tal_arr_expand(&peer_ids, id);

			bool gossip_queries_feature = fromwire_u8(&data, &size) % 2;
			msg = towire_gossipd_new_peer(tmpctx, &id, gossip_queries_feature);
			connectd_new_peer(daemon, msg);
			break;
		}
		case 1: /* WIRE_GOSSIPD_RECV_GOSSIP */
		{
			/* Need atleast one peer to gossip. */
			if (tal_count(peer_ids) == 0)
				break;

			struct node_id peer_to_gossip = peer_ids[fromwire_u64(&data, &size) % tal_count(peer_ids)];

			u8 *gossip_msg = create_gossip_msg(tmpctx, &data, &size);
			if (!gossip_msg)
				break;

			msg = towire_gossipd_recv_gossip(tmpctx, &peer_to_gossip, gossip_msg);
			handle_recv_gossip(daemon, msg);
			break;
		}
		case 2: /* WIRE_GOSSIPD_PEER_GONE */
		{
			/* Nothing to remove. */
			if (tal_count(peer_ids) == 0)
				break;

			size_t idx = fromwire_u64(&data, &size) % tal_count(peer_ids);
			struct node_id id_to_del = peer_ids[idx];
			tal_arr_remove(&peer_ids, idx);

			msg = towire_gossipd_peer_gone(tmpctx, &id_to_del);
			connectd_peer_gone(daemon, msg);
			break;
		}
		default:
			break;
		}
		tal_free(msg);
	}

cleanup:
	if (daemon) {
		tal_free(daemon->connectd);
		uintmap_clear(&daemon->gm->early_ann_map.map);
		uintmap_clear(&daemon->seeker->unknown_scids);
	}
	clean_tmpctx();
}
