#include "config.h"
#include "../log.c"
#include <common/daemon.h>
#include <common/setup.h>

/* AUTOGENERATED MOCKS START */
/* Generated stub for command_check_done */
struct command_result *command_check_done(struct command *cmd)

{ fprintf(stderr, "command_check_done called!\n"); abort(); }
/* Generated stub for command_check_only */
bool command_check_only(const struct command *cmd UNNEEDED)
{ fprintf(stderr, "command_check_only called!\n"); abort(); }
/* Generated stub for command_deprecated_in_ok */
bool command_deprecated_in_ok(struct command *cmd UNNEEDED,
			      const char *param UNNEEDED,
			      const char *depr_start UNNEEDED,
			      const char *depr_end UNNEEDED)
{ fprintf(stderr, "command_deprecated_in_ok called!\n"); abort(); }
/* Generated stub for command_dev_apis */
bool command_dev_apis(const struct command *cmd UNNEEDED)
{ fprintf(stderr, "command_dev_apis called!\n"); abort(); }
/* Generated stub for command_fail */
struct command_result *command_fail(struct command *cmd UNNEEDED, enum jsonrpc_errcode code UNNEEDED,
				    const char *fmt UNNEEDED, ...)

{ fprintf(stderr, "command_fail called!\n"); abort(); }
/* Generated stub for command_filter_ptr */
struct json_filter **command_filter_ptr(struct command *cmd UNNEEDED)
{ fprintf(stderr, "command_filter_ptr called!\n"); abort(); }
/* Generated stub for command_log */
void command_log(struct command *cmd UNNEEDED, enum log_level level UNNEEDED,
		 const char *fmt UNNEEDED, ...)

{ fprintf(stderr, "command_log called!\n"); abort(); }
/* Generated stub for command_param_failed */
struct command_result *command_param_failed(void)

{ fprintf(stderr, "command_param_failed called!\n"); abort(); }
/* Generated stub for command_set_usage */
void command_set_usage(struct command *cmd UNNEEDED, const char *usage UNNEEDED)
{ fprintf(stderr, "command_set_usage called!\n"); abort(); }
/* Generated stub for command_success */
struct command_result *command_success(struct command *cmd UNNEEDED,
				       struct json_stream *response)

{ fprintf(stderr, "command_success called!\n"); abort(); }
/* Generated stub for command_usage_only */
bool command_usage_only(const struct command *cmd UNNEEDED)
{ fprintf(stderr, "command_usage_only called!\n"); abort(); }
/* Generated stub for json_stream_log_suppress_for_cmd */
void json_stream_log_suppress_for_cmd(struct json_stream *js UNNEEDED,
					    const struct command *cmd UNNEEDED)
{ fprintf(stderr, "json_stream_log_suppress_for_cmd called!\n"); abort(); }
/* Generated stub for json_stream_success */
struct json_stream *json_stream_success(struct command *cmd UNNEEDED)
{ fprintf(stderr, "json_stream_success called!\n"); abort(); }
/* Generated stub for notify_log */
void notify_log(struct lightningd *ld UNNEEDED, const struct log_entry *l UNNEEDED)
{ fprintf(stderr, "notify_log called!\n"); abort(); }
/* Generated stub for notify_warning */
void notify_warning(struct lightningd *ld UNNEEDED, struct log_entry *l UNNEEDED)
{ fprintf(stderr, "notify_warning called!\n"); abort(); }
/* AUTOGENERATED MOCKS END */

int main(int argc, char *argv[])
{
	struct log_book *lb;
	struct logger *l;

	common_setup(argv[0]);

	lb = new_log_book(NULL,
			  (sizeof(struct log_entry) + sizeof("test XXXXXX"))
			  *100);
	l = new_logger(lb, lb, NULL, "test %s", "prefix");

	assert(streq(log_prefix(l), "test prefix"));

	for (size_t i = 0; i < 100; i++)
		log_debug(l, "test %06zi", i);

	assert(lb->num_entries == 100);
	for (size_t i = 0; i < 100; i++) {
		assert(lb->log[i].level == LOG_DBG);
		assert(lb->log[i].skipped == 0);
		assert(lb->log[i].nc == NULL);
		assert(lb->log[i].prefix->refcnt == 101);
		assert(streq(lb->log[i].prefix->prefix, "test prefix"));
		assert(streq(lb->log[i].log, tal_fmt(lb, "test %06zi", i)));
		assert(lb->log[i].io == NULL);
	}

	log_debug(l, "final test message");
	assert(lb->num_entries < 100);
	assert(lb->num_entries > 11);

	/* last 10% must be preserved exactly (with final and pruning
	 * msg appended) */
	for (size_t i = 91; i < 100; i++) {
		size_t pos = lb->num_entries - 2 - (100 - i);
		assert(streq(lb->log[pos].log, tal_fmt(lb, "test %06zi", i)));
	}
	assert(streq(lb->log[lb->num_entries - 2].log, "final test message"));

	/* Sum should still reflect 102 total messages */
	size_t total = 0;
	for (size_t i = 0; i < lb->num_entries; i++)
		total += 1 + lb->log[i].skipped;
	assert(total == 102);

	/* Freeing (last) log frees logbook */
	tal_free(l);
	common_shutdown();
}
