#include "config.h"
#include "../log.c"
#include <common/daemon.h>
#include <common/setup.h>

/* AUTOGENERATED MOCKS START */
/* Generated stub for command_check_done */
struct command_result *command_check_done(struct command *cmd)

{ fprintf(stderr, "command_check_done called!\n"); abort(); }
/* Generated stub for command_check_only */
bool command_check_only(const struct command *cmd UNNEEDED)
{ fprintf(stderr, "command_check_only called!\n"); abort(); }
/* Generated stub for command_deprecated_in_ok */
bool command_deprecated_in_ok(struct command *cmd UNNEEDED,
			      const char *param UNNEEDED,
			      const char *depr_start UNNEEDED,
			      const char *depr_end UNNEEDED)
{ fprintf(stderr, "command_deprecated_in_ok called!\n"); abort(); }
/* Generated stub for command_dev_apis */
bool command_dev_apis(const struct command *cmd UNNEEDED)
{ fprintf(stderr, "command_dev_apis called!\n"); abort(); }
/* Generated stub for command_fail */
struct command_result *command_fail(struct command *cmd UNNEEDED, enum jsonrpc_errcode code UNNEEDED,
				    const char *fmt UNNEEDED, ...)

{ fprintf(stderr, "command_fail called!\n"); abort(); }
/* Generated stub for command_filter_ptr */
struct json_filter **command_filter_ptr(struct command *cmd UNNEEDED)
{ fprintf(stderr, "command_filter_ptr called!\n"); abort(); }
/* Generated stub for command_log */
void command_log(struct command *cmd UNNEEDED, enum log_level level UNNEEDED,
		 const char *fmt UNNEEDED, ...)

{ fprintf(stderr, "command_log called!\n"); abort(); }
/* Generated stub for command_param_failed */
struct command_result *command_param_failed(void)

{ fprintf(stderr, "command_param_failed called!\n"); abort(); }
/* Generated stub for command_set_usage */
void command_set_usage(struct command *cmd UNNEEDED, const char *usage UNNEEDED)
{ fprintf(stderr, "command_set_usage called!\n"); abort(); }
/* Generated stub for command_success */
struct command_result *command_success(struct command *cmd UNNEEDED,
				       struct json_stream *response)

{ fprintf(stderr, "command_success called!\n"); abort(); }
/* Generated stub for command_usage_only */
bool command_usage_only(const struct command *cmd UNNEEDED)
{ fprintf(stderr, "command_usage_only called!\n"); abort(); }
/* Generated stub for json_stream_log_suppress_for_cmd */
void json_stream_log_suppress_for_cmd(struct json_stream *js UNNEEDED,
					    const struct command *cmd UNNEEDED)
{ fprintf(stderr, "json_stream_log_suppress_for_cmd called!\n"); abort(); }
/* Generated stub for json_stream_success */
struct json_stream *json_stream_success(struct command *cmd UNNEEDED)
{ fprintf(stderr, "json_stream_success called!\n"); abort(); }
/* Generated stub for notify_log */
void notify_log(struct lightningd *ld UNNEEDED,
		enum log_level level UNNEEDED,
		struct timeabs time UNNEEDED,
		const char *source UNNEEDED,
		const char *logmsg UNNEEDED)
{ fprintf(stderr, "notify_log called!\n"); abort(); }
/* Generated stub for notify_warning */
void notify_warning(struct lightningd *ld UNNEEDED,
		    enum log_level level UNNEEDED,
		    struct timeabs time UNNEEDED,
		    const char *source UNNEEDED,
		    const char *logmsg UNNEEDED)
{ fprintf(stderr, "notify_warning called!\n"); abort(); }
/* AUTOGENERATED MOCKS END */

int main(int argc, char *argv[])
{
	struct log_book *lb;
	struct logger *l;
	size_t prev_avail = -1ULL, num = 0, off, i;
	const u8 *io;
	const char *msg;
	struct log_hdr lhdr;

	common_setup(argv[0]);

	lb = new_log_book(NULL);
	l = new_logger(lb, lb, NULL, "test %s", "prefix");

	assert(streq(log_prefix(l), "test prefix"));

	/* Push one off the end. */
	while (ringbuf_avail(lb) < prev_avail) {
		prev_avail = ringbuf_avail(lb);
		log_debug(l, "test %06zi", num++);
	}

	assert(ringbuf_used(lb) <= sizeof(lb->ringbuf));
	assert(ringbuf_avail(lb) < sizeof(struct log_hdr) + strlen("test 000000"));

	off = 0;
	i = 1;
	while (get_log_entry(tmpctx, lb, &lhdr, &msg, &io, &off)) {
		assert(lhdr.level == LOG_DBG);
		assert(lhdr.nc == NULL);
		assert(streq(lhdr.prefix->prefix, "test prefix"));
		assert(lhdr.msglen == strlen("test 000000"));
		assert(lhdr.iolen == 0);
		assert(strncmp(msg, tal_fmt(lb, "test %06zi", i++), lhdr.msglen) == 0);
		assert(lhdr.prefix->refcnt == num);
		assert(io == NULL);
	}

	/* Freeing (last) log frees logbook */
	tal_free(l);
	common_shutdown();
}
