#include "config.h"
#define main unused_main
int unused_main(int argc, char *argv[]);
#include "../io_loop_with_timers.c"
#include "../lightningd.c"
#include "../subd.c"
#include <common/json_command.h>
#include <common/setup.h>
#include <hsmd/hsmd_wiregen.h>

/* AUTOGENERATED MOCKS START */
/* Generated stub for begin_topology */
void begin_topology(struct chain_topology *topo UNNEEDED)
{ fprintf(stderr, "begin_topology called!\n"); abort(); }
/* Generated stub for bip86_pubkey */
void bip86_pubkey(struct lightningd *ld UNNEEDED, struct pubkey *pubkey UNNEEDED, u32 index UNNEEDED)
{ fprintf(stderr, "bip86_pubkey called!\n"); abort(); }
/* Generated stub for channel_gossip_notify_new_block */
void channel_gossip_notify_new_block(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "channel_gossip_notify_new_block called!\n"); abort(); }
/* Generated stub for channel_notify_new_block */
void channel_notify_new_block(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "channel_notify_new_block called!\n"); abort(); }
/* Generated stub for command_check_only */
bool command_check_only(const struct command *cmd UNNEEDED)
{ fprintf(stderr, "command_check_only called!\n"); abort(); }
/* Generated stub for command_dev_apis */
bool command_dev_apis(const struct command *cmd UNNEEDED)
{ fprintf(stderr, "command_dev_apis called!\n"); abort(); }
/* Generated stub for command_fail */
struct command_result *command_fail(struct command *cmd UNNEEDED, enum jsonrpc_errcode code UNNEEDED,
				    const char *fmt UNNEEDED, ...)

{ fprintf(stderr, "command_fail called!\n"); abort(); }
/* Generated stub for command_filter_ptr */
struct json_filter **command_filter_ptr(struct command *cmd UNNEEDED)
{ fprintf(stderr, "command_filter_ptr called!\n"); abort(); }
/* Generated stub for command_log */
void command_log(struct command *cmd UNNEEDED, enum log_level level UNNEEDED,
		 const char *fmt UNNEEDED, ...)

{ fprintf(stderr, "command_log called!\n"); abort(); }
/* Generated stub for connectd_activate */
void connectd_activate(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "connectd_activate called!\n"); abort(); }
/* Generated stub for connectd_init */
int connectd_init(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "connectd_init called!\n"); abort(); }
/* Generated stub for connectd_start_shutdown */
void connectd_start_shutdown(struct subd *connectd UNNEEDED)
{ fprintf(stderr, "connectd_start_shutdown called!\n"); abort(); }
/* Generated stub for db_begin_transaction_ */
void db_begin_transaction_(struct db *db UNNEEDED, const char *location UNNEEDED)
{ fprintf(stderr, "db_begin_transaction_ called!\n"); abort(); }
/* Generated stub for db_commit_transaction */
void db_commit_transaction(struct db *db UNNEEDED)
{ fprintf(stderr, "db_commit_transaction called!\n"); abort(); }
/* Generated stub for db_get_intvar */
s64 db_get_intvar(struct db *db UNNEEDED, const char *varname UNNEEDED, s64 defval UNNEEDED)
{ fprintf(stderr, "db_get_intvar called!\n"); abort(); }
/* Generated stub for db_in_transaction */
bool db_in_transaction(struct db *db UNNEEDED)
{ fprintf(stderr, "db_in_transaction called!\n"); abort(); }
/* Generated stub for fatal */
void   fatal(const char *fmt UNNEEDED, ...)
{ fprintf(stderr, "fatal called!\n"); abort(); }
/* Generated stub for free_htlcs */
void free_htlcs(struct lightningd *ld UNNEEDED, const struct channel *channel UNNEEDED)
{ fprintf(stderr, "free_htlcs called!\n"); abort(); }
/* Generated stub for fromwire_hsmd_ecdh_resp */
bool fromwire_hsmd_ecdh_resp(const void *p UNNEEDED, struct secret *ss UNNEEDED)
{ fprintf(stderr, "fromwire_hsmd_ecdh_resp called!\n"); abort(); }
/* Generated stub for gossip_init */
void gossip_init(struct lightningd *ld UNNEEDED, int connectd_fd UNNEEDED)
{ fprintf(stderr, "gossip_init called!\n"); abort(); }
/* Generated stub for gossip_notify_new_block */
void gossip_notify_new_block(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "gossip_notify_new_block called!\n"); abort(); }
/* Generated stub for handle_early_opts */
void handle_early_opts(struct lightningd *ld UNNEEDED, int argc UNNEEDED, char *argv[])
{ fprintf(stderr, "handle_early_opts called!\n"); abort(); }
/* Generated stub for handle_opts */
void handle_opts(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "handle_opts called!\n"); abort(); }
/* Generated stub for hash_cid */
size_t hash_cid(const struct channel_id *cid UNNEEDED)
{ fprintf(stderr, "hash_cid called!\n"); abort(); }
/* Generated stub for hash_htlc_key */
size_t hash_htlc_key(const struct htlc_key *htlc_key UNNEEDED)
{ fprintf(stderr, "hash_htlc_key called!\n"); abort(); }
/* Generated stub for hsm_init */
struct ext_key *hsm_init(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "hsm_init called!\n"); abort(); }
/* Generated stub for htlcs_notify_new_block */
void htlcs_notify_new_block(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "htlcs_notify_new_block called!\n"); abort(); }
/* Generated stub for htlcs_resubmit */
void htlcs_resubmit(struct lightningd *ld UNNEEDED,
		    struct htlc_in_map *unconnected_htlcs_in STEALS UNNEEDED)
{ fprintf(stderr, "htlcs_resubmit called!\n"); abort(); }
/* Generated stub for invoices_start_expiration */
void invoices_start_expiration(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "invoices_start_expiration called!\n"); abort(); }
/* Generated stub for jsonrpc_listen */
void jsonrpc_listen(struct jsonrpc *rpc UNNEEDED, struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "jsonrpc_listen called!\n"); abort(); }
/* Generated stub for jsonrpc_setup */
void jsonrpc_setup(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "jsonrpc_setup called!\n"); abort(); }
/* Generated stub for jsonrpc_stop_all */
void jsonrpc_stop_all(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "jsonrpc_stop_all called!\n"); abort(); }
/* Generated stub for jsonrpc_stop_listening */
void jsonrpc_stop_listening(struct jsonrpc *jsonrpc UNNEEDED)
{ fprintf(stderr, "jsonrpc_stop_listening called!\n"); abort(); }
/* Generated stub for load_channels_from_wallet */
struct htlc_in_map *load_channels_from_wallet(struct lightningd *ld UNNEEDED,
					      size_t *num_channels UNNEEDED)
{ fprintf(stderr, "load_channels_from_wallet called!\n"); abort(); }
/* Generated stub for log_ */
void log_(struct logger *logger UNNEEDED, enum log_level level UNNEEDED,
	  const struct node_id *node_id UNNEEDED,
	  bool call_notifier UNNEEDED,
	  const char *fmt UNNEEDED, ...)

{ fprintf(stderr, "log_ called!\n"); abort(); }
/* Generated stub for log_backtrace_exit */
void log_backtrace_exit(void)
{ fprintf(stderr, "log_backtrace_exit called!\n"); abort(); }
/* Generated stub for log_backtrace_print */
void log_backtrace_print(const char *fmt UNNEEDED, ...)
{ fprintf(stderr, "log_backtrace_print called!\n"); abort(); }
/* Generated stub for log_has_io_logging */
bool log_has_io_logging(const struct logger *log UNNEEDED)
{ fprintf(stderr, "log_has_io_logging called!\n"); abort(); }
/* Generated stub for log_has_trace_logging */
bool log_has_trace_logging(const struct logger *log UNNEEDED)
{ fprintf(stderr, "log_has_trace_logging called!\n"); abort(); }
/* Generated stub for log_prefix */
const char *log_prefix(const struct logger *logger UNNEEDED)
{ fprintf(stderr, "log_prefix called!\n"); abort(); }
/* Generated stub for log_status_msg */
bool log_status_msg(struct logger *log UNNEEDED,
 		    const struct node_id *node_id UNNEEDED,
		    const u8 *msg UNNEEDED)
{ fprintf(stderr, "log_status_msg called!\n"); abort(); }
/* Generated stub for new_log_book */
struct log_book *new_log_book(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "new_log_book called!\n"); abort(); }
/* Generated stub for new_logger */
struct logger *new_logger(const tal_t *ctx UNNEEDED, struct log_book *record UNNEEDED,
			  const struct node_id *default_node_id UNNEEDED,
			  const char *fmt UNNEEDED, ...)
{ fprintf(stderr, "new_logger called!\n"); abort(); }
/* Generated stub for new_peer_fd_arr */
struct peer_fd *new_peer_fd_arr(const tal_t *ctx UNNEEDED, const int *fd UNNEEDED)
{ fprintf(stderr, "new_peer_fd_arr called!\n"); abort(); }
/* Generated stub for new_topology */
struct chain_topology *new_topology(struct lightningd *ld UNNEEDED, struct logger *log UNNEEDED)
{ fprintf(stderr, "new_topology called!\n"); abort(); }
/* Generated stub for onchaind_replay_channels */
void onchaind_replay_channels(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "onchaind_replay_channels called!\n"); abort(); }
/* Generated stub for plugin_hook_call_ */
bool plugin_hook_call_(struct lightningd *ld UNNEEDED,
		       struct plugin_hook *hook UNNEEDED,
		       const char *strfilterfield TAKES UNNEEDED,
		       u64 intfilterfield UNNEEDED,
		       const char *cmd_id TAKES UNNEEDED,
		       tal_t *cb_arg STEALS UNNEEDED)
{ fprintf(stderr, "plugin_hook_call_ called!\n"); abort(); }
/* Generated stub for plugins_config */
bool plugins_config(struct plugins *plugins UNNEEDED)
{ fprintf(stderr, "plugins_config called!\n"); abort(); }
/* Generated stub for plugins_init */
void plugins_init(struct plugins *plugins UNNEEDED)
{ fprintf(stderr, "plugins_init called!\n"); abort(); }
/* Generated stub for plugins_new */
struct plugins *plugins_new(const tal_t *ctx UNNEEDED, struct log_book *log_book UNNEEDED,
			    struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "plugins_new called!\n"); abort(); }
/* Generated stub for plugins_set_builtin_plugins_dir */
void plugins_set_builtin_plugins_dir(struct plugins *plugins UNNEEDED,
				     const char *dir UNNEEDED)
{ fprintf(stderr, "plugins_set_builtin_plugins_dir called!\n"); abort(); }
/* Generated stub for resend_closing_transactions */
void resend_closing_transactions(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "resend_closing_transactions called!\n"); abort(); }
/* Generated stub for resend_opening_transactions */
void resend_opening_transactions(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "resend_opening_transactions called!\n"); abort(); }
/* Generated stub for runes_early_init */
struct runes *runes_early_init(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "runes_early_init called!\n"); abort(); }
/* Generated stub for runes_finish_init */
void runes_finish_init(struct runes *runes UNNEEDED)
{ fprintf(stderr, "runes_finish_init called!\n"); abort(); }
/* Generated stub for setup_color_and_alias */
void setup_color_and_alias(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "setup_color_and_alias called!\n"); abort(); }
/* Generated stub for setup_peers */
void setup_peers(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "setup_peers called!\n"); abort(); }
/* Generated stub for setup_topology */
void setup_topology(struct chain_topology *topology UNNEEDED)
{ fprintf(stderr, "setup_topology called!\n"); abort(); }
/* Generated stub for shutdown_plugins */
void shutdown_plugins(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "shutdown_plugins called!\n"); abort(); }
/* Generated stub for stop_topology */
void stop_topology(struct chain_topology *topo UNNEEDED)
{ fprintf(stderr, "stop_topology called!\n"); abort(); }
/* Generated stub for towire_hsmd_ecdh_req */
u8 *towire_hsmd_ecdh_req(const tal_t *ctx UNNEEDED, const struct pubkey *point UNNEEDED)
{ fprintf(stderr, "towire_hsmd_ecdh_req called!\n"); abort(); }
/* Generated stub for waitblockheight_notify_new_block */
void waitblockheight_notify_new_block(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "waitblockheight_notify_new_block called!\n"); abort(); }
/* Generated stub for wallet_add_bwatch_derkey */
void wallet_add_bwatch_derkey(struct lightningd *ld UNNEEDED,
			      u64 keyindex UNNEEDED,
			      u32 start_block UNNEEDED,
			      const u8 derkey[PUBKEY_CMPR_LEN])
{ fprintf(stderr, "wallet_add_bwatch_derkey called!\n"); abort(); }
/* Generated stub for wallet_add_bwatch_scriptpubkey */
void wallet_add_bwatch_scriptpubkey(struct lightningd *ld UNNEEDED,
				    const char *owner_prefix UNNEEDED,
				    u64 keyindex UNNEEDED,
				    u32 start_block UNNEEDED,
				    const u8 *script UNNEEDED,
				    size_t script_len UNNEEDED)
{ fprintf(stderr, "wallet_add_bwatch_scriptpubkey called!\n"); abort(); }
/* Generated stub for wallet_begin_old_close_rescan */
void wallet_begin_old_close_rescan(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "wallet_begin_old_close_rescan called!\n"); abort(); }
/* Generated stub for wallet_delete_old_htlcs */
void wallet_delete_old_htlcs(struct wallet *w UNNEEDED)
{ fprintf(stderr, "wallet_delete_old_htlcs called!\n"); abort(); }
/* Generated stub for wallet_new */
struct wallet *wallet_new(struct lightningd *ld UNNEEDED, struct timers *timers UNNEEDED)
{ fprintf(stderr, "wallet_new called!\n"); abort(); }
/* Generated stub for wallet_sanity_check */
bool wallet_sanity_check(struct wallet *w UNNEEDED)
{ fprintf(stderr, "wallet_sanity_check called!\n"); abort(); }
/* Generated stub for watchman_get_height */
u32 watchman_get_height(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "watchman_get_height called!\n"); abort(); }
/* Generated stub for watchman_new */
struct watchman *watchman_new(const tal_t *ctx UNNEEDED, struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "watchman_new called!\n"); abort(); }
/* AUTOGENERATED MOCKS END */

struct logger *crashlog;

#undef main
int main(int argc UNUSED, char *argv[])
{
	common_setup(argv[0]);

	char *argv0;
	/* We're assuming we're run from top build dir. */
	const char *answer;

	answer = path_canon(tmpctx, "lightningd/test/run-find_my_abspath");

	/* Various different ways we could find ourselves. */
	argv0 = path_join(tmpctx,
			  path_cwd(tmpctx), "lightningd/test/run-find_my_abspath");
	unsetenv("PATH");

	/* Absolute path. */
	assert(streq(find_my_abspath(tmpctx, argv0), answer));

	/* Relative to cwd. */
	argv0 = "lightningd/test/run-find_my_abspath";
	assert(streq(find_my_abspath(tmpctx, argv0), answer));

	/* Using $PATH */
	setenv("PATH", path_join(tmpctx,
				 path_cwd(tmpctx), "lightningd/test"), 1);
	argv0 = "run-find_my_abspath";

	assert(streq(find_my_abspath(tmpctx, argv0), answer));

	/* Even with dummy things in path. */
	char **pathelems = tal_arr(tmpctx, char *, 4);
	pathelems[0] = "/tmp/foo";
	pathelems[1] = "/sbin";
	pathelems[2] = path_join(tmpctx, path_cwd(tmpctx), "lightningd/test");
	pathelems[3] = NULL;

	setenv("PATH", tal_strjoin(tmpctx, pathelems, ":", STR_NO_TRAIL), 1);
	assert(streq(find_my_abspath(tmpctx, argv0), answer));

	assert(!taken_any());
	common_shutdown();

	return 0;
}
