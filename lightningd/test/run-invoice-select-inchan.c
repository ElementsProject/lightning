#include "config.h"
#include "../invoice.c"
#include "../peer_control.c"
#include "../routehint.c"
#include <ccan/alignof/alignof.h>
#include <common/daemon.h>
#include <common/errcode.h>
#include <common/setup.h>
#include <stdio.h>

/* AUTOGENERATED MOCKS START */
/* Generated stub for any_channel_by_scid */
struct channel *any_channel_by_scid(struct lightningd *ld UNNEEDED,
				    struct short_channel_id scid UNNEEDED,
				    bool privacy_leak_ok UNNEEDED)
{ fprintf(stderr, "any_channel_by_scid called!\n"); abort(); }
/* Generated stub for bip32_pubkey */
void bip32_pubkey(struct lightningd *ld UNNEEDED, struct pubkey *pubkey UNNEEDED, u32 index UNNEEDED)
{ fprintf(stderr, "bip32_pubkey called!\n"); abort(); }
/* Generated stub for bip86_pubkey */
void bip86_pubkey(struct lightningd *ld UNNEEDED, struct pubkey *pubkey UNNEEDED, u32 index UNNEEDED)
{ fprintf(stderr, "bip86_pubkey called!\n"); abort(); }
/* Generated stub for bitcoind_getutxout_ */
void bitcoind_getutxout_(const tal_t *ctx UNNEEDED,
			 struct bitcoind *bitcoind UNNEEDED,
			 const struct bitcoin_outpoint *outpoint UNNEEDED,
			 void (*cb)(struct bitcoind * UNNEEDED,
				    const struct bitcoin_tx_output * UNNEEDED,
				    void *) UNNEEDED,
			 void *arg UNNEEDED)
{ fprintf(stderr, "bitcoind_getutxout_ called!\n"); abort(); }
/* Generated stub for broadcast_tx_ */
void broadcast_tx_(const tal_t *ctx UNNEEDED,
		   struct chain_topology *topo UNNEEDED,
		   struct channel *channel UNNEEDED,
		   const struct bitcoin_tx *tx TAKES UNNEEDED,
		   const char *cmd_id UNNEEDED, bool allowhighfees UNNEEDED, u32 minblock UNNEEDED,
		   bool (*finished)(struct channel * UNNEEDED,
				    const struct bitcoin_tx * UNNEEDED,
				    bool success UNNEEDED,
				    const char *err UNNEEDED,
				    void *) UNNEEDED,
		   bool (*refresh)(struct channel * UNNEEDED, const struct bitcoin_tx ** UNNEEDED, void *) UNNEEDED,
		   void *cbarg TAKES UNNEEDED)
{ fprintf(stderr, "broadcast_tx_ called!\n"); abort(); }
/* Generated stub for channel_change_state_reason_str */
const char *channel_change_state_reason_str(enum state_change reason UNNEEDED)
{ fprintf(stderr, "channel_change_state_reason_str called!\n"); abort(); }
/* Generated stub for channel_cleanup_commands */
void channel_cleanup_commands(struct channel *channel UNNEEDED, const char *why UNNEEDED)
{ fprintf(stderr, "channel_cleanup_commands called!\n"); abort(); }
/* Generated stub for channel_fail_forget */
void channel_fail_forget(struct channel *channel UNNEEDED, const char *fmt UNNEEDED, ...)
{ fprintf(stderr, "channel_fail_forget called!\n"); abort(); }
/* Generated stub for channel_fail_permanent */
void channel_fail_permanent(struct channel *channel UNNEEDED,
			    enum state_change reason UNNEEDED,
			    const char *fmt UNNEEDED,
			    ...)
{ fprintf(stderr, "channel_fail_permanent called!\n"); abort(); }
/* Generated stub for channel_fail_saw_onchain */
void channel_fail_saw_onchain(struct channel *channel UNNEEDED,
			      enum state_change reason UNNEEDED,
			      const struct bitcoin_tx *tx UNNEEDED,
			      const char *fmt UNNEEDED,
			      ...)
{ fprintf(stderr, "channel_fail_saw_onchain called!\n"); abort(); }
/* Generated stub for channel_fail_transient */
void channel_fail_transient(struct channel *channel UNNEEDED,
			    bool disconnect UNNEEDED,
			    const char *fmt UNNEEDED, ...)
{ fprintf(stderr, "channel_fail_transient called!\n"); abort(); }
/* Generated stub for channel_gossip_channel_disconnect */
void channel_gossip_channel_disconnect(struct channel *channel UNNEEDED)
{ fprintf(stderr, "channel_gossip_channel_disconnect called!\n"); abort(); }
/* Generated stub for channel_gossip_get_remote_update */
const struct peer_update *channel_gossip_get_remote_update(const struct channel *channel UNNEEDED)
{ fprintf(stderr, "channel_gossip_get_remote_update called!\n"); abort(); }
/* Generated stub for channel_gossip_node_announce */
void channel_gossip_node_announce(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "channel_gossip_node_announce called!\n"); abort(); }
/* Generated stub for channel_gossip_startup_done */
void channel_gossip_startup_done(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "channel_gossip_startup_done called!\n"); abort(); }
/* Generated stub for channel_has_htlc_in */
struct htlc_in *channel_has_htlc_in(struct channel *channel UNNEEDED)
{ fprintf(stderr, "channel_has_htlc_in called!\n"); abort(); }
/* Generated stub for channel_has_htlc_out */
struct htlc_out *channel_has_htlc_out(struct channel *channel UNNEEDED)
{ fprintf(stderr, "channel_has_htlc_out called!\n"); abort(); }
/* Generated stub for channel_important_filter */
bool channel_important_filter(const struct channel *channel UNNEEDED, void *unused UNNEEDED)
{ fprintf(stderr, "channel_important_filter called!\n"); abort(); }
/* Generated stub for channel_internal_error */
void channel_internal_error(struct channel *channel UNNEEDED, const char *fmt UNNEEDED, ...)
{ fprintf(stderr, "channel_internal_error called!\n"); abort(); }
/* Generated stub for channel_last_funding_feerate */
u32 channel_last_funding_feerate(const struct channel *channel UNNEEDED)
{ fprintf(stderr, "channel_last_funding_feerate called!\n"); abort(); }
/* Generated stub for channel_set_last_tx */
void channel_set_last_tx(struct channel *channel UNNEEDED,
			 struct bitcoin_tx *tx UNNEEDED,
			 const struct bitcoin_signature *sig UNNEEDED)
{ fprintf(stderr, "channel_set_last_tx called!\n"); abort(); }
/* Generated stub for channel_set_scid */
void channel_set_scid(struct channel *channel UNNEEDED, const struct short_channel_id *new_scid UNNEEDED)
{ fprintf(stderr, "channel_set_scid called!\n"); abort(); }
/* Generated stub for channel_state_name */
const char *channel_state_name(const struct channel *channel UNNEEDED)
{ fprintf(stderr, "channel_state_name called!\n"); abort(); }
/* Generated stub for channel_state_str */
const char *channel_state_str(enum channel_state state UNNEEDED)
{ fprintf(stderr, "channel_state_str called!\n"); abort(); }
/* Generated stub for channel_unsaved_close_conn */
void channel_unsaved_close_conn(struct channel *channel UNNEEDED, const char *why UNNEEDED)
{ fprintf(stderr, "channel_unsaved_close_conn called!\n"); abort(); }
/* Generated stub for channel_update_feerates */
void channel_update_feerates(struct lightningd *ld UNNEEDED, const struct channel *channel UNNEEDED)
{ fprintf(stderr, "channel_update_feerates called!\n"); abort(); }
/* Generated stub for channel_update_reserve */
void channel_update_reserve(struct channel *channel UNNEEDED,
			    struct channel_config *their_config UNNEEDED,
			    struct amount_sat funding_total UNNEEDED)
{ fprintf(stderr, "channel_update_reserve called!\n"); abort(); }
/* Generated stub for channeld_tell_depth */
void channeld_tell_depth(struct channel *channel UNNEEDED,
			 const struct bitcoin_txid *txid UNNEEDED,
			 u32 depth UNNEEDED)
{ fprintf(stderr, "channeld_tell_depth called!\n"); abort(); }
/* Generated stub for cmd_id_from_close_command */
const char *cmd_id_from_close_command(const tal_t *ctx UNNEEDED,
				      struct lightningd *ld UNNEEDED, struct channel *channel UNNEEDED)
{ fprintf(stderr, "cmd_id_from_close_command called!\n"); abort(); }
/* Generated stub for command_check_done */
struct command_result *command_check_done(struct command *cmd)

{ fprintf(stderr, "command_check_done called!\n"); abort(); }
/* Generated stub for command_check_only */
bool command_check_only(const struct command *cmd UNNEEDED)
{ fprintf(stderr, "command_check_only called!\n"); abort(); }
/* Generated stub for command_deprecated_in_ok */
bool command_deprecated_in_ok(struct command *cmd UNNEEDED,
			      const char *param UNNEEDED,
			      const char *depr_start UNNEEDED,
			      const char *depr_end UNNEEDED)
{ fprintf(stderr, "command_deprecated_in_ok called!\n"); abort(); }
/* Generated stub for command_deprecated_out_ok */
bool command_deprecated_out_ok(struct command *cmd UNNEEDED,
			       const char *fieldname UNNEEDED,
			       const char *depr_start UNNEEDED,
			       const char *depr_end UNNEEDED)
{ fprintf(stderr, "command_deprecated_out_ok called!\n"); abort(); }
/* Generated stub for command_dev_apis */
bool command_dev_apis(const struct command *cmd UNNEEDED)
{ fprintf(stderr, "command_dev_apis called!\n"); abort(); }
/* Generated stub for command_fail */
struct command_result *command_fail(struct command *cmd UNNEEDED, enum jsonrpc_errcode code UNNEEDED,
				    const char *fmt UNNEEDED, ...)

{ fprintf(stderr, "command_fail called!\n"); abort(); }
/* Generated stub for command_failed */
struct command_result *command_failed(struct command *cmd UNNEEDED,
				      struct json_stream *result)

{ fprintf(stderr, "command_failed called!\n"); abort(); }
/* Generated stub for command_filter_ptr */
struct json_filter **command_filter_ptr(struct command *cmd UNNEEDED)
{ fprintf(stderr, "command_filter_ptr called!\n"); abort(); }
/* Generated stub for command_its_complicated */
struct command_result *command_its_complicated(const char *why UNNEEDED)
{ fprintf(stderr, "command_its_complicated called!\n"); abort(); }
/* Generated stub for command_log */
void command_log(struct command *cmd UNNEEDED, enum log_level level UNNEEDED,
		 const char *fmt UNNEEDED, ...)

{ fprintf(stderr, "command_log called!\n"); abort(); }
/* Generated stub for command_logger */
struct logger *command_logger(struct command *cmd UNNEEDED)
{ fprintf(stderr, "command_logger called!\n"); abort(); }
/* Generated stub for command_param_failed */
struct command_result *command_param_failed(void)

{ fprintf(stderr, "command_param_failed called!\n"); abort(); }
/* Generated stub for command_set_usage */
void command_set_usage(struct command *cmd UNNEEDED, const char *usage UNNEEDED)
{ fprintf(stderr, "command_set_usage called!\n"); abort(); }
/* Generated stub for command_still_pending */
struct command_result *command_still_pending(struct command *cmd)

{ fprintf(stderr, "command_still_pending called!\n"); abort(); }
/* Generated stub for command_success */
struct command_result *command_success(struct command *cmd UNNEEDED,
				       struct json_stream *response)

{ fprintf(stderr, "command_success called!\n"); abort(); }
/* Generated stub for command_usage_only */
bool command_usage_only(const struct command *cmd UNNEEDED)
{ fprintf(stderr, "command_usage_only called!\n"); abort(); }
/* Generated stub for commit_tx_boost */
void commit_tx_boost(struct channel *channel UNNEEDED,
		     struct anchor_details *adet UNNEEDED,
		     bool success UNNEEDED)
{ fprintf(stderr, "commit_tx_boost called!\n"); abort(); }
/* Generated stub for connect_any_cmd_id */
const char *connect_any_cmd_id(const tal_t *ctx UNNEEDED,
			       struct lightningd *ld UNNEEDED, const struct peer *peer UNNEEDED)
{ fprintf(stderr, "connect_any_cmd_id called!\n"); abort(); }
/* Generated stub for connect_failed_disconnect */
void connect_failed_disconnect(struct lightningd *ld UNNEEDED,
			       const struct node_id *id UNNEEDED,
			       const struct wireaddr_internal *addr UNNEEDED)
{ fprintf(stderr, "connect_failed_disconnect called!\n"); abort(); }
/* Generated stub for connect_succeeded */
void connect_succeeded(struct lightningd *ld UNNEEDED, const struct peer *peer UNNEEDED,
		       bool incoming UNNEEDED,
		       const struct wireaddr_internal *addr UNNEEDED)
{ fprintf(stderr, "connect_succeeded called!\n"); abort(); }
/* Generated stub for connectd_connect_to_peer */
void connectd_connect_to_peer(struct lightningd *ld UNNEEDED,
			      const struct peer *peer UNNEEDED,
			      bool is_important UNNEEDED)
{ fprintf(stderr, "connectd_connect_to_peer called!\n"); abort(); }
/* Generated stub for create_anchor_details */
struct anchor_details *create_anchor_details(const tal_t *ctx UNNEEDED,
					     struct channel *channel UNNEEDED,
					     const struct bitcoin_tx *tx UNNEEDED)
{ fprintf(stderr, "create_anchor_details called!\n"); abort(); }
/* Generated stub for delete_channel */
void delete_channel(struct channel *channel STEALS UNNEEDED, bool completely_eliminate UNNEEDED)
{ fprintf(stderr, "delete_channel called!\n"); abort(); }
/* Generated stub for depthcb_update_scid */
bool depthcb_update_scid(struct channel *channel UNNEEDED,
			 const struct bitcoin_txid *txid UNNEEDED,
			 const struct bitcoin_outpoint *outpoint UNNEEDED)
{ fprintf(stderr, "depthcb_update_scid called!\n"); abort(); }
/* Generated stub for dev_disconnect_permanent */
bool dev_disconnect_permanent(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "dev_disconnect_permanent called!\n"); abort(); }
/* Generated stub for fatal */
void   fatal(const char *fmt UNNEEDED, ...)
{ fprintf(stderr, "fatal called!\n"); abort(); }
/* Generated stub for find_channel_by_id */
struct channel *find_channel_by_id(const struct peer *peer UNNEEDED,
				   const struct channel_id *cid UNNEEDED)
{ fprintf(stderr, "find_channel_by_id called!\n"); abort(); }
/* Generated stub for find_plugin_for_command */
struct plugin *find_plugin_for_command(struct lightningd *ld UNNEEDED,
				       const char *cmd_name UNNEEDED)
{ fprintf(stderr, "find_plugin_for_command called!\n"); abort(); }
/* Generated stub for find_txwatch_ */
struct txwatch *find_txwatch_(struct chain_topology *topo UNNEEDED,
			      const struct bitcoin_txid *txid UNNEEDED,
			      enum watch_result (*cb)(struct lightningd *ld UNNEEDED,
						      const struct bitcoin_txid * UNNEEDED,
						      const struct bitcoin_tx * UNNEEDED,
						      unsigned int depth UNNEEDED,
						      void *arg) UNNEEDED,
			    void *arg UNNEEDED)
{ fprintf(stderr, "find_txwatch_ called!\n"); abort(); }
/* Generated stub for fixup_htlcs_out */
void fixup_htlcs_out(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "fixup_htlcs_out called!\n"); abort(); }
/* Generated stub for force_peer_disconnect */
void force_peer_disconnect(struct lightningd *ld UNNEEDED,
			   const struct peer *peer UNNEEDED,
			   const char *why UNNEEDED)
{ fprintf(stderr, "force_peer_disconnect called!\n"); abort(); }
/* Generated stub for fromwire_channeld_dev_memleak_reply */
bool fromwire_channeld_dev_memleak_reply(const void *p UNNEEDED, bool *leak UNNEEDED)
{ fprintf(stderr, "fromwire_channeld_dev_memleak_reply called!\n"); abort(); }
/* Generated stub for fromwire_connectd_peer_connected */
bool fromwire_connectd_peer_connected(const tal_t *ctx UNNEEDED, const void *p UNNEEDED, struct node_id *id UNNEEDED, u64 *counter UNNEEDED, struct wireaddr_internal *addr UNNEEDED, struct wireaddr **remote_addr UNNEEDED, bool *incoming UNNEEDED, u8 **features UNNEEDED)
{ fprintf(stderr, "fromwire_connectd_peer_connected called!\n"); abort(); }
/* Generated stub for fromwire_connectd_peer_disconnected */
bool fromwire_connectd_peer_disconnected(const void *p UNNEEDED, struct node_id *id UNNEEDED, u64 *counter UNNEEDED)
{ fprintf(stderr, "fromwire_connectd_peer_disconnected called!\n"); abort(); }
/* Generated stub for fromwire_connectd_peer_reconnected */
bool fromwire_connectd_peer_reconnected(const tal_t *ctx UNNEEDED, const void *p UNNEEDED, struct node_id *id UNNEEDED, u64 *prev_counter UNNEEDED, u64 *counter UNNEEDED, struct wireaddr_internal *addr UNNEEDED, struct wireaddr **remote_addr UNNEEDED, bool *incoming UNNEEDED, u8 **features UNNEEDED)
{ fprintf(stderr, "fromwire_connectd_peer_reconnected called!\n"); abort(); }
/* Generated stub for fromwire_connectd_peer_spoke */
bool fromwire_connectd_peer_spoke(const tal_t *ctx UNNEEDED, const void *p UNNEEDED, struct node_id *id UNNEEDED, u64 *counter UNNEEDED, u16 *msgtype UNNEEDED, struct channel_id *channel_id UNNEEDED, wirestring **error UNNEEDED)
{ fprintf(stderr, "fromwire_connectd_peer_spoke called!\n"); abort(); }
/* Generated stub for fromwire_dualopend_dev_memleak_reply */
bool fromwire_dualopend_dev_memleak_reply(const void *p UNNEEDED, bool *leak UNNEEDED)
{ fprintf(stderr, "fromwire_dualopend_dev_memleak_reply called!\n"); abort(); }
/* Generated stub for fromwire_hsmd_preapprove_invoice_check_reply */
bool fromwire_hsmd_preapprove_invoice_check_reply(const void *p UNNEEDED, bool *approved UNNEEDED)
{ fprintf(stderr, "fromwire_hsmd_preapprove_invoice_check_reply called!\n"); abort(); }
/* Generated stub for fromwire_hsmd_preapprove_invoice_reply */
bool fromwire_hsmd_preapprove_invoice_reply(const void *p UNNEEDED, bool *approved UNNEEDED)
{ fprintf(stderr, "fromwire_hsmd_preapprove_invoice_reply called!\n"); abort(); }
/* Generated stub for fromwire_hsmd_preapprove_keysend_check_reply */
bool fromwire_hsmd_preapprove_keysend_check_reply(const void *p UNNEEDED, bool *approved UNNEEDED)
{ fprintf(stderr, "fromwire_hsmd_preapprove_keysend_check_reply called!\n"); abort(); }
/* Generated stub for fromwire_hsmd_preapprove_keysend_reply */
bool fromwire_hsmd_preapprove_keysend_reply(const void *p UNNEEDED, bool *approved UNNEEDED)
{ fprintf(stderr, "fromwire_hsmd_preapprove_keysend_reply called!\n"); abort(); }
/* Generated stub for fromwire_hsmd_sign_bolt12_reply */
bool fromwire_hsmd_sign_bolt12_reply(const void *p UNNEEDED, struct bip340sig *sig UNNEEDED)
{ fprintf(stderr, "fromwire_hsmd_sign_bolt12_reply called!\n"); abort(); }
/* Generated stub for fromwire_hsmd_sign_commitment_tx_reply */
bool fromwire_hsmd_sign_commitment_tx_reply(const void *p UNNEEDED, struct bitcoin_signature *sig UNNEEDED)
{ fprintf(stderr, "fromwire_hsmd_sign_commitment_tx_reply called!\n"); abort(); }
/* Generated stub for fromwire_hsmd_sign_invoice_reply */
bool fromwire_hsmd_sign_invoice_reply(const void *p UNNEEDED, secp256k1_ecdsa_recoverable_signature *sig UNNEEDED)
{ fprintf(stderr, "fromwire_hsmd_sign_invoice_reply called!\n"); abort(); }
/* Generated stub for fromwire_onchaind_dev_memleak_reply */
bool fromwire_onchaind_dev_memleak_reply(const void *p UNNEEDED, bool *leak UNNEEDED)
{ fprintf(stderr, "fromwire_onchaind_dev_memleak_reply called!\n"); abort(); }
/* Generated stub for fromwire_openingd_dev_memleak_reply */
bool fromwire_openingd_dev_memleak_reply(const void *p UNNEEDED, bool *leak UNNEEDED)
{ fprintf(stderr, "fromwire_openingd_dev_memleak_reply called!\n"); abort(); }
/* Generated stub for get_block_height */
u32 get_block_height(const struct chain_topology *topo UNNEEDED)
{ fprintf(stderr, "get_block_height called!\n"); abort(); }
/* Generated stub for hash_cid */
size_t hash_cid(const struct channel_id *cid UNNEEDED)
{ fprintf(stderr, "hash_cid called!\n"); abort(); }
/* Generated stub for hash_htlc_key */
size_t hash_htlc_key(const struct htlc_key *htlc_key UNNEEDED)
{ fprintf(stderr, "hash_htlc_key called!\n"); abort(); }
/* Generated stub for hsm_capable */
bool hsm_capable(struct lightningd *ld UNNEEDED, u32 msgtype UNNEEDED)
{ fprintf(stderr, "hsm_capable called!\n"); abort(); }
/* Generated stub for hsm_sync_req */
const u8 *hsm_sync_req(const tal_t *ctx UNNEEDED,
		       struct lightningd *ld UNNEEDED,
		       const u8 *msg TAKES UNNEEDED)
{ fprintf(stderr, "hsm_sync_req called!\n"); abort(); }
/* Generated stub for htlc_max_possible_send */
struct amount_msat htlc_max_possible_send(const struct channel *channel UNNEEDED)
{ fprintf(stderr, "htlc_max_possible_send called!\n"); abort(); }
/* Generated stub for htlc_set_fail_ */
void htlc_set_fail_(struct htlc_set *set UNNEEDED, const u8 *failmsg TAKES UNNEEDED,
		    const char *file UNNEEDED, int line UNNEEDED)
{ fprintf(stderr, "htlc_set_fail_ called!\n"); abort(); }
/* Generated stub for htlc_set_fulfill */
void htlc_set_fulfill(struct htlc_set *set UNNEEDED, const struct preimage *preimage UNNEEDED)
{ fprintf(stderr, "htlc_set_fulfill called!\n"); abort(); }
/* Generated stub for invoices_create */
bool invoices_create(struct invoices *invoices UNNEEDED,
		     u64 *inv_dbid UNNEEDED,
		     const struct amount_msat *msat TAKES UNNEEDED,
		     const struct json_escape *label TAKES UNNEEDED,
		     u64 expiry UNNEEDED,
		     const char *b11enc UNNEEDED,
		     const char *description UNNEEDED,
		     const u8 *features UNNEEDED,
		     const struct preimage *r UNNEEDED,
		     const struct sha256 *rhash UNNEEDED,
		     const struct sha256 *local_offer_id UNNEEDED)
{ fprintf(stderr, "invoices_create called!\n"); abort(); }
/* Generated stub for invoices_create_fallback */
void invoices_create_fallback(struct invoices *invoices UNNEEDED,
			      u64 inv_dbid UNNEEDED,
			      const u8 *scriptPubkey UNNEEDED)
{ fprintf(stderr, "invoices_create_fallback called!\n"); abort(); }
/* Generated stub for invoices_delete */
bool invoices_delete(struct invoices *invoices UNNEEDED,
		     u64 inv_dbid UNNEEDED,
		     enum invoice_status status UNNEEDED,
		     const struct json_escape *label UNNEEDED,
		     const char *invstring UNNEEDED)
{ fprintf(stderr, "invoices_delete called!\n"); abort(); }
/* Generated stub for invoices_delete_description */
bool invoices_delete_description(struct invoices *invoices UNNEEDED,
				 u64 inv_dbid UNNEEDED,
				 const struct json_escape *label UNNEEDED,
				 const char *description UNNEEDED)
{ fprintf(stderr, "invoices_delete_description called!\n"); abort(); }
/* Generated stub for invoices_find_by_fallback_script */
bool invoices_find_by_fallback_script(struct invoices *invoices UNNEEDED,
			    u64 *inv_dbid UNNEEDED,
			    const u8 *scriptPubkey UNNEEDED)
{ fprintf(stderr, "invoices_find_by_fallback_script called!\n"); abort(); }
/* Generated stub for invoices_find_by_label */
bool invoices_find_by_label(struct invoices *invoices UNNEEDED,
			    u64 *inv_dbid UNNEEDED,
			    const struct json_escape *label UNNEEDED)
{ fprintf(stderr, "invoices_find_by_label called!\n"); abort(); }
/* Generated stub for invoices_find_by_rhash */
bool invoices_find_by_rhash(struct invoices *invoices UNNEEDED,
			    u64 *inv_dbid UNNEEDED,
			    const struct sha256 *rhash UNNEEDED)
{ fprintf(stderr, "invoices_find_by_rhash called!\n"); abort(); }
/* Generated stub for invoices_find_unpaid */
bool invoices_find_unpaid(struct invoices *invoices UNNEEDED,
			  u64 *inv_dbid UNNEEDED,
			  const struct sha256 *rhash UNNEEDED)
{ fprintf(stderr, "invoices_find_unpaid called!\n"); abort(); }
/* Generated stub for invoices_first */
struct db_stmt *invoices_first(struct invoices *invoices UNNEEDED,
			       const enum wait_index *listindex UNNEEDED,
			       u64 liststart UNNEEDED,
			       const u32 *listlimit UNNEEDED,
			       u64 *inv_dbid UNNEEDED)
{ fprintf(stderr, "invoices_first called!\n"); abort(); }
/* Generated stub for invoices_get_details */
struct invoice_details *invoices_get_details(const tal_t *ctx UNNEEDED,
					     struct invoices *invoices UNNEEDED,
					     u64 inv_dbid UNNEEDED)
{ fprintf(stderr, "invoices_get_details called!\n"); abort(); }
/* Generated stub for invoices_next */
struct db_stmt *invoices_next(struct invoices *invoices UNNEEDED,
			      struct db_stmt *stmt UNNEEDED,
			      u64 *inv_dbid UNNEEDED)
{ fprintf(stderr, "invoices_next called!\n"); abort(); }
/* Generated stub for invoices_resolve */
bool invoices_resolve(struct invoices *invoices UNNEEDED,
		      u64 inv_dbid UNNEEDED,
		      struct amount_msat received UNNEEDED,
		      const struct json_escape *label UNNEEDED,
		      const struct bitcoin_outpoint *outpoint UNNEEDED)
{ fprintf(stderr, "invoices_resolve called!\n"); abort(); }
/* Generated stub for invoices_waitany */
void invoices_waitany(const tal_t *ctx UNNEEDED,
		      struct invoices *invoices UNNEEDED,
		      u64 lastpay_index UNNEEDED,
		      void (*cb)(const u64 * UNNEEDED, void*) UNNEEDED,
		      void *cbarg UNNEEDED)
{ fprintf(stderr, "invoices_waitany called!\n"); abort(); }
/* Generated stub for invoices_waitone */
void invoices_waitone(const tal_t *ctx UNNEEDED,
		      struct invoices *invoices UNNEEDED,
		      u64 inv_dbid UNNEEDED,
		      void (*cb)(const u64 * UNNEEDED, void*) UNNEEDED,
		      void *cbarg UNNEEDED)
{ fprintf(stderr, "invoices_waitone called!\n"); abort(); }
/* Generated stub for json_add_log */
void json_add_log(struct json_stream *result UNNEEDED,
		  const struct log_book *log_book UNNEEDED,
		  const struct node_id *node_id UNNEEDED,
		  enum log_level minlevel UNNEEDED)
{ fprintf(stderr, "json_add_log called!\n"); abort(); }
/* Generated stub for json_add_uncommitted_channel */
void  json_add_uncommitted_channel(struct command *cmd UNNEEDED,
						      struct json_stream *response UNNEEDED,
						      const struct uncommitted_channel *uc UNNEEDED,
						      const struct peer *peer UNNEEDED)
{ fprintf(stderr, "json_add_uncommitted_channel called!\n"); abort(); }
/* Generated stub for json_add_unsaved_channel */
void  json_add_unsaved_channel(struct command *cmd UNNEEDED,
					   struct json_stream *response UNNEEDED,
					   const struct channel *channel UNNEEDED,
					   const struct peer *peer UNNEEDED)
{ fprintf(stderr, "json_add_unsaved_channel called!\n"); abort(); }
/* Generated stub for json_stream_fail */
struct json_stream *json_stream_fail(struct command *cmd UNNEEDED,
				     enum jsonrpc_errcode code UNNEEDED,
				     const char *errmsg UNNEEDED)
{ fprintf(stderr, "json_stream_fail called!\n"); abort(); }
/* Generated stub for json_stream_success */
struct json_stream *json_stream_success(struct command *cmd UNNEEDED)
{ fprintf(stderr, "json_stream_success called!\n"); abort(); }
/* Generated stub for jsonrpc_request_end */
void jsonrpc_request_end(struct jsonrpc_request *request UNNEEDED)
{ fprintf(stderr, "jsonrpc_request_end called!\n"); abort(); }
/* Generated stub for jsonrpc_request_start_ */
struct jsonrpc_request *jsonrpc_request_start_(
    const tal_t *ctx UNNEEDED, const char *method UNNEEDED,
    const char *id_prefix TAKES UNNEEDED,
    struct logger *log UNNEEDED, bool add_header UNNEEDED,
    void (*notify_cb)(const char *buffer UNNEEDED,
		      const jsmntok_t *idtok UNNEEDED,
		      const jsmntok_t *methodtok UNNEEDED,
		      const jsmntok_t *paramtoks UNNEEDED,
		      void *) UNNEEDED,
    void (*response_cb)(const char *buffer UNNEEDED, const jsmntok_t *toks UNNEEDED,
			const jsmntok_t *idtok UNNEEDED, void *) UNNEEDED,
    void *response_cb_arg UNNEEDED)
{ fprintf(stderr, "jsonrpc_request_start_ called!\n"); abort(); }
/* Generated stub for kill_uncommitted_channel */
void kill_uncommitted_channel(struct uncommitted_channel *uc UNNEEDED,
			      const char *why UNNEEDED)
{ fprintf(stderr, "kill_uncommitted_channel called!\n"); abort(); }
/* Generated stub for local_fail_in_htlc */
void local_fail_in_htlc(struct htlc_in *hin UNNEEDED, const u8 *failmsg TAKES UNNEEDED)
{ fprintf(stderr, "local_fail_in_htlc called!\n"); abort(); }
/* Generated stub for lockin_complete */
void lockin_complete(struct channel *channel UNNEEDED,
		     enum channel_state expected_state UNNEEDED)
{ fprintf(stderr, "lockin_complete called!\n"); abort(); }
/* Generated stub for log_ */
void log_(struct logger *logger UNNEEDED, enum log_level level UNNEEDED,
	  const struct node_id *node_id UNNEEDED,
	  bool call_notifier UNNEEDED,
	  const char *fmt UNNEEDED, ...)

{ fprintf(stderr, "log_ called!\n"); abort(); }
/* Generated stub for new_peer_fd */
struct peer_fd *new_peer_fd(const tal_t *ctx UNNEEDED, int peer_fd UNNEEDED)
{ fprintf(stderr, "new_peer_fd called!\n"); abort(); }
/* Generated stub for new_uncommitted_channel */
struct uncommitted_channel *new_uncommitted_channel(struct peer *peer UNNEEDED)
{ fprintf(stderr, "new_uncommitted_channel called!\n"); abort(); }
/* Generated stub for new_unsaved_channel */
struct channel *new_unsaved_channel(struct peer *peer UNNEEDED,
				    u32 feerate_base UNNEEDED,
				    u32 feerate_ppm UNNEEDED)
{ fprintf(stderr, "new_unsaved_channel called!\n"); abort(); }
/* Generated stub for newaddr_inner */
bool  newaddr_inner(struct command *cmd UNNEEDED, struct pubkey *pubkey UNNEEDED,
				      enum addrtype addrtype UNNEEDED)
{ fprintf(stderr, "newaddr_inner called!\n"); abort(); }
/* Generated stub for notify_connect */
void notify_connect(struct lightningd *ld UNNEEDED,
		    const struct node_id *nodeid UNNEEDED,
		    bool incoming UNNEEDED,
		    const struct wireaddr_internal *addr UNNEEDED)
{ fprintf(stderr, "notify_connect called!\n"); abort(); }
/* Generated stub for notify_disconnect */
void notify_disconnect(struct lightningd *ld UNNEEDED, const struct node_id *nodeid UNNEEDED)
{ fprintf(stderr, "notify_disconnect called!\n"); abort(); }
/* Generated stub for notify_invoice_creation */
void notify_invoice_creation(struct lightningd *ld UNNEEDED,
			     const struct amount_msat *amount UNNEEDED,
			     const struct preimage *preimage UNNEEDED,
			     const struct json_escape *label UNNEEDED)
{ fprintf(stderr, "notify_invoice_creation called!\n"); abort(); }
/* Generated stub for notify_invoice_payment */
void notify_invoice_payment(struct lightningd *ld UNNEEDED,
			    struct amount_msat amount UNNEEDED,
			    const struct preimage *preimage UNNEEDED,
			    const struct json_escape *label UNNEEDED,
			    const struct bitcoin_outpoint *outpoint UNNEEDED)
{ fprintf(stderr, "notify_invoice_payment called!\n"); abort(); }
/* Generated stub for onchaind_funding_spent */
enum watch_result onchaind_funding_spent(struct channel *channel UNNEEDED,
					 const struct bitcoin_tx *tx UNNEEDED,
					 u32 blockheight UNNEEDED)
{ fprintf(stderr, "onchaind_funding_spent called!\n"); abort(); }
/* Generated stub for param_index */
struct command_result *param_index(struct command *cmd UNNEEDED, const char *name UNNEEDED,
				   const char *buffer UNNEEDED,
				   const jsmntok_t *tok UNNEEDED,
				   enum wait_index **index UNNEEDED)
{ fprintf(stderr, "param_index called!\n"); abort(); }
/* Generated stub for param_loglevel */
struct command_result *param_loglevel(struct command *cmd UNNEEDED,
				      const char *name UNNEEDED,
				      const char *buffer UNNEEDED,
				      const jsmntok_t *tok UNNEEDED,
				      enum log_level **level UNNEEDED)
{ fprintf(stderr, "param_loglevel called!\n"); abort(); }
/* Generated stub for peer_any_channel_bystate */
struct channel *peer_any_channel_bystate(struct peer *peer UNNEEDED,
					 bool (*channel_state_filter)(enum channel_state) UNNEEDED,
					 bool *others UNNEEDED)
{ fprintf(stderr, "peer_any_channel_bystate called!\n"); abort(); }
/* Generated stub for peer_restart_dualopend */
bool peer_restart_dualopend(struct peer *peer UNNEEDED,
			    struct peer_fd *peer_fd UNNEEDED,
			    struct channel *channel UNNEEDED,
			    bool from_abort UNNEEDED)
{ fprintf(stderr, "peer_restart_dualopend called!\n"); abort(); }
/* Generated stub for peer_start_channeld */
bool peer_start_channeld(struct channel *channel UNNEEDED,
			 struct peer_fd *peer_fd UNNEEDED,
			 const u8 *fwd_msg UNNEEDED,
			 bool reconnected UNNEEDED)
{ fprintf(stderr, "peer_start_channeld called!\n"); abort(); }
/* Generated stub for peer_start_dualopend */
bool peer_start_dualopend(struct peer *peer UNNEEDED, struct peer_fd *peer_fd UNNEEDED,
			  struct channel *channel UNNEEDED)
{ fprintf(stderr, "peer_start_dualopend called!\n"); abort(); }
/* Generated stub for peer_start_openingd */
bool peer_start_openingd(struct peer *peer UNNEEDED,
			 struct peer_fd *peer_fd UNNEEDED)
{ fprintf(stderr, "peer_start_openingd called!\n"); abort(); }
/* Generated stub for plugin_hook_call_ */
bool plugin_hook_call_(struct lightningd *ld UNNEEDED,
		       const struct plugin_hook *hook UNNEEDED,
		       const char *cmd_id TAKES UNNEEDED,
		       tal_t *cb_arg STEALS UNNEEDED)
{ fprintf(stderr, "plugin_hook_call_ called!\n"); abort(); }
/* Generated stub for plugin_request_send */
void plugin_request_send(struct plugin *plugin UNNEEDED,
			 struct jsonrpc_request *req UNNEEDED)
{ fprintf(stderr, "plugin_request_send called!\n"); abort(); }
/* Generated stub for report_subd_memleak */
void report_subd_memleak(struct leak_detect *leak_detect UNNEEDED, struct subd *leaker UNNEEDED)
{ fprintf(stderr, "report_subd_memleak called!\n"); abort(); }
/* Generated stub for resolve_close_command */
void resolve_close_command(struct lightningd *ld UNNEEDED, struct channel *channel UNNEEDED,
			   bool cooperative UNNEEDED, const struct bitcoin_tx **close_txs UNNEEDED)
{ fprintf(stderr, "resolve_close_command called!\n"); abort(); }
/* Generated stub for start_leak_request */
void start_leak_request(const struct subd_req *req UNNEEDED,
			struct leak_detect *leak_detect UNNEEDED)
{ fprintf(stderr, "start_leak_request called!\n"); abort(); }
/* Generated stub for subd_req_ */
struct subd_req *subd_req_(const tal_t *ctx UNNEEDED,
	       struct subd *sd UNNEEDED,
	       const u8 *msg_out UNNEEDED,
	       int fd_out UNNEEDED, size_t num_fds_in UNNEEDED,
	       void (*replycb)(struct subd * UNNEEDED, const u8 * UNNEEDED, const int * UNNEEDED, void *) UNNEEDED,
	       void *replycb_data TAKES UNNEEDED)
{ fprintf(stderr, "subd_req_ called!\n"); abort(); }
/* Generated stub for subd_send_fd */
void subd_send_fd(struct subd *sd UNNEEDED, int fd UNNEEDED)
{ fprintf(stderr, "subd_send_fd called!\n"); abort(); }
/* Generated stub for subd_send_msg */
void subd_send_msg(struct subd *sd UNNEEDED, const u8 *msg_out UNNEEDED)
{ fprintf(stderr, "subd_send_msg called!\n"); abort(); }
/* Generated stub for towire_channeld_dev_memleak */
u8 *towire_channeld_dev_memleak(const tal_t *ctx UNNEEDED)
{ fprintf(stderr, "towire_channeld_dev_memleak called!\n"); abort(); }
/* Generated stub for towire_channeld_dev_reenable_commit */
u8 *towire_channeld_dev_reenable_commit(const tal_t *ctx UNNEEDED)
{ fprintf(stderr, "towire_channeld_dev_reenable_commit called!\n"); abort(); }
/* Generated stub for towire_connectd_disconnect_peer */
u8 *towire_connectd_disconnect_peer(const tal_t *ctx UNNEEDED, const struct node_id *id UNNEEDED, u64 counter UNNEEDED)
{ fprintf(stderr, "towire_connectd_disconnect_peer called!\n"); abort(); }
/* Generated stub for towire_connectd_peer_connect_subd */
u8 *towire_connectd_peer_connect_subd(const tal_t *ctx UNNEEDED, const struct node_id *id UNNEEDED, u64 counter UNNEEDED, const struct channel_id *channel_id UNNEEDED)
{ fprintf(stderr, "towire_connectd_peer_connect_subd called!\n"); abort(); }
/* Generated stub for towire_connectd_peer_send_msg */
u8 *towire_connectd_peer_send_msg(const tal_t *ctx UNNEEDED, const struct node_id *id UNNEEDED, u64 counter UNNEEDED, const u8 *msg UNNEEDED)
{ fprintf(stderr, "towire_connectd_peer_send_msg called!\n"); abort(); }
/* Generated stub for towire_dualopend_dev_memleak */
u8 *towire_dualopend_dev_memleak(const tal_t *ctx UNNEEDED)
{ fprintf(stderr, "towire_dualopend_dev_memleak called!\n"); abort(); }
/* Generated stub for towire_hsmd_preapprove_invoice */
u8 *towire_hsmd_preapprove_invoice(const tal_t *ctx UNNEEDED, const wirestring *invstring UNNEEDED)
{ fprintf(stderr, "towire_hsmd_preapprove_invoice called!\n"); abort(); }
/* Generated stub for towire_hsmd_preapprove_invoice_check */
u8 *towire_hsmd_preapprove_invoice_check(const tal_t *ctx UNNEEDED, const wirestring *invstring UNNEEDED, bool check_only UNNEEDED)
{ fprintf(stderr, "towire_hsmd_preapprove_invoice_check called!\n"); abort(); }
/* Generated stub for towire_hsmd_preapprove_keysend */
u8 *towire_hsmd_preapprove_keysend(const tal_t *ctx UNNEEDED, const struct node_id *destination UNNEEDED, const struct sha256 *payment_hash UNNEEDED, struct amount_msat amount_msat UNNEEDED)
{ fprintf(stderr, "towire_hsmd_preapprove_keysend called!\n"); abort(); }
/* Generated stub for towire_hsmd_preapprove_keysend_check */
u8 *towire_hsmd_preapprove_keysend_check(const tal_t *ctx UNNEEDED, const struct node_id *destination UNNEEDED, const struct sha256 *payment_hash UNNEEDED, struct amount_msat amount_msat UNNEEDED, bool check_only UNNEEDED)
{ fprintf(stderr, "towire_hsmd_preapprove_keysend_check called!\n"); abort(); }
/* Generated stub for towire_hsmd_sign_bolt12 */
u8 *towire_hsmd_sign_bolt12(const tal_t *ctx UNNEEDED, const wirestring *messagename UNNEEDED, const wirestring *fieldname UNNEEDED, const struct sha256 *merkleroot UNNEEDED, const u8 *publictweak UNNEEDED)
{ fprintf(stderr, "towire_hsmd_sign_bolt12 called!\n"); abort(); }
/* Generated stub for towire_hsmd_sign_commitment_tx */
u8 *towire_hsmd_sign_commitment_tx(const tal_t *ctx UNNEEDED, const struct node_id *peer_id UNNEEDED, u64 channel_dbid UNNEEDED, const struct bitcoin_tx *tx UNNEEDED, const struct pubkey *remote_funding_key UNNEEDED, u64 commit_num UNNEEDED)
{ fprintf(stderr, "towire_hsmd_sign_commitment_tx called!\n"); abort(); }
/* Generated stub for towire_hsmd_sign_invoice */
u8 *towire_hsmd_sign_invoice(const tal_t *ctx UNNEEDED, const u8 *u5bytes UNNEEDED, const u8 *hrp UNNEEDED)
{ fprintf(stderr, "towire_hsmd_sign_invoice called!\n"); abort(); }
/* Generated stub for towire_onchaind_dev_memleak */
u8 *towire_onchaind_dev_memleak(const tal_t *ctx UNNEEDED)
{ fprintf(stderr, "towire_onchaind_dev_memleak called!\n"); abort(); }
/* Generated stub for towire_openingd_dev_memleak */
u8 *towire_openingd_dev_memleak(const tal_t *ctx UNNEEDED)
{ fprintf(stderr, "towire_openingd_dev_memleak called!\n"); abort(); }
/* Generated stub for wallet_channel_save */
void wallet_channel_save(struct wallet *w UNNEEDED, struct channel *chan UNNEEDED)
{ fprintf(stderr, "wallet_channel_save called!\n"); abort(); }
/* Generated stub for wallet_delete_peer_if_unused */
void wallet_delete_peer_if_unused(struct wallet *w UNNEEDED, u64 peer_dbid UNNEEDED)
{ fprintf(stderr, "wallet_delete_peer_if_unused called!\n"); abort(); }
/* Generated stub for wallet_extract_owned_outputs */
int wallet_extract_owned_outputs(struct wallet *w UNNEEDED, const struct wally_tx *tx UNNEEDED,
				 bool is_coinbase UNNEEDED,
				 const u32 *blockheight UNNEEDED)
{ fprintf(stderr, "wallet_extract_owned_outputs called!\n"); abort(); }
/* Generated stub for wallet_htlcs_load_in_for_channel */
bool wallet_htlcs_load_in_for_channel(struct wallet *wallet UNNEEDED,
				      struct channel *chan UNNEEDED,
				      struct htlc_in_map *htlcs_in UNNEEDED)
{ fprintf(stderr, "wallet_htlcs_load_in_for_channel called!\n"); abort(); }
/* Generated stub for wallet_htlcs_load_out_for_channel */
bool wallet_htlcs_load_out_for_channel(struct wallet *wallet UNNEEDED,
				       struct channel *chan UNNEEDED,
				       struct htlc_out_map *htlcs_out UNNEEDED,
				       struct htlc_in_map *remaining_htlcs_in UNNEEDED)
{ fprintf(stderr, "wallet_htlcs_load_out_for_channel called!\n"); abort(); }
/* Generated stub for wallet_init_channels */
bool wallet_init_channels(struct wallet *w UNNEEDED)
{ fprintf(stderr, "wallet_init_channels called!\n"); abort(); }
/* Generated stub for wallet_insert_funding_spend */
void wallet_insert_funding_spend(struct wallet *w UNNEEDED,
				 const struct channel *chan UNNEEDED,
				 const struct bitcoin_txid *txid UNNEEDED,
				 const u32 input_num UNNEEDED, const u32 blockheight UNNEEDED)
{ fprintf(stderr, "wallet_insert_funding_spend called!\n"); abort(); }
/* Generated stub for wallet_offer_find */
char *wallet_offer_find(const tal_t *ctx UNNEEDED,
			struct wallet *w UNNEEDED,
			const struct sha256 *offer_id UNNEEDED,
			const struct json_escape **label UNNEEDED,
			enum offer_status *status)

{ fprintf(stderr, "wallet_offer_find called!\n"); abort(); }
/* Generated stub for wallet_total_forward_fees */
struct amount_msat wallet_total_forward_fees(struct wallet *w UNNEEDED)
{ fprintf(stderr, "wallet_total_forward_fees called!\n"); abort(); }
/* Generated stub for wallet_transaction_add */
void wallet_transaction_add(struct wallet *w UNNEEDED, const struct wally_tx *tx UNNEEDED,
			    const u32 blockheight UNNEEDED, const u32 txindex UNNEEDED)
{ fprintf(stderr, "wallet_transaction_add called!\n"); abort(); }
/* Generated stub for wallet_transaction_height */
u32 wallet_transaction_height(struct wallet *w UNNEEDED, const struct bitcoin_txid *txid UNNEEDED)
{ fprintf(stderr, "wallet_transaction_height called!\n"); abort(); }
/* Generated stub for watch_opening_inflight */
void watch_opening_inflight(struct lightningd *ld UNNEEDED,
			    struct channel_inflight *inflight UNNEEDED)
{ fprintf(stderr, "watch_opening_inflight called!\n"); abort(); }
/* Generated stub for watch_splice_inflight */
void watch_splice_inflight(struct lightningd *ld UNNEEDED,
			   struct channel_inflight *inflight UNNEEDED)
{ fprintf(stderr, "watch_splice_inflight called!\n"); abort(); }
/* Generated stub for watch_txid_ */
struct txwatch *watch_txid_(const tal_t *ctx UNNEEDED,
			    struct chain_topology *topo UNNEEDED,
			    const struct bitcoin_txid *txid UNNEEDED,
			    enum watch_result (*cb)(struct lightningd *ld UNNEEDED,
						    const struct bitcoin_txid * UNNEEDED,
						    const struct bitcoin_tx * UNNEEDED,
						    unsigned int depth UNNEEDED,
						    void *arg) UNNEEDED,
			    void *arg UNNEEDED)
{ fprintf(stderr, "watch_txid_ called!\n"); abort(); }
/* Generated stub for watch_txo */
struct txowatch *watch_txo(const tal_t *ctx UNNEEDED,
			   struct chain_topology *topo UNNEEDED,
			   struct channel *channel UNNEEDED,
			   const struct bitcoin_outpoint *outpoint UNNEEDED,
			   enum watch_result (*cb)(struct channel * UNNEEDED,
						   const struct bitcoin_tx *tx UNNEEDED,
						   size_t input_num UNNEEDED,
						   const struct block *block))
{ fprintf(stderr, "watch_txo called!\n"); abort(); }
/* AUTOGENERATED MOCKS END */

static void add_candidate(struct routehint_candidate **candidates, int n,
			  struct channel *c)
{
	struct routehint_candidate candidate;

	candidate.r = tal(*candidates, struct route_info);
	memset(&candidate.r->pubkey, n, sizeof(candidate.r->pubkey));
	memset(&candidate.r->short_channel_id, n,
	       sizeof(candidate.r->short_channel_id));
	candidate.r->fee_base_msat
		= candidate.r->fee_proportional_millionths
		= candidate.r->cltv_expiry_delta
		= n;
	candidate.c = c;
	candidate.capacity = amount_msat(n * 1000 - 1);
	tal_arr_expand(candidates, candidate);
}

static struct channel *add_peer(struct lightningd *ld, int n,
				enum channel_state state,
				bool connected)
{
	struct peer *peer = tal(ld, struct peer);
	struct channel *c = tal(peer, struct channel);

	memset(&peer->id, n, sizeof(peer->id));
	list_head_init(&peer->channels);
	peer_node_id_map_add(ld->peers, peer);
	peer->ld = ld;

	c->state = state;
	c->owner = connected ? (void *)peer : NULL;
	c->opener = LOCAL;
	c->peer = peer;
	/* Channel has incoming capacity n*1000 - 1 millisatoshi */
	c->funding_sats.satoshis = n+1;
	c->our_msat = AMOUNT_MSAT(1);
	c->our_config.channel_reserve = AMOUNT_SAT(1);
	c->our_config.htlc_minimum = AMOUNT_MSAT(0);
	c->channel_info.their_config.channel_reserve = AMOUNT_SAT(0);
	list_add_tail(&peer->channels, &c->list);

	return c;
}

/* There *is* padding in this structure, after pubkey and after cltv_expiry_delta. */
STRUCTEQ_DEF(route_info,
	     ALIGNOF(struct short_channel_id) - 1 - sizeof(u16),
	     pubkey,
	     cltv_expiry_delta,
	     short_channel_id,
	     fee_base_msat,
	     fee_proportional_millionths);

int main(int argc, char *argv[])
{
	struct lightningd *ld;
	struct routehint_candidate *candidates;
	struct route_info **ret;
	size_t n;

	common_setup(argv[0]);
	ld = tal(tmpctx, struct lightningd);

	ld->peers = tal(ld, struct peer_node_id_map);
	peer_node_id_map_init(ld->peers);
	ld->htlcs_in = tal(ld, struct htlc_in_map);
	htlc_in_map_init(ld->htlcs_in);
	chainparams = chainparams_for_network("regtest");

	candidates = tal_arr(tmpctx, struct routehint_candidate, 0);

	/* 1. Nothing to choose from -> NULL result. */
	ret = select_inchan(tmpctx, ld, AMOUNT_MSAT(0), candidates);
	assert(tal_count(ret) == 0);

	/* 2. One peer (999 msat capacity) */
	add_candidate(&candidates, 1, add_peer(ld, 1, CHANNELD_NORMAL, true));
	ret = select_inchan(tmpctx, ld, AMOUNT_MSAT(1000), candidates);
	assert(tal_count(ret) == 0);

	ret = select_inchan(tmpctx, ld, AMOUNT_MSAT(999), candidates);
	assert(tal_count(ret) == 1);
	assert(tal_count(ret[0]) == 1);
	assert(route_info_eq(ret[0], candidates[0].r));

	/* 3. Two peers (999 msat capacity and 1999 msat) */
	add_candidate(&candidates, 2, add_peer(ld, 2, CHANNELD_NORMAL, true));

	ret = select_inchan(tmpctx, ld, AMOUNT_MSAT(1000), candidates);
	assert(tal_count(ret) == 1);
	assert(tal_count(ret[0]) == 1);
	assert(route_info_eq(ret[0], candidates[1].r));

	/* 7. Correct peer with just enough capacity_to_pay_us */
	ret = select_inchan(tmpctx, ld, AMOUNT_MSAT(1999), candidates);
	assert(tal_count(ret) == 1);
	assert(tal_count(ret[0]) == 1);
	assert(route_info_eq(ret[0], candidates[1].r));

	/* 8. Not if we ask for too much! Our balance is 1msat. */
	ret = select_inchan(tmpctx, ld, AMOUNT_MSAT(2000), candidates);
	assert(tal_count(ret) == 0);

	/* 9. Add another peer (2999 capacity) */
	add_candidate(&candidates, 3, add_peer(ld, 3, CHANNELD_NORMAL, true));

	/* Simulate selection ratios between excesses 25% and 50% of capacity*/
	for (size_t i = n = 0; i < 1000; i++) {
		ret = select_inchan(tmpctx, ld, AMOUNT_MSAT(1499), candidates);
		assert(tal_count(ret) == 1);
		assert(tal_count(ret[0]) == 1);
		assert(route_info_eq(ret[0], candidates[1].r)
		       || route_info_eq(ret[0], candidates[2].r));
		n += route_info_eq(ret[0], candidates[1].r);
	}

	/* Handwave over probability of this happening!  Within 20% */
	printf("Number of selections with excess 25 percent of capacity: %zu\n"
	       "Number of selections with excess 50 percent of capacity: %zu\n",
	       n, 1000 - n);
	assert(n > 333 - 66 && n < 333 + 66);

	/* 10. Last peer's capacity goes from 3 to 2 sat */
	candidates[2].c->channel_info.their_config.channel_reserve = AMOUNT_SAT(1);

	for (size_t i = n = 0; i < 1000; i++) {
		ret = select_inchan(tmpctx, ld, AMOUNT_MSAT(1499), candidates);
		assert(tal_count(ret) == 1);
		assert(tal_count(ret[0]) == 1);
		assert(route_info_eq(ret[0], candidates[1].r)
		       || route_info_eq(ret[0], candidates[2].r));
		n += route_info_eq(ret[0], candidates[1].r);
	}

	/* Handwave over probability of this happening!  Within 20% */
	printf("Number of selections with excess 25 percent of capacity: %zu\n"
	       "Number of selections with excess 75 percent of capacity: %zu\n",
	       n, 1000 - n);
	assert(n > 250 - 50 && n < 250 + 50);

	common_shutdown();

	/* FIXME: Do BOLT comparison! */
	return 0;
}
