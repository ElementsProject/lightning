#include "config.h"
#include "../invoice.c"
#include "../peer_control.c"
#include "../routehint.c"
#include <ccan/alignof/alignof.h>
#include <common/errcode.h>
#include <common/setup.h>
#include <stdio.h>

/* AUTOGENERATED MOCKS START */
/* Generated stub for any_channel_by_scid */
struct channel *any_channel_by_scid(struct lightningd *ld UNNEEDED,
				    const struct short_channel_id *scid UNNEEDED,
				    bool privacy_leak_ok UNNEEDED)
{ fprintf(stderr, "any_channel_by_scid called!\n"); abort(); }
/* Generated stub for param_invstring */
struct command_result *param_invstring(struct command *cmd, const char *name,
				    const char * buffer, const jsmntok_t *tok,
				    const char **str)
{ fprintf(stderr, "param_invstring called!\n"); abort(); }
/* Generated stub for bip32_pubkey */
void bip32_pubkey(struct lightningd *ld UNNEEDED, struct pubkey *pubkey UNNEEDED, u32 index UNNEEDED)
{ fprintf(stderr, "bip32_pubkey called!\n"); abort(); }
/* Generated stub for bitcoind_getutxout_ */
void bitcoind_getutxout_(struct bitcoind *bitcoind UNNEEDED,
			 const struct bitcoin_outpoint *outpoint UNNEEDED,
			 void (*cb)(struct bitcoind * UNNEEDED,
				    const struct bitcoin_tx_output * UNNEEDED,
				    void *) UNNEEDED,
			 void *arg UNNEEDED)
{ fprintf(stderr, "bitcoind_getutxout_ called!\n"); abort(); }
/* Generated stub for bolt11_decode */
struct bolt11 *bolt11_decode(const tal_t *ctx UNNEEDED, const char *str UNNEEDED,
			     const struct feature_set *our_features UNNEEDED,
			     const char *description UNNEEDED,
			     const struct chainparams *must_be_chain UNNEEDED,
			     char **fail UNNEEDED)
{ fprintf(stderr, "bolt11_decode called!\n"); abort(); }
/* Generated stub for bolt11_decode_nosig */
struct bolt11 *bolt11_decode_nosig(const tal_t *ctx UNNEEDED, const char *str UNNEEDED,
				   const struct feature_set *our_features UNNEEDED,
				   const char *description UNNEEDED,
				   const struct chainparams *must_be_chain UNNEEDED,
				   struct sha256 *hash UNNEEDED,
				   const u5 **sig UNNEEDED,
				   bool *have_n UNNEEDED,
				   char **fail UNNEEDED)
{ fprintf(stderr, "bolt11_decode_nosig called!\n"); abort(); }
/* Generated stub for bolt11_encode_ */
char *bolt11_encode_(const tal_t *ctx UNNEEDED,
		     const struct bolt11 *b11 UNNEEDED, bool n_field UNNEEDED,
		     bool (*sign)(const u5 *u5bytes UNNEEDED,
				  const u8 *hrpu8 UNNEEDED,
				  secp256k1_ecdsa_recoverable_signature *rsig UNNEEDED,
				  void *arg) UNNEEDED,
		     void *arg UNNEEDED)
{ fprintf(stderr, "bolt11_encode_ called!\n"); abort(); }
/* Generated stub for broadcast_tx_ */
void broadcast_tx_(struct chain_topology *topo UNNEEDED,
		   struct channel *channel UNNEEDED,
		   const struct bitcoin_tx *tx TAKES UNNEEDED,
		   const char *cmd_id UNNEEDED, bool allowhighfees UNNEEDED, u32 minblock UNNEEDED,
		   bool (*finished)(struct channel * UNNEEDED,
				    const struct bitcoin_tx * UNNEEDED,
				    bool success UNNEEDED,
				    const char *err UNNEEDED,
				    void *) UNNEEDED,
		   bool (*refresh)(struct channel * UNNEEDED, const struct bitcoin_tx ** UNNEEDED, void *) UNNEEDED,
		   void *cbarg TAKES UNNEEDED)
{ fprintf(stderr, "broadcast_tx_ called!\n"); abort(); }
/* Generated stub for channel_change_state_reason_str */
const char *channel_change_state_reason_str(enum state_change reason UNNEEDED)
{ fprintf(stderr, "channel_change_state_reason_str called!\n"); abort(); }
/* Generated stub for channel_cleanup_commands */
void channel_cleanup_commands(struct channel *channel UNNEEDED, const char *why UNNEEDED)
{ fprintf(stderr, "channel_cleanup_commands called!\n"); abort(); }
/* Generated stub for channel_fail_forget */
void channel_fail_forget(struct channel *channel UNNEEDED, const char *fmt UNNEEDED, ...)
{ fprintf(stderr, "channel_fail_forget called!\n"); abort(); }
/* Generated stub for channel_fail_permanent */
void channel_fail_permanent(struct channel *channel UNNEEDED,
			    enum state_change reason UNNEEDED,
			    const char *fmt UNNEEDED,
			    ...)
{ fprintf(stderr, "channel_fail_permanent called!\n"); abort(); }
/* Generated stub for channel_fail_transient */
void channel_fail_transient(struct channel *channel UNNEEDED,
			    const char *fmt UNNEEDED, ...)
{ fprintf(stderr, "channel_fail_transient called!\n"); abort(); }
/* Generated stub for channel_has_htlc_in */
struct htlc_in *channel_has_htlc_in(struct channel *channel UNNEEDED)
{ fprintf(stderr, "channel_has_htlc_in called!\n"); abort(); }
/* Generated stub for channel_has_htlc_out */
struct htlc_out *channel_has_htlc_out(struct channel *channel UNNEEDED)
{ fprintf(stderr, "channel_has_htlc_out called!\n"); abort(); }
/* Generated stub for channel_inflight_find */
struct channel_inflight *channel_inflight_find(struct channel *channel UNNEEDED,
					       const struct bitcoin_txid *txid UNNEEDED)
{ fprintf(stderr, "channel_inflight_find called!\n"); abort(); }
/* Generated stub for channel_internal_error */
void channel_internal_error(struct channel *channel UNNEEDED, const char *fmt UNNEEDED, ...)
{ fprintf(stderr, "channel_internal_error called!\n"); abort(); }
/* Generated stub for channel_last_funding_feerate */
u32 channel_last_funding_feerate(const struct channel *channel UNNEEDED)
{ fprintf(stderr, "channel_last_funding_feerate called!\n"); abort(); }
/* Generated stub for channel_set_last_tx */
void channel_set_last_tx(struct channel *channel UNNEEDED,
			 struct bitcoin_tx *tx UNNEEDED,
			 const struct bitcoin_signature *sig UNNEEDED)
{ fprintf(stderr, "channel_set_last_tx called!\n"); abort(); }
/* Generated stub for channel_state_name */
const char *channel_state_name(const struct channel *channel UNNEEDED)
{ fprintf(stderr, "channel_state_name called!\n"); abort(); }
/* Generated stub for channel_state_str */
const char *channel_state_str(enum channel_state state UNNEEDED)
{ fprintf(stderr, "channel_state_str called!\n"); abort(); }
/* Generated stub for channel_tell_depth */
bool channel_tell_depth(struct lightningd *ld UNNEEDED,
				 struct channel *channel UNNEEDED,
				 const struct bitcoin_txid *txid UNNEEDED,
				 u32 depth UNNEEDED)
{ fprintf(stderr, "channel_tell_depth called!\n"); abort(); }
/* Generated stub for channel_type_has */
bool channel_type_has(const struct channel_type *type UNNEEDED, int feature UNNEEDED)
{ fprintf(stderr, "channel_type_has called!\n"); abort(); }
/* Generated stub for channel_type_name */
const char **channel_type_name(const tal_t *ctx UNNEEDED, const struct channel_type *t UNNEEDED)
{ fprintf(stderr, "channel_type_name called!\n"); abort(); }
/* Generated stub for channel_unsaved_close_conn */
void channel_unsaved_close_conn(struct channel *channel UNNEEDED, const char *why UNNEEDED)
{ fprintf(stderr, "channel_unsaved_close_conn called!\n"); abort(); }
/* Generated stub for channel_update_reserve */
void channel_update_reserve(struct channel *channel UNNEEDED,
			    struct channel_config *their_config UNNEEDED,
			    struct amount_sat funding_total UNNEEDED)
{ fprintf(stderr, "channel_update_reserve called!\n"); abort(); }
/* Generated stub for command_fail */
struct command_result *command_fail(struct command *cmd UNNEEDED, enum jsonrpc_errcode code UNNEEDED,
				    const char *fmt UNNEEDED, ...)

{ fprintf(stderr, "command_fail called!\n"); abort(); }
/* Generated stub for command_failed */
struct command_result *command_failed(struct command *cmd UNNEEDED,
				      struct json_stream *result)

{ fprintf(stderr, "command_failed called!\n"); abort(); }
/* Generated stub for command_its_complicated */
struct command_result *command_its_complicated(const char *why UNNEEDED)
{ fprintf(stderr, "command_its_complicated called!\n"); abort(); }
/* Generated stub for command_log */
struct log *command_log(struct command *cmd UNNEEDED)
{ fprintf(stderr, "command_log called!\n"); abort(); }
/* Generated stub for command_param_failed */
struct command_result *command_param_failed(void)

{ fprintf(stderr, "command_param_failed called!\n"); abort(); }
/* Generated stub for command_still_pending */
struct command_result *command_still_pending(struct command *cmd)

{ fprintf(stderr, "command_still_pending called!\n"); abort(); }
/* Generated stub for command_success */
struct command_result *command_success(struct command *cmd UNNEEDED,
				       struct json_stream *response)

{ fprintf(stderr, "command_success called!\n"); abort(); }
/* Generated stub for commit_tx_boost */
bool commit_tx_boost(struct channel *channel UNNEEDED,
		     const struct bitcoin_tx **tx UNNEEDED,
		     struct anchor_details *adet UNNEEDED)
{ fprintf(stderr, "commit_tx_boost called!\n"); abort(); }
/* Generated stub for connect_any_cmd_id */
const char *connect_any_cmd_id(const tal_t *ctx UNNEEDED,
			       struct lightningd *ld UNNEEDED, const struct peer *peer UNNEEDED)
{ fprintf(stderr, "connect_any_cmd_id called!\n"); abort(); }
/* Generated stub for connect_failed_disconnect */
void connect_failed_disconnect(struct lightningd *ld UNNEEDED,
			       const struct node_id *id UNNEEDED,
			       const struct wireaddr_internal *addr UNNEEDED)
{ fprintf(stderr, "connect_failed_disconnect called!\n"); abort(); }
/* Generated stub for connect_succeeded */
void connect_succeeded(struct lightningd *ld UNNEEDED, const struct peer *peer UNNEEDED,
		       bool incoming UNNEEDED,
		       const struct wireaddr_internal *addr UNNEEDED)
{ fprintf(stderr, "connect_succeeded called!\n"); abort(); }
/* Generated stub for create_anchor_details */
struct anchor_details *create_anchor_details(const tal_t *ctx UNNEEDED,
					     struct channel *channel UNNEEDED,
					     const struct bitcoin_tx *tx UNNEEDED)
{ fprintf(stderr, "create_anchor_details called!\n"); abort(); }
/* Generated stub for db_begin_transaction_ */
void db_begin_transaction_(struct db *db UNNEEDED, const char *location UNNEEDED)
{ fprintf(stderr, "db_begin_transaction_ called!\n"); abort(); }
/* Generated stub for db_commit_transaction */
void db_commit_transaction(struct db *db UNNEEDED)
{ fprintf(stderr, "db_commit_transaction called!\n"); abort(); }
/* Generated stub for delete_channel */
void delete_channel(struct channel *channel STEALS UNNEEDED)
{ fprintf(stderr, "delete_channel called!\n"); abort(); }
/* Generated stub for encode_scriptpubkey_to_addr */
char *encode_scriptpubkey_to_addr(const tal_t *ctx UNNEEDED,
				  const struct chainparams *chainparams UNNEEDED,
				  const u8 *scriptPubkey UNNEEDED)
{ fprintf(stderr, "encode_scriptpubkey_to_addr called!\n"); abort(); }
/* Generated stub for encrypt_tlv_encrypted_data */
u8 *encrypt_tlv_encrypted_data(const tal_t *ctx UNNEEDED,
			       const struct privkey *blinding UNNEEDED,
			       const struct pubkey *node UNNEEDED,
			       const struct tlv_encrypted_data_tlv *tlv UNNEEDED,
			       struct privkey *next_blinding UNNEEDED,
			       struct pubkey *node_alias)

{ fprintf(stderr, "encrypt_tlv_encrypted_data called!\n"); abort(); }
/* Generated stub for failmsg_incorrect_or_unknown_ */
const u8 *failmsg_incorrect_or_unknown_(const tal_t *ctx UNNEEDED,
					struct lightningd *ld UNNEEDED,
					const struct htlc_in *hin UNNEEDED,
					const char *file UNNEEDED, int line UNNEEDED)
{ fprintf(stderr, "failmsg_incorrect_or_unknown_ called!\n"); abort(); }
/* Generated stub for fatal */
void   fatal(const char *fmt UNNEEDED, ...)
{ fprintf(stderr, "fatal called!\n"); abort(); }
/* Generated stub for feature_is_set */
bool feature_is_set(const u8 *features UNNEEDED, size_t bit UNNEEDED)
{ fprintf(stderr, "feature_is_set called!\n"); abort(); }
/* Generated stub for feature_negotiated */
bool feature_negotiated(const struct feature_set *our_features UNNEEDED,
			const u8 *their_features UNNEEDED, size_t f UNNEEDED)
{ fprintf(stderr, "feature_negotiated called!\n"); abort(); }
/* Generated stub for featurebits_or */
u8 *featurebits_or(const tal_t *ctx UNNEEDED, const u8 *f1 TAKES UNNEEDED, const u8 *f2 TAKES UNNEEDED)
{ fprintf(stderr, "featurebits_or called!\n"); abort(); }
/* Generated stub for find_channel_by_alias */
struct channel *find_channel_by_alias(const struct peer *peer UNNEEDED,
				      const struct short_channel_id *alias UNNEEDED,
				      enum side side UNNEEDED)
{ fprintf(stderr, "find_channel_by_alias called!\n"); abort(); }
/* Generated stub for find_channel_by_id */
struct channel *find_channel_by_id(const struct peer *peer UNNEEDED,
				   const struct channel_id *cid UNNEEDED)
{ fprintf(stderr, "find_channel_by_id called!\n"); abort(); }
/* Generated stub for find_channel_by_scid */
struct channel *find_channel_by_scid(const struct peer *peer UNNEEDED,
				     const struct short_channel_id *scid UNNEEDED)
{ fprintf(stderr, "find_channel_by_scid called!\n"); abort(); }
/* Generated stub for find_plugin_for_command */
struct plugin *find_plugin_for_command(struct lightningd *ld UNNEEDED,
				       const char *cmd_name UNNEEDED)
{ fprintf(stderr, "find_plugin_for_command called!\n"); abort(); }
/* Generated stub for fixup_htlcs_out */
void fixup_htlcs_out(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "fixup_htlcs_out called!\n"); abort(); }
/* Generated stub for fromwire_bigsize */
bigsize_t fromwire_bigsize(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_bigsize called!\n"); abort(); }
/* Generated stub for fromwire_channel_id */
bool fromwire_channel_id(const u8 **cursor UNNEEDED, size_t *max UNNEEDED,
			 struct channel_id *channel_id UNNEEDED)
{ fprintf(stderr, "fromwire_channel_id called!\n"); abort(); }
/* Generated stub for fromwire_channeld_dev_memleak_reply */
bool fromwire_channeld_dev_memleak_reply(const void *p UNNEEDED, bool *leak UNNEEDED)
{ fprintf(stderr, "fromwire_channeld_dev_memleak_reply called!\n"); abort(); }
/* Generated stub for fromwire_connectd_peer_connected */
bool fromwire_connectd_peer_connected(const tal_t *ctx UNNEEDED, const void *p UNNEEDED, struct node_id *id UNNEEDED, u64 *counter UNNEEDED, struct wireaddr_internal *addr UNNEEDED, struct wireaddr **remote_addr UNNEEDED, bool *incoming UNNEEDED, u8 **features UNNEEDED)
{ fprintf(stderr, "fromwire_connectd_peer_connected called!\n"); abort(); }
/* Generated stub for fromwire_connectd_peer_disconnect_done */
bool fromwire_connectd_peer_disconnect_done(const void *p UNNEEDED, struct node_id *id UNNEEDED, u64 *counter UNNEEDED)
{ fprintf(stderr, "fromwire_connectd_peer_disconnect_done called!\n"); abort(); }
/* Generated stub for fromwire_connectd_peer_spoke */
bool fromwire_connectd_peer_spoke(const void *p UNNEEDED, struct node_id *id UNNEEDED, u64 *counter UNNEEDED, u16 *msgtype UNNEEDED, struct channel_id *channel_id UNNEEDED)
{ fprintf(stderr, "fromwire_connectd_peer_spoke called!\n"); abort(); }
/* Generated stub for fromwire_dualopend_dev_memleak_reply */
bool fromwire_dualopend_dev_memleak_reply(const void *p UNNEEDED, bool *leak UNNEEDED)
{ fprintf(stderr, "fromwire_dualopend_dev_memleak_reply called!\n"); abort(); }
/* Generated stub for fromwire_hsmd_preapprove_invoice_reply */
bool fromwire_hsmd_preapprove_invoice_reply(const void *p UNNEEDED, bool *approved UNNEEDED)
{ fprintf(stderr, "fromwire_hsmd_preapprove_invoice_reply called!\n"); abort(); }
/* Generated stub for fromwire_hsmd_preapprove_keysend_reply */
bool fromwire_hsmd_preapprove_keysend_reply(const void *p UNNEEDED, bool *approved UNNEEDED)
{ fprintf(stderr, "fromwire_hsmd_preapprove_keysend_reply called!\n"); abort(); }
/* Generated stub for fromwire_hsmd_sign_bolt12_reply */
bool fromwire_hsmd_sign_bolt12_reply(const void *p UNNEEDED, struct bip340sig *sig UNNEEDED)
{ fprintf(stderr, "fromwire_hsmd_sign_bolt12_reply called!\n"); abort(); }
/* Generated stub for fromwire_hsmd_sign_commitment_tx_reply */
bool fromwire_hsmd_sign_commitment_tx_reply(const void *p UNNEEDED, struct bitcoin_signature *sig UNNEEDED)
{ fprintf(stderr, "fromwire_hsmd_sign_commitment_tx_reply called!\n"); abort(); }
/* Generated stub for fromwire_hsmd_sign_invoice_reply */
bool fromwire_hsmd_sign_invoice_reply(const void *p UNNEEDED, secp256k1_ecdsa_recoverable_signature *sig UNNEEDED)
{ fprintf(stderr, "fromwire_hsmd_sign_invoice_reply called!\n"); abort(); }
/* Generated stub for fromwire_node_id */
void fromwire_node_id(const u8 **cursor UNNEEDED, size_t *max UNNEEDED, struct node_id *id UNNEEDED)
{ fprintf(stderr, "fromwire_node_id called!\n"); abort(); }
/* Generated stub for fromwire_onchaind_dev_memleak_reply */
bool fromwire_onchaind_dev_memleak_reply(const void *p UNNEEDED, bool *leak UNNEEDED)
{ fprintf(stderr, "fromwire_onchaind_dev_memleak_reply called!\n"); abort(); }
/* Generated stub for fromwire_openingd_dev_memleak_reply */
bool fromwire_openingd_dev_memleak_reply(const void *p UNNEEDED, bool *leak UNNEEDED)
{ fprintf(stderr, "fromwire_openingd_dev_memleak_reply called!\n"); abort(); }
/* Generated stub for get_block_height */
u32 get_block_height(const struct chain_topology *topo UNNEEDED)
{ fprintf(stderr, "get_block_height called!\n"); abort(); }
/* Generated stub for get_feerate */
u32 get_feerate(const struct fee_states *fee_states UNNEEDED,
		enum side opener UNNEEDED,
		enum side side UNNEEDED)
{ fprintf(stderr, "get_feerate called!\n"); abort(); }
/* Generated stub for hash_htlc_key */
size_t hash_htlc_key(const struct htlc_key *htlc_key UNNEEDED)
{ fprintf(stderr, "hash_htlc_key called!\n"); abort(); }
/* Generated stub for hsm_sync_req */
const u8 *hsm_sync_req(const tal_t *ctx UNNEEDED,
		       struct lightningd *ld UNNEEDED,
		       const u8 *msg TAKES UNNEEDED)
{ fprintf(stderr, "hsm_sync_req called!\n"); abort(); }
/* Generated stub for htlc_is_trimmed */
bool htlc_is_trimmed(enum side htlc_owner UNNEEDED,
		     struct amount_msat htlc_amount UNNEEDED,
		     u32 feerate_per_kw UNNEEDED,
		     struct amount_sat dust_limit UNNEEDED,
		     enum side side UNNEEDED,
		     bool option_anchor_outputs UNNEEDED,
		     bool option_anchors_zero_fee_htlc_tx UNNEEDED)
{ fprintf(stderr, "htlc_is_trimmed called!\n"); abort(); }
/* Generated stub for htlc_max_possible_send */
struct amount_msat htlc_max_possible_send(const struct channel *channel UNNEEDED)
{ fprintf(stderr, "htlc_max_possible_send called!\n"); abort(); }
/* Generated stub for htlc_set_fail */
void htlc_set_fail(struct htlc_set *set UNNEEDED, const u8 *failmsg TAKES UNNEEDED)
{ fprintf(stderr, "htlc_set_fail called!\n"); abort(); }
/* Generated stub for htlc_set_fulfill */
void htlc_set_fulfill(struct htlc_set *set UNNEEDED, const struct preimage *preimage UNNEEDED)
{ fprintf(stderr, "htlc_set_fulfill called!\n"); abort(); }
/* Generated stub for invoice_decode */
struct tlv_invoice *invoice_decode(const tal_t *ctx UNNEEDED,
				   const char *b12 UNNEEDED, size_t b12len UNNEEDED,
				   const struct feature_set *our_features UNNEEDED,
				   const struct chainparams *must_be_chain UNNEEDED,
				   char **fail UNNEEDED)
{ fprintf(stderr, "invoice_decode called!\n"); abort(); }
/* Generated stub for invoice_decode_nosig */
struct tlv_invoice *invoice_decode_nosig(const tal_t *ctx UNNEEDED,
					 const char *b12 UNNEEDED, size_t b12len UNNEEDED,
					 const struct feature_set *our_features UNNEEDED,
					 const struct chainparams *must_be_chain UNNEEDED,
					 char **fail UNNEEDED)
{ fprintf(stderr, "invoice_decode_nosig called!\n"); abort(); }
/* Generated stub for invoice_encode */
char *invoice_encode(const tal_t *ctx UNNEEDED, const struct tlv_invoice *bolt12_tlv UNNEEDED)
{ fprintf(stderr, "invoice_encode called!\n"); abort(); }
/* Generated stub for invoice_offer_id */
void invoice_offer_id(const struct tlv_invoice *invoice UNNEEDED, struct sha256 *id UNNEEDED)
{ fprintf(stderr, "invoice_offer_id called!\n"); abort(); }
/* Generated stub for invoice_path_id */
u8 *invoice_path_id(const tal_t *ctx UNNEEDED,
		    const struct secret *base_secret UNNEEDED,
		    const struct sha256 *payment_hash UNNEEDED)
{ fprintf(stderr, "invoice_path_id called!\n"); abort(); }
/* Generated stub for json_add_address */
void json_add_address(struct json_stream *response UNNEEDED, const char *fieldname UNNEEDED,
		      const struct wireaddr *addr UNNEEDED)
{ fprintf(stderr, "json_add_address called!\n"); abort(); }
/* Generated stub for json_add_address_internal */
void json_add_address_internal(struct json_stream *response UNNEEDED,
			       const char *fieldname UNNEEDED,
			       const struct wireaddr_internal *addr UNNEEDED)
{ fprintf(stderr, "json_add_address_internal called!\n"); abort(); }
/* Generated stub for json_add_amount_msat */
void json_add_amount_msat(struct json_stream *result UNNEEDED,
			  const char *msatfieldname UNNEEDED,
			  struct amount_msat msat)

{ fprintf(stderr, "json_add_amount_msat called!\n"); abort(); }
/* Generated stub for json_add_amount_sat_msat */
void json_add_amount_sat_msat(struct json_stream *result UNNEEDED,
			      const char *msatfieldname UNNEEDED,
			      struct amount_sat sat)

{ fprintf(stderr, "json_add_amount_sat_msat called!\n"); abort(); }
/* Generated stub for json_add_bolt11 */
void json_add_bolt11(struct json_stream *response UNNEEDED,
		     const struct bolt11 *b11 UNNEEDED)
{ fprintf(stderr, "json_add_bolt11 called!\n"); abort(); }
/* Generated stub for json_add_bool */
void json_add_bool(struct json_stream *result UNNEEDED, const char *fieldname UNNEEDED,
		   bool value UNNEEDED)
{ fprintf(stderr, "json_add_bool called!\n"); abort(); }
/* Generated stub for json_add_escaped_string */
void json_add_escaped_string(struct json_stream *result UNNEEDED,
			     const char *fieldname UNNEEDED,
			     const struct json_escape *esc TAKES UNNEEDED)
{ fprintf(stderr, "json_add_escaped_string called!\n"); abort(); }
/* Generated stub for json_add_hex_talarr */
void json_add_hex_talarr(struct json_stream *result UNNEEDED,
			 const char *fieldname UNNEEDED,
			 const tal_t *data UNNEEDED)
{ fprintf(stderr, "json_add_hex_talarr called!\n"); abort(); }
/* Generated stub for json_add_invstring */
void json_add_invstring(struct json_stream *result UNNEEDED, const char *invstring UNNEEDED)
{ fprintf(stderr, "json_add_invstring called!\n"); abort(); }
/* Generated stub for json_add_log */
void json_add_log(struct json_stream *result UNNEEDED,
		  const struct log_book *lr UNNEEDED,
		  const struct node_id *node_id UNNEEDED,
		  enum log_level minlevel UNNEEDED)
{ fprintf(stderr, "json_add_log called!\n"); abort(); }
/* Generated stub for json_add_node_id */
void json_add_node_id(struct json_stream *response UNNEEDED,
				const char *fieldname UNNEEDED,
				const struct node_id *id UNNEEDED)
{ fprintf(stderr, "json_add_node_id called!\n"); abort(); }
/* Generated stub for json_add_num */
void json_add_num(struct json_stream *result UNNEEDED, const char *fieldname UNNEEDED,
		  unsigned int value UNNEEDED)
{ fprintf(stderr, "json_add_num called!\n"); abort(); }
/* Generated stub for json_add_preimage */
void json_add_preimage(struct json_stream *result UNNEEDED, const char *fieldname UNNEEDED,
		     const struct preimage *preimage UNNEEDED)
{ fprintf(stderr, "json_add_preimage called!\n"); abort(); }
/* Generated stub for json_add_secret */
void json_add_secret(struct json_stream *response UNNEEDED,
		     const char *fieldname UNNEEDED,
		     const struct secret *secret UNNEEDED)
{ fprintf(stderr, "json_add_secret called!\n"); abort(); }
/* Generated stub for json_add_sha256 */
void json_add_sha256(struct json_stream *result UNNEEDED, const char *fieldname UNNEEDED,
		     const struct sha256 *hash UNNEEDED)
{ fprintf(stderr, "json_add_sha256 called!\n"); abort(); }
/* Generated stub for json_add_short_channel_id */
void json_add_short_channel_id(struct json_stream *response UNNEEDED,
			       const char *fieldname UNNEEDED,
			       const struct short_channel_id *id UNNEEDED)
{ fprintf(stderr, "json_add_short_channel_id called!\n"); abort(); }
/* Generated stub for json_add_string */
void json_add_string(struct json_stream *js UNNEEDED,
		     const char *fieldname UNNEEDED,
		     const char *str TAKES UNNEEDED)
{ fprintf(stderr, "json_add_string called!\n"); abort(); }
/* Generated stub for json_add_stringn */
void json_add_stringn(struct json_stream *result UNNEEDED, const char *fieldname UNNEEDED,
		      const char *value TAKES UNNEEDED, size_t value_len UNNEEDED)
{ fprintf(stderr, "json_add_stringn called!\n"); abort(); }
/* Generated stub for json_add_timeiso */
void json_add_timeiso(struct json_stream *result UNNEEDED,
		      const char *fieldname UNNEEDED,
		      struct timeabs *time UNNEEDED)
{ fprintf(stderr, "json_add_timeiso called!\n"); abort(); }
/* Generated stub for json_add_tx */
void json_add_tx(struct json_stream *result UNNEEDED,
		 const char *fieldname UNNEEDED,
		 const struct bitcoin_tx *tx UNNEEDED)
{ fprintf(stderr, "json_add_tx called!\n"); abort(); }
/* Generated stub for json_add_txid */
void json_add_txid(struct json_stream *result UNNEEDED, const char *fieldname UNNEEDED,
		   const struct bitcoin_txid *txid UNNEEDED)
{ fprintf(stderr, "json_add_txid called!\n"); abort(); }
/* Generated stub for json_add_u32 */
void json_add_u32(struct json_stream *result UNNEEDED, const char *fieldname UNNEEDED,
		  uint32_t value UNNEEDED)
{ fprintf(stderr, "json_add_u32 called!\n"); abort(); }
/* Generated stub for json_add_u64 */
void json_add_u64(struct json_stream *result UNNEEDED, const char *fieldname UNNEEDED,
		  uint64_t value UNNEEDED)
{ fprintf(stderr, "json_add_u64 called!\n"); abort(); }
/* Generated stub for json_add_uncommitted_channel */
void json_add_uncommitted_channel(struct json_stream *response UNNEEDED,
				  const struct uncommitted_channel *uc UNNEEDED,
				  /* Only set for listpeerchannels */
				  const struct peer *peer UNNEEDED)
{ fprintf(stderr, "json_add_uncommitted_channel called!\n"); abort(); }
/* Generated stub for json_add_unsaved_channel */
void json_add_unsaved_channel(struct json_stream *response UNNEEDED,
			      const struct channel *channel UNNEEDED,
			      /* Only set for listpeerchannels */
			      const struct peer *peer UNNEEDED)
{ fprintf(stderr, "json_add_unsaved_channel called!\n"); abort(); }
/* Generated stub for json_array_end */
void json_array_end(struct json_stream *js UNNEEDED)
{ fprintf(stderr, "json_array_end called!\n"); abort(); }
/* Generated stub for json_array_start */
void json_array_start(struct json_stream *js UNNEEDED, const char *fieldname UNNEEDED)
{ fprintf(stderr, "json_array_start called!\n"); abort(); }
/* Generated stub for json_object_end */
void json_object_end(struct json_stream *js UNNEEDED)
{ fprintf(stderr, "json_object_end called!\n"); abort(); }
/* Generated stub for json_object_start */
void json_object_start(struct json_stream *ks UNNEEDED, const char *fieldname UNNEEDED)
{ fprintf(stderr, "json_object_start called!\n"); abort(); }
/* Generated stub for json_scan */
const char *json_scan(const tal_t *ctx UNNEEDED,
		      const char *buffer UNNEEDED,
		      const jsmntok_t *tok UNNEEDED,
		      const char *guide UNNEEDED,
		      ...)
{ fprintf(stderr, "json_scan called!\n"); abort(); }
/* Generated stub for json_stream_fail */
struct json_stream *json_stream_fail(struct command *cmd UNNEEDED,
				     enum jsonrpc_errcode code UNNEEDED,
				     const char *errmsg UNNEEDED)
{ fprintf(stderr, "json_stream_fail called!\n"); abort(); }
/* Generated stub for json_stream_success */
struct json_stream *json_stream_success(struct command *cmd UNNEEDED)
{ fprintf(stderr, "json_stream_success called!\n"); abort(); }
/* Generated stub for json_to_address_scriptpubkey */
enum address_parse_result json_to_address_scriptpubkey(const tal_t *ctx UNNEEDED,
			     const struct chainparams *chainparams UNNEEDED,
			     const char *buffer UNNEEDED,
			     const jsmntok_t *tok UNNEEDED, const u8 **scriptpubkey UNNEEDED)
{ fprintf(stderr, "json_to_address_scriptpubkey called!\n"); abort(); }
/* Generated stub for json_to_msat */
bool json_to_msat(const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED,
		  struct amount_msat *msat UNNEEDED)
{ fprintf(stderr, "json_to_msat called!\n"); abort(); }
/* Generated stub for json_to_node_id */
bool json_to_node_id(const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED,
			       struct node_id *id UNNEEDED)
{ fprintf(stderr, "json_to_node_id called!\n"); abort(); }
/* Generated stub for json_to_number */
bool json_to_number(const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED,
		    unsigned int *num UNNEEDED)
{ fprintf(stderr, "json_to_number called!\n"); abort(); }
/* Generated stub for json_to_short_channel_id */
bool json_to_short_channel_id(const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED,
			      struct short_channel_id *scid UNNEEDED)
{ fprintf(stderr, "json_to_short_channel_id called!\n"); abort(); }
/* Generated stub for json_to_u16 */
bool json_to_u16(const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED,
                 uint16_t *num UNNEEDED)
{ fprintf(stderr, "json_to_u16 called!\n"); abort(); }
/* Generated stub for json_tok_bin_from_hex */
u8 *json_tok_bin_from_hex(const tal_t *ctx UNNEEDED, const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED)
{ fprintf(stderr, "json_tok_bin_from_hex called!\n"); abort(); }
/* Generated stub for json_tok_channel_id */
bool json_tok_channel_id(const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED,
			 struct channel_id *cid UNNEEDED)
{ fprintf(stderr, "json_tok_channel_id called!\n"); abort(); }
/* Generated stub for jsonrpc_request_end */
void jsonrpc_request_end(struct jsonrpc_request *request UNNEEDED)
{ fprintf(stderr, "jsonrpc_request_end called!\n"); abort(); }
/* Generated stub for jsonrpc_request_start_ */
struct jsonrpc_request *jsonrpc_request_start_(
    const tal_t *ctx UNNEEDED, const char *method UNNEEDED,
    const char *id_prefix TAKES UNNEEDED,
    bool id_as_string UNNEEDED,
    struct log *log UNNEEDED, bool add_header UNNEEDED,
    void (*notify_cb)(const char *buffer UNNEEDED,
		      const jsmntok_t *idtok UNNEEDED,
		      const jsmntok_t *methodtok UNNEEDED,
		      const jsmntok_t *paramtoks UNNEEDED,
		      void *) UNNEEDED,
    void (*response_cb)(const char *buffer UNNEEDED, const jsmntok_t *toks UNNEEDED,
			const jsmntok_t *idtok UNNEEDED, void *) UNNEEDED,
    void *response_cb_arg UNNEEDED)
{ fprintf(stderr, "jsonrpc_request_start_ called!\n"); abort(); }
/* Generated stub for kill_uncommitted_channel */
void kill_uncommitted_channel(struct uncommitted_channel *uc UNNEEDED,
			      const char *why UNNEEDED)
{ fprintf(stderr, "kill_uncommitted_channel called!\n"); abort(); }
/* Generated stub for log_ */
void log_(struct log *log UNNEEDED, enum log_level level UNNEEDED,
	  const struct node_id *node_id UNNEEDED,
	  bool call_notifier UNNEEDED,
	  const char *fmt UNNEEDED, ...)

{ fprintf(stderr, "log_ called!\n"); abort(); }
/* Generated stub for merkle_tlv */
void merkle_tlv(const struct tlv_field *fields UNNEEDED, struct sha256 *merkle UNNEEDED)
{ fprintf(stderr, "merkle_tlv called!\n"); abort(); }
/* Generated stub for new_bolt11 */
struct bolt11 *new_bolt11(const tal_t *ctx UNNEEDED,
			  const struct amount_msat *msat TAKES UNNEEDED)
{ fprintf(stderr, "new_bolt11 called!\n"); abort(); }
/* Generated stub for new_height_states */
struct height_states *new_height_states(const tal_t *ctx UNNEEDED,
					enum side opener UNNEEDED,
					const u32 *blockheight UNNEEDED)
{ fprintf(stderr, "new_height_states called!\n"); abort(); }
/* Generated stub for new_peer_fd */
struct peer_fd *new_peer_fd(const tal_t *ctx UNNEEDED, int peer_fd UNNEEDED)
{ fprintf(stderr, "new_peer_fd called!\n"); abort(); }
/* Generated stub for new_reltimer_ */
struct oneshot *new_reltimer_(struct timers *timers UNNEEDED,
			      const tal_t *ctx UNNEEDED,
			      struct timerel expire UNNEEDED,
			      void (*cb)(void *) UNNEEDED, void *arg UNNEEDED)
{ fprintf(stderr, "new_reltimer_ called!\n"); abort(); }
/* Generated stub for new_uncommitted_channel */
struct uncommitted_channel *new_uncommitted_channel(struct peer *peer UNNEEDED)
{ fprintf(stderr, "new_uncommitted_channel called!\n"); abort(); }
/* Generated stub for new_unsaved_channel */
struct channel *new_unsaved_channel(struct peer *peer UNNEEDED,
				    u32 feerate_base UNNEEDED,
				    u32 feerate_ppm UNNEEDED)
{ fprintf(stderr, "new_unsaved_channel called!\n"); abort(); }
/* Generated stub for node_id_cmp */
int node_id_cmp(const struct node_id *a UNNEEDED, const struct node_id *b UNNEEDED)
{ fprintf(stderr, "node_id_cmp called!\n"); abort(); }
/* Generated stub for notify_connect */
void notify_connect(struct lightningd *ld UNNEEDED,
		    const struct node_id *nodeid UNNEEDED,
		    bool incoming UNNEEDED,
		    const struct wireaddr_internal *addr UNNEEDED)
{ fprintf(stderr, "notify_connect called!\n"); abort(); }
/* Generated stub for notify_disconnect */
void notify_disconnect(struct lightningd *ld UNNEEDED, struct node_id *nodeid UNNEEDED)
{ fprintf(stderr, "notify_disconnect called!\n"); abort(); }
/* Generated stub for notify_invoice_creation */
void notify_invoice_creation(struct lightningd *ld UNNEEDED, struct amount_msat *amount UNNEEDED,
			    struct preimage preimage UNNEEDED, const struct json_escape *label UNNEEDED)
{ fprintf(stderr, "notify_invoice_creation called!\n"); abort(); }
/* Generated stub for notify_invoice_payment */
void notify_invoice_payment(struct lightningd *ld UNNEEDED, struct amount_msat amount UNNEEDED,
			    struct preimage preimage UNNEEDED, const struct json_escape *label UNNEEDED)
{ fprintf(stderr, "notify_invoice_payment called!\n"); abort(); }
/* Generated stub for onchaind_funding_spent */
enum watch_result onchaind_funding_spent(struct channel *channel UNNEEDED,
					 const struct bitcoin_tx *tx UNNEEDED,
					 u32 blockheight UNNEEDED)
{ fprintf(stderr, "onchaind_funding_spent called!\n"); abort(); }
/* Generated stub for param */
bool param(struct command *cmd UNNEEDED, const char *buffer UNNEEDED,
	   const jsmntok_t params[] UNNEEDED, ...)
{ fprintf(stderr, "param called!\n"); abort(); }
/* Generated stub for param_array */
struct command_result *param_array(struct command *cmd UNNEEDED, const char *name UNNEEDED,
				   const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED,
				   const jsmntok_t **arr UNNEEDED)
{ fprintf(stderr, "param_array called!\n"); abort(); }
/* Generated stub for param_bool */
struct command_result *param_bool(struct command *cmd UNNEEDED, const char *name UNNEEDED,
				  const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED,
				  bool **b UNNEEDED)
{ fprintf(stderr, "param_bool called!\n"); abort(); }
/* Generated stub for param_channel_id */
struct command_result *param_channel_id(struct command *cmd UNNEEDED,
					const char *name UNNEEDED,
					const char *buffer UNNEEDED,
					const jsmntok_t *tok UNNEEDED,
					struct channel_id **cid UNNEEDED)
{ fprintf(stderr, "param_channel_id called!\n"); abort(); }
/* Generated stub for param_escaped_string */
struct command_result *param_escaped_string(struct command *cmd UNNEEDED,
					    const char *name UNNEEDED,
					    const char *buffer UNNEEDED,
					    const jsmntok_t *tok UNNEEDED,
					    const char **str UNNEEDED)
{ fprintf(stderr, "param_escaped_string called!\n"); abort(); }
/* Generated stub for param_label */
struct command_result *param_label(struct command *cmd UNNEEDED, const char *name UNNEEDED,
				   const char * buffer UNNEEDED, const jsmntok_t *tok UNNEEDED,
				   struct json_escape **label UNNEEDED)
{ fprintf(stderr, "param_label called!\n"); abort(); }
/* Generated stub for param_loglevel */
struct command_result *param_loglevel(struct command *cmd UNNEEDED,
				      const char *name UNNEEDED,
				      const char *buffer UNNEEDED,
				      const jsmntok_t *tok UNNEEDED,
				      enum log_level **level UNNEEDED)
{ fprintf(stderr, "param_loglevel called!\n"); abort(); }
/* Generated stub for param_msat */
struct command_result *param_msat(struct command *cmd UNNEEDED, const char *name UNNEEDED,
				  const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED,
				  struct amount_msat **msat UNNEEDED)
{ fprintf(stderr, "param_msat called!\n"); abort(); }
/* Generated stub for param_node_id */
struct command_result *param_node_id(struct command *cmd UNNEEDED,
				     const char *name UNNEEDED,
				     const char *buffer UNNEEDED,
				     const jsmntok_t *tok UNNEEDED,
				     struct node_id **id UNNEEDED)
{ fprintf(stderr, "param_node_id called!\n"); abort(); }
/* Generated stub for param_number */
struct command_result *param_number(struct command *cmd UNNEEDED, const char *name UNNEEDED,
				    const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED,
				    unsigned int **num UNNEEDED)
{ fprintf(stderr, "param_number called!\n"); abort(); }
/* Generated stub for param_sha256 */
struct command_result *param_sha256(struct command *cmd UNNEEDED, const char *name UNNEEDED,
				    const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED,
				    struct sha256 **hash UNNEEDED)
{ fprintf(stderr, "param_sha256 called!\n"); abort(); }
/* Generated stub for param_short_channel_id */
struct command_result *param_short_channel_id(struct command *cmd UNNEEDED,
					      const char *name UNNEEDED,
					      const char *buffer UNNEEDED,
					      const jsmntok_t *tok UNNEEDED,
					      struct short_channel_id **scid UNNEEDED)
{ fprintf(stderr, "param_short_channel_id called!\n"); abort(); }
/* Generated stub for param_string */
struct command_result *param_string(struct command *cmd UNNEEDED, const char *name UNNEEDED,
				    const char * buffer UNNEEDED, const jsmntok_t *tok UNNEEDED,
				    const char **str UNNEEDED)
{ fprintf(stderr, "param_string called!\n"); abort(); }
/* Generated stub for param_u64 */
struct command_result *param_u64(struct command *cmd UNNEEDED, const char *name UNNEEDED,
				 const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED,
				 uint64_t **num UNNEEDED)
{ fprintf(stderr, "param_u64 called!\n"); abort(); }
/* Generated stub for peer_any_active_channel */
struct channel *peer_any_active_channel(struct peer *peer UNNEEDED, bool *others UNNEEDED)
{ fprintf(stderr, "peer_any_active_channel called!\n"); abort(); }
/* Generated stub for peer_restart_dualopend */
bool peer_restart_dualopend(struct peer *peer UNNEEDED,
			    struct peer_fd *peer_fd UNNEEDED,
			    struct channel *channel UNNEEDED)
{ fprintf(stderr, "peer_restart_dualopend called!\n"); abort(); }
/* Generated stub for peer_start_channeld */
bool peer_start_channeld(struct channel *channel UNNEEDED,
			 struct peer_fd *peer_fd UNNEEDED,
			 const u8 *fwd_msg UNNEEDED,
			 bool reconnected UNNEEDED,
			 bool reestablish_only UNNEEDED)
{ fprintf(stderr, "peer_start_channeld called!\n"); abort(); }
/* Generated stub for peer_start_dualopend */
bool peer_start_dualopend(struct peer *peer UNNEEDED, struct peer_fd *peer_fd UNNEEDED,
			  struct channel *channel UNNEEDED)
{ fprintf(stderr, "peer_start_dualopend called!\n"); abort(); }
/* Generated stub for peer_start_openingd */
bool peer_start_openingd(struct peer *peer UNNEEDED,
			 struct peer_fd *peer_fd UNNEEDED)
{ fprintf(stderr, "peer_start_openingd called!\n"); abort(); }
/* Generated stub for plugin_hook_call_ */
bool plugin_hook_call_(struct lightningd *ld UNNEEDED,
		       const struct plugin_hook *hook UNNEEDED,
		       const char *cmd_id TAKES UNNEEDED,
		       tal_t *cb_arg STEALS UNNEEDED)
{ fprintf(stderr, "plugin_hook_call_ called!\n"); abort(); }
/* Generated stub for plugin_request_send */
void plugin_request_send(struct plugin *plugin UNNEEDED,
			 struct jsonrpc_request *req TAKES UNNEEDED)
{ fprintf(stderr, "plugin_request_send called!\n"); abort(); }
/* Generated stub for pubkey_from_node_id */
bool pubkey_from_node_id(struct pubkey *key UNNEEDED, const struct node_id *id UNNEEDED)
{ fprintf(stderr, "pubkey_from_node_id called!\n"); abort(); }
/* Generated stub for report_subd_memleak */
void report_subd_memleak(struct leak_detect *leak_detect UNNEEDED, struct subd *leaker UNNEEDED)
{ fprintf(stderr, "report_subd_memleak called!\n"); abort(); }
/* Generated stub for resolve_close_command */
const char *resolve_close_command(const tal_t *ctx UNNEEDED,
				  struct lightningd *ld UNNEEDED, struct channel *channel UNNEEDED,
				  bool cooperative UNNEEDED)
{ fprintf(stderr, "resolve_close_command called!\n"); abort(); }
/* Generated stub for start_leak_request */
void start_leak_request(const struct subd_req *req UNNEEDED,
			struct leak_detect *leak_detect UNNEEDED)
{ fprintf(stderr, "start_leak_request called!\n"); abort(); }
/* Generated stub for subd_req_ */
struct subd_req *subd_req_(const tal_t *ctx UNNEEDED,
	       struct subd *sd UNNEEDED,
	       const u8 *msg_out UNNEEDED,
	       int fd_out UNNEEDED, size_t num_fds_in UNNEEDED,
	       void (*replycb)(struct subd * UNNEEDED, const u8 * UNNEEDED, const int * UNNEEDED, void *) UNNEEDED,
	       void *replycb_data UNNEEDED)
{ fprintf(stderr, "subd_req_ called!\n"); abort(); }
/* Generated stub for subd_send_fd */
void subd_send_fd(struct subd *sd UNNEEDED, int fd UNNEEDED)
{ fprintf(stderr, "subd_send_fd called!\n"); abort(); }
/* Generated stub for subd_send_msg */
void subd_send_msg(struct subd *sd UNNEEDED, const u8 *msg_out UNNEEDED)
{ fprintf(stderr, "subd_send_msg called!\n"); abort(); }
/* Generated stub for towire_bigsize */
void towire_bigsize(u8 **pptr UNNEEDED, const bigsize_t val UNNEEDED)
{ fprintf(stderr, "towire_bigsize called!\n"); abort(); }
/* Generated stub for towire_channel_id */
void towire_channel_id(u8 **pptr UNNEEDED, const struct channel_id *channel_id UNNEEDED)
{ fprintf(stderr, "towire_channel_id called!\n"); abort(); }
/* Generated stub for towire_channeld_config_channel */
u8 *towire_channeld_config_channel(const tal_t *ctx UNNEEDED, u32 *feerate_base UNNEEDED, u32 *feerate_ppm UNNEEDED, struct amount_msat *htlc_minimum UNNEEDED, struct amount_msat *htlc_maximum UNNEEDED)
{ fprintf(stderr, "towire_channeld_config_channel called!\n"); abort(); }
/* Generated stub for towire_channeld_dev_memleak */
u8 *towire_channeld_dev_memleak(const tal_t *ctx UNNEEDED)
{ fprintf(stderr, "towire_channeld_dev_memleak called!\n"); abort(); }
/* Generated stub for towire_channeld_dev_reenable_commit */
u8 *towire_channeld_dev_reenable_commit(const tal_t *ctx UNNEEDED)
{ fprintf(stderr, "towire_channeld_dev_reenable_commit called!\n"); abort(); }
/* Generated stub for towire_connectd_discard_peer */
u8 *towire_connectd_discard_peer(const tal_t *ctx UNNEEDED, const struct node_id *id UNNEEDED, u64 counter UNNEEDED)
{ fprintf(stderr, "towire_connectd_discard_peer called!\n"); abort(); }
/* Generated stub for towire_connectd_peer_connect_subd */
u8 *towire_connectd_peer_connect_subd(const tal_t *ctx UNNEEDED, const struct node_id *id UNNEEDED, u64 counter UNNEEDED, const struct channel_id *channel_id UNNEEDED)
{ fprintf(stderr, "towire_connectd_peer_connect_subd called!\n"); abort(); }
/* Generated stub for towire_connectd_peer_final_msg */
u8 *towire_connectd_peer_final_msg(const tal_t *ctx UNNEEDED, const struct node_id *id UNNEEDED, u64 counter UNNEEDED, const u8 *msg UNNEEDED)
{ fprintf(stderr, "towire_connectd_peer_final_msg called!\n"); abort(); }
/* Generated stub for towire_dualopend_dev_memleak */
u8 *towire_dualopend_dev_memleak(const tal_t *ctx UNNEEDED)
{ fprintf(stderr, "towire_dualopend_dev_memleak called!\n"); abort(); }
/* Generated stub for towire_errorfmt */
u8 *towire_errorfmt(const tal_t *ctx UNNEEDED,
		    const struct channel_id *channel UNNEEDED,
		    const char *fmt UNNEEDED, ...)
{ fprintf(stderr, "towire_errorfmt called!\n"); abort(); }
/* Generated stub for towire_gossipd_discovered_ip */
u8 *towire_gossipd_discovered_ip(const tal_t *ctx UNNEEDED, const struct wireaddr *discovered_ip UNNEEDED)
{ fprintf(stderr, "towire_gossipd_discovered_ip called!\n"); abort(); }
/* Generated stub for towire_hsmd_preapprove_invoice */
u8 *towire_hsmd_preapprove_invoice(const tal_t *ctx UNNEEDED, const wirestring *invstring UNNEEDED)
{ fprintf(stderr, "towire_hsmd_preapprove_invoice called!\n"); abort(); }
/* Generated stub for towire_hsmd_preapprove_keysend */
u8 *towire_hsmd_preapprove_keysend(const tal_t *ctx UNNEEDED, const struct node_id *destination UNNEEDED, const struct sha256 *payment_hash UNNEEDED, struct amount_msat amount_msat UNNEEDED)
{ fprintf(stderr, "towire_hsmd_preapprove_keysend called!\n"); abort(); }
/* Generated stub for towire_hsmd_sign_bolt12 */
u8 *towire_hsmd_sign_bolt12(const tal_t *ctx UNNEEDED, const wirestring *messagename UNNEEDED, const wirestring *fieldname UNNEEDED, const struct sha256 *merkleroot UNNEEDED, const u8 *publictweak UNNEEDED)
{ fprintf(stderr, "towire_hsmd_sign_bolt12 called!\n"); abort(); }
/* Generated stub for towire_hsmd_sign_commitment_tx */
u8 *towire_hsmd_sign_commitment_tx(const tal_t *ctx UNNEEDED, const struct node_id *peer_id UNNEEDED, u64 channel_dbid UNNEEDED, const struct bitcoin_tx *tx UNNEEDED, const struct pubkey *remote_funding_key UNNEEDED, u64 commit_num UNNEEDED)
{ fprintf(stderr, "towire_hsmd_sign_commitment_tx called!\n"); abort(); }
/* Generated stub for towire_hsmd_sign_invoice */
u8 *towire_hsmd_sign_invoice(const tal_t *ctx UNNEEDED, const u8 *u5bytes UNNEEDED, const u8 *hrp UNNEEDED)
{ fprintf(stderr, "towire_hsmd_sign_invoice called!\n"); abort(); }
/* Generated stub for towire_node_id */
void towire_node_id(u8 **pptr UNNEEDED, const struct node_id *id UNNEEDED)
{ fprintf(stderr, "towire_node_id called!\n"); abort(); }
/* Generated stub for towire_onchaind_dev_memleak */
u8 *towire_onchaind_dev_memleak(const tal_t *ctx UNNEEDED)
{ fprintf(stderr, "towire_onchaind_dev_memleak called!\n"); abort(); }
/* Generated stub for towire_openingd_dev_memleak */
u8 *towire_openingd_dev_memleak(const tal_t *ctx UNNEEDED)
{ fprintf(stderr, "towire_openingd_dev_memleak called!\n"); abort(); }
/* Generated stub for towire_scb_chan */
void towire_scb_chan(u8 **p UNNEEDED, const struct scb_chan *scb_chan UNNEEDED)
{ fprintf(stderr, "towire_scb_chan called!\n"); abort(); }
/* Generated stub for towire_warningfmt */
u8 *towire_warningfmt(const tal_t *ctx UNNEEDED,
		      const struct channel_id *channel UNNEEDED,
		      const char *fmt UNNEEDED, ...)
{ fprintf(stderr, "towire_warningfmt called!\n"); abort(); }
/* Generated stub for try_reconnect */
void try_reconnect(const tal_t *ctx UNNEEDED,
		   struct peer *peer UNNEEDED,
		   const struct wireaddr_internal *addrhint UNNEEDED)
{ fprintf(stderr, "try_reconnect called!\n"); abort(); }
/* Generated stub for version */
const char *version(void)
{ fprintf(stderr, "version called!\n"); abort(); }
/* Generated stub for wallet_annotate_txout */
void wallet_annotate_txout(struct wallet *w UNNEEDED,
			   const struct bitcoin_outpoint *outpoint UNNEEDED,
			   enum wallet_tx_type type UNNEEDED, u64 channel UNNEEDED)
{ fprintf(stderr, "wallet_annotate_txout called!\n"); abort(); }
/* Generated stub for wallet_channel_save */
void wallet_channel_save(struct wallet *w UNNEEDED, struct channel *chan UNNEEDED)
{ fprintf(stderr, "wallet_channel_save called!\n"); abort(); }
/* Generated stub for wallet_channel_stats_load */
void wallet_channel_stats_load(struct wallet *w UNNEEDED, u64 cdbid UNNEEDED, struct channel_stats *stats UNNEEDED)
{ fprintf(stderr, "wallet_channel_stats_load called!\n"); abort(); }
/* Generated stub for wallet_channeltxs_add */
void wallet_channeltxs_add(struct wallet *w UNNEEDED, struct channel *chan UNNEEDED,
			    const int type UNNEEDED, const struct bitcoin_txid *txid UNNEEDED,
			   const u32 input_num UNNEEDED, const u32 blockheight UNNEEDED)
{ fprintf(stderr, "wallet_channeltxs_add called!\n"); abort(); }
/* Generated stub for wallet_delete_peer_if_unused */
void wallet_delete_peer_if_unused(struct wallet *w UNNEEDED, u64 peer_dbid UNNEEDED)
{ fprintf(stderr, "wallet_delete_peer_if_unused called!\n"); abort(); }
/* Generated stub for wallet_htlcs_load_in_for_channel */
bool wallet_htlcs_load_in_for_channel(struct wallet *wallet UNNEEDED,
				      struct channel *chan UNNEEDED,
				      struct htlc_in_map *htlcs_in UNNEEDED)
{ fprintf(stderr, "wallet_htlcs_load_in_for_channel called!\n"); abort(); }
/* Generated stub for wallet_htlcs_load_out_for_channel */
bool wallet_htlcs_load_out_for_channel(struct wallet *wallet UNNEEDED,
				       struct channel *chan UNNEEDED,
				       struct htlc_out_map *htlcs_out UNNEEDED,
				       struct htlc_in_map *remaining_htlcs_in UNNEEDED)
{ fprintf(stderr, "wallet_htlcs_load_out_for_channel called!\n"); abort(); }
/* Generated stub for wallet_init_channels */
bool wallet_init_channels(struct wallet *w UNNEEDED)
{ fprintf(stderr, "wallet_init_channels called!\n"); abort(); }
/* Generated stub for wallet_invoice_create */
bool wallet_invoice_create(struct wallet *wallet UNNEEDED,
			   struct invoice *pinvoice UNNEEDED,
			   const struct amount_msat *msat TAKES UNNEEDED,
			   const struct json_escape *label TAKES UNNEEDED,
			   u64 expiry UNNEEDED,
			   const char *b11enc UNNEEDED,
			   const char *description UNNEEDED,
			   const u8 *features UNNEEDED,
			   const struct preimage *r UNNEEDED,
			   const struct sha256 *rhash UNNEEDED,
			   const struct sha256 *local_offer_id UNNEEDED)
{ fprintf(stderr, "wallet_invoice_create called!\n"); abort(); }
/* Generated stub for wallet_invoice_delete */
bool wallet_invoice_delete(struct wallet *wallet UNNEEDED,
			   struct invoice invoice UNNEEDED)
{ fprintf(stderr, "wallet_invoice_delete called!\n"); abort(); }
/* Generated stub for wallet_invoice_delete_description */
bool wallet_invoice_delete_description(struct wallet *wallet UNNEEDED,
				       struct invoice invoice UNNEEDED)
{ fprintf(stderr, "wallet_invoice_delete_description called!\n"); abort(); }
/* Generated stub for wallet_invoice_delete_expired */
void wallet_invoice_delete_expired(struct wallet *wallet UNNEEDED,
				   u64 max_expiry_time UNNEEDED)
{ fprintf(stderr, "wallet_invoice_delete_expired called!\n"); abort(); }
/* Generated stub for wallet_invoice_details */
struct invoice_details *wallet_invoice_details(const tal_t *ctx UNNEEDED,
					       struct wallet *wallet UNNEEDED,
					       struct invoice invoice UNNEEDED)
{ fprintf(stderr, "wallet_invoice_details called!\n"); abort(); }
/* Generated stub for wallet_invoice_find_by_label */
bool wallet_invoice_find_by_label(struct wallet *wallet UNNEEDED,
				  struct invoice *pinvoice UNNEEDED,
				  const struct json_escape *label UNNEEDED)
{ fprintf(stderr, "wallet_invoice_find_by_label called!\n"); abort(); }
/* Generated stub for wallet_invoice_find_by_rhash */
bool wallet_invoice_find_by_rhash(struct wallet *wallet UNNEEDED,
				  struct invoice *pinvoice UNNEEDED,
				  const struct sha256 *rhash UNNEEDED)
{ fprintf(stderr, "wallet_invoice_find_by_rhash called!\n"); abort(); }
/* Generated stub for wallet_invoice_find_unpaid */
bool wallet_invoice_find_unpaid(struct wallet *wallet UNNEEDED,
				struct invoice *pinvoice UNNEEDED,
				const struct sha256 *rhash UNNEEDED)
{ fprintf(stderr, "wallet_invoice_find_unpaid called!\n"); abort(); }
/* Generated stub for wallet_invoice_iterate */
bool wallet_invoice_iterate(struct wallet *wallet UNNEEDED,
			    struct invoice_iterator *it UNNEEDED)
{ fprintf(stderr, "wallet_invoice_iterate called!\n"); abort(); }
/* Generated stub for wallet_invoice_iterator_deref */
const struct invoice_details *wallet_invoice_iterator_deref(const tal_t *ctx UNNEEDED,
			      struct wallet *wallet UNNEEDED,
			      const struct invoice_iterator *it UNNEEDED)
{ fprintf(stderr, "wallet_invoice_iterator_deref called!\n"); abort(); }
/* Generated stub for wallet_invoice_resolve */
bool wallet_invoice_resolve(struct wallet *wallet UNNEEDED,
			    struct invoice invoice UNNEEDED,
			    struct amount_msat received UNNEEDED)
{ fprintf(stderr, "wallet_invoice_resolve called!\n"); abort(); }
/* Generated stub for wallet_invoice_waitany */
void wallet_invoice_waitany(const tal_t *ctx UNNEEDED,
			    struct wallet *wallet UNNEEDED,
			    u64 lastpay_index UNNEEDED,
			    void (*cb)(const struct invoice * UNNEEDED, void*) UNNEEDED,
			    void *cbarg UNNEEDED)
{ fprintf(stderr, "wallet_invoice_waitany called!\n"); abort(); }
/* Generated stub for wallet_invoice_waitone */
void wallet_invoice_waitone(const tal_t *ctx UNNEEDED,
			    struct wallet *wallet UNNEEDED,
			    struct invoice invoice UNNEEDED,
			    void (*cb)(const struct invoice * UNNEEDED, void*) UNNEEDED,
			    void *cbarg UNNEEDED)
{ fprintf(stderr, "wallet_invoice_waitone called!\n"); abort(); }
/* Generated stub for wallet_offer_find */
char *wallet_offer_find(const tal_t *ctx UNNEEDED,
			struct wallet *w UNNEEDED,
			const struct sha256 *offer_id UNNEEDED,
			const struct json_escape **label UNNEEDED,
			enum offer_status *status)

{ fprintf(stderr, "wallet_offer_find called!\n"); abort(); }
/* Generated stub for wallet_state_change_get */
struct state_change_entry *wallet_state_change_get(struct wallet *w UNNEEDED,
						   const tal_t *ctx UNNEEDED,
						   u64 channel_id UNNEEDED)
{ fprintf(stderr, "wallet_state_change_get called!\n"); abort(); }
/* Generated stub for wallet_total_forward_fees */
struct amount_msat wallet_total_forward_fees(struct wallet *w UNNEEDED)
{ fprintf(stderr, "wallet_total_forward_fees called!\n"); abort(); }
/* Generated stub for wallet_transaction_add */
void wallet_transaction_add(struct wallet *w UNNEEDED, const struct wally_tx *tx UNNEEDED,
			    const u32 blockheight UNNEEDED, const u32 txindex UNNEEDED)
{ fprintf(stderr, "wallet_transaction_add called!\n"); abort(); }
/* Generated stub for wallet_transaction_locate */
struct txlocator *wallet_transaction_locate(const tal_t *ctx UNNEEDED, struct wallet *w UNNEEDED,
					    const struct bitcoin_txid *txid UNNEEDED)
{ fprintf(stderr, "wallet_transaction_locate called!\n"); abort(); }
/* Generated stub for watch_txid */
struct txwatch *watch_txid(const tal_t *ctx UNNEEDED,
			   struct chain_topology *topo UNNEEDED,
			   struct channel *channel UNNEEDED,
			   const struct bitcoin_txid *txid UNNEEDED,
			   enum watch_result (*cb)(struct lightningd *ld UNNEEDED,
						   struct channel * UNNEEDED,
						   const struct bitcoin_txid * UNNEEDED,
						   const struct bitcoin_tx * UNNEEDED,
						   unsigned int depth))
{ fprintf(stderr, "watch_txid called!\n"); abort(); }
/* Generated stub for watch_txo */
struct txowatch *watch_txo(const tal_t *ctx UNNEEDED,
			   struct chain_topology *topo UNNEEDED,
			   struct channel *channel UNNEEDED,
			   const struct bitcoin_outpoint *outpoint UNNEEDED,
			   enum watch_result (*cb)(struct channel * UNNEEDED,
						   const struct bitcoin_tx *tx UNNEEDED,
						   size_t input_num UNNEEDED,
						   const struct block *block))
{ fprintf(stderr, "watch_txo called!\n"); abort(); }
/* AUTOGENERATED MOCKS END */

#if DEVELOPER
/* Generated stub for dev_disconnect_permanent */
bool dev_disconnect_permanent(struct lightningd *ld UNNEEDED)
{ fprintf(stderr, "dev_disconnect_permanent called!\n"); abort(); }
#endif

static void add_candidate(struct routehint_candidate **candidates, int n,
			  struct channel *c)
{
	struct routehint_candidate candidate;

	candidate.r = tal(*candidates, struct route_info);
	memset(&candidate.r->pubkey, n, sizeof(candidate.r->pubkey));
	memset(&candidate.r->short_channel_id, n,
	       sizeof(candidate.r->short_channel_id));
	candidate.r->fee_base_msat
		= candidate.r->fee_proportional_millionths
		= candidate.r->cltv_expiry_delta
		= n;
	candidate.c = c;
	candidate.capacity = amount_msat(n * 1000 - 1);
	tal_arr_expand(candidates, candidate);
}

static struct channel *add_peer(struct lightningd *ld, int n,
				enum channel_state state,
				bool connected)
{
	struct peer *peer = tal(ld, struct peer);
	struct channel *c = tal(peer, struct channel);

	memset(&peer->id, n, sizeof(peer->id));
	list_head_init(&peer->channels);
	peer_node_id_map_add(ld->peers, peer);
	peer->ld = ld;

	c->state = state;
	c->owner = connected ? (void *)peer : NULL;
	c->opener = LOCAL;
	c->peer = peer;
	/* Channel has incoming capacity n*1000 - 1 millisatoshi */
	c->funding_sats.satoshis = n+1;
	c->our_msat = AMOUNT_MSAT(1);
	c->our_config.channel_reserve = AMOUNT_SAT(1);
	c->our_config.htlc_minimum = AMOUNT_MSAT(0);
	c->channel_info.their_config.channel_reserve = AMOUNT_SAT(0);
	list_add_tail(&peer->channels, &c->list);

	return c;
}

/* There *is* padding in this structure, after pubkey and after cltv_expiry_delta. */
STRUCTEQ_DEF(route_info,
	     ALIGNOF(struct short_channel_id) - 1 - sizeof(u16),
	     pubkey,
	     cltv_expiry_delta,
	     short_channel_id,
	     fee_base_msat,
	     fee_proportional_millionths);

int main(int argc, char *argv[])
{
	struct lightningd *ld;
	struct routehint_candidate *candidates;
	struct route_info **ret;
	size_t n;

	common_setup(argv[0]);
	ld = tal(tmpctx, struct lightningd);

	ld->peers = tal(ld, struct peer_node_id_map);
	peer_node_id_map_init(ld->peers);
	ld->htlcs_in = tal(ld, struct htlc_in_map);
	htlc_in_map_init(ld->htlcs_in);
	chainparams = chainparams_for_network("regtest");

	candidates = tal_arr(tmpctx, struct routehint_candidate, 0);

	/* 1. Nothing to choose from -> NULL result. */
	ret = select_inchan(tmpctx, ld, AMOUNT_MSAT(0), candidates);
	assert(tal_count(ret) == 0);

	/* 2. One peer (999 msat capacity) */
	add_candidate(&candidates, 1, add_peer(ld, 1, CHANNELD_NORMAL, true));
	ret = select_inchan(tmpctx, ld, AMOUNT_MSAT(1000), candidates);
	assert(tal_count(ret) == 0);

	ret = select_inchan(tmpctx, ld, AMOUNT_MSAT(999), candidates);
	assert(tal_count(ret) == 1);
	assert(tal_count(ret[0]) == 1);
	assert(route_info_eq(ret[0], candidates[0].r));

	/* 3. Two peers (999 msat capacity and 1999 msat) */
	add_candidate(&candidates, 2, add_peer(ld, 2, CHANNELD_NORMAL, true));

	ret = select_inchan(tmpctx, ld, AMOUNT_MSAT(1000), candidates);
	assert(tal_count(ret) == 1);
	assert(tal_count(ret[0]) == 1);
	assert(route_info_eq(ret[0], candidates[1].r));

	/* 7. Correct peer with just enough capacity_to_pay_us */
	ret = select_inchan(tmpctx, ld, AMOUNT_MSAT(1999), candidates);
	assert(tal_count(ret) == 1);
	assert(tal_count(ret[0]) == 1);
	assert(route_info_eq(ret[0], candidates[1].r));

	/* 8. Not if we ask for too much! Our balance is 1msat. */
	ret = select_inchan(tmpctx, ld, AMOUNT_MSAT(2000), candidates);
	assert(tal_count(ret) == 0);

	/* 9. Add another peer (2999 capacity) */
	add_candidate(&candidates, 3, add_peer(ld, 3, CHANNELD_NORMAL, true));

	/* Simulate selection ratios between excesses 25% and 50% of capacity*/
	for (size_t i = n = 0; i < 1000; i++) {
		ret = select_inchan(tmpctx, ld, AMOUNT_MSAT(1499), candidates);
		assert(tal_count(ret) == 1);
		assert(tal_count(ret[0]) == 1);
		assert(route_info_eq(ret[0], candidates[1].r)
		       || route_info_eq(ret[0], candidates[2].r));
		n += route_info_eq(ret[0], candidates[1].r);
	}

	/* Handwave over probability of this happening!  Within 20% */
	printf("Number of selections with excess 25 percent of capacity: %zu\n"
	       "Number of selections with excess 50 percent of capacity: %zu\n",
	       n, 1000 - n);
	assert(n > 333 - 66 && n < 333 + 66);

	/* 10. Last peer's capacity goes from 3 to 2 sat */
	candidates[2].c->channel_info.their_config.channel_reserve = AMOUNT_SAT(1);

	for (size_t i = n = 0; i < 1000; i++) {
		ret = select_inchan(tmpctx, ld, AMOUNT_MSAT(1499), candidates);
		assert(tal_count(ret) == 1);
		assert(tal_count(ret[0]) == 1);
		assert(route_info_eq(ret[0], candidates[1].r)
		       || route_info_eq(ret[0], candidates[2].r));
		n += route_info_eq(ret[0], candidates[1].r);
	}

	/* Handwave over probability of this happening!  Within 20% */
	printf("Number of selections with excess 25 percent of capacity: %zu\n"
	       "Number of selections with excess 75 percent of capacity: %zu\n",
	       n, 1000 - n);
	assert(n > 250 - 50 && n < 250 + 50);

	common_shutdown();

	/* FIXME: Do BOLT comparison! */
	return 0;
}
