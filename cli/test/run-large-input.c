#include "config.h"
#include <assert.h>
#include <common/amount.h>
#include <common/bigsize.h>
#include <common/json_stream.h>
#include <common/wireaddr.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

int test_main(int argc, char *argv[]);
ssize_t test_read(int fd, void *buf, size_t len);
int test_socket(int domain, int type, int protocol);
int test_connect(int sockfd, const struct sockaddr *addr,
		 socklen_t addrlen);
int test_getpid(void);
int test_printf(const char *format, ...);
int test_chdir(const char *path);

#define main test_main
#define read test_read
#define socket test_socket
#define connect test_connect
#define getpid test_getpid
#define printf test_printf
#define chdir test_chdir

  #include "../lightning-cli.c"
#undef main

/* AUTOGENERATED MOCKS START */
/* Generated stub for amount_asset_is_main */
bool amount_asset_is_main(struct amount_asset *asset UNNEEDED)
{ fprintf(stderr, "amount_asset_is_main called!\n"); abort(); }
/* Generated stub for amount_asset_to_sat */
struct amount_sat amount_asset_to_sat(struct amount_asset *asset UNNEEDED)
{ fprintf(stderr, "amount_asset_to_sat called!\n"); abort(); }
/* Generated stub for amount_sat_add */
 bool amount_sat_add(struct amount_sat *val UNNEEDED,
				       struct amount_sat a UNNEEDED,
				       struct amount_sat b UNNEEDED)
{ fprintf(stderr, "amount_sat_add called!\n"); abort(); }
/* Generated stub for amount_sat_eq */
bool amount_sat_eq(struct amount_sat a UNNEEDED, struct amount_sat b UNNEEDED)
{ fprintf(stderr, "amount_sat_eq called!\n"); abort(); }
/* Generated stub for amount_sat_sub */
 bool amount_sat_sub(struct amount_sat *val UNNEEDED,
				       struct amount_sat a UNNEEDED,
				       struct amount_sat b UNNEEDED)
{ fprintf(stderr, "amount_sat_sub called!\n"); abort(); }
/* Generated stub for amount_sat_to_msat */
 bool amount_sat_to_msat(struct amount_msat *msat UNNEEDED,
					   struct amount_sat sat UNNEEDED)
{ fprintf(stderr, "amount_sat_to_msat called!\n"); abort(); }
/* Generated stub for bigsize_get */
size_t bigsize_get(const u8 *p UNNEEDED, size_t max UNNEEDED, bigsize_t *val UNNEEDED)
{ fprintf(stderr, "bigsize_get called!\n"); abort(); }
/* Generated stub for bigsize_put */
size_t bigsize_put(u8 buf[BIGSIZE_MAX_LEN] UNNEEDED, bigsize_t v UNNEEDED)
{ fprintf(stderr, "bigsize_put called!\n"); abort(); }
/* Generated stub for fmt_wireaddr_without_port */
char *fmt_wireaddr_without_port(const tal_t *ctx UNNEEDED, const struct wireaddr *a UNNEEDED)
{ fprintf(stderr, "fmt_wireaddr_without_port called!\n"); abort(); }
/* Generated stub for json_add_member */
void json_add_member(struct json_stream *js UNNEEDED,
		     const char *fieldname UNNEEDED,
		     bool quote UNNEEDED,
		     const char *fmt UNNEEDED, ...)
{ fprintf(stderr, "json_add_member called!\n"); abort(); }
/* Generated stub for json_array_end */
void json_array_end(struct json_stream *js UNNEEDED)
{ fprintf(stderr, "json_array_end called!\n"); abort(); }
/* Generated stub for json_array_start */
void json_array_start(struct json_stream *js UNNEEDED, const char *fieldname UNNEEDED)
{ fprintf(stderr, "json_array_start called!\n"); abort(); }
/* Generated stub for json_member_direct */
char *json_member_direct(struct json_stream *js UNNEEDED,
			 const char *fieldname UNNEEDED, size_t extra UNNEEDED)
{ fprintf(stderr, "json_member_direct called!\n"); abort(); }
/* Generated stub for json_object_end */
void json_object_end(struct json_stream *js UNNEEDED)
{ fprintf(stderr, "json_object_end called!\n"); abort(); }
/* Generated stub for json_object_start */
void json_object_start(struct json_stream *ks UNNEEDED, const char *fieldname UNNEEDED)
{ fprintf(stderr, "json_object_start called!\n"); abort(); }
/* Generated stub for version_and_exit */
char *version_and_exit(const void *unused UNNEEDED)
{ fprintf(stderr, "version_and_exit called!\n"); abort(); }
/* AUTOGENERATED MOCKS END */

int test_socket(int domain UNUSED, int type UNUSED, int protocol UNUSED)
{
	/* We give a real fd, as it writes to it */
	return open("/dev/null", O_WRONLY);
}

int test_connect(int sockfd UNUSED, const struct sockaddr *addr UNUSED,
		 socklen_t addrlen UNUSED)
{
	return 0;
}

int test_getpid(void)
{
	return 9999;
}

int test_printf(const char *fmt UNUSED, ...)
{
	return 0;
}

int test_chdir(const char *path)
{
	return 0;
}

static char *response;
static size_t response_off, max_read_return;

ssize_t test_read(int fd UNUSED, void *buf, size_t len)
{
	if (len > max_read_return)
		len = max_read_return;
	if (len > strlen(response + response_off))
		len = strlen(response + response_off);

	memcpy(buf, response + response_off, len);
	response_off += len;
	return len;
}

/* Simulate a real log file I captured */
#define NUM_ENTRIES (137772/2)

#define HEADER "{ \"jsonrpc\": \"2.0\",\n"				\
	       "    \"id\": \"lightning-cli-9999\",\n"			\
	       "    \"result\" : {\n"					\
	       "        \"creation_time\" : \"1515999039.806099043\",\n" \
	       "        \"bytes_used\" : 10787759,\n"			\
	       "        \"bytes_max\" : 20971520,\n"			\
	       "        \"log\" : [\n"
#define LOG_ENTRY							\
	"            {\"type\": \"SKIPPED\", \"num_skipped\": 22},\n"	\
	"            {\"type\": \"DEBUG\", \"time\": \"241693.051558854\", \"source\": \"lightning_gossipd(14581):\", \"log\": \"TRACE: nonlocal_gossip_broadcast_done\"},\n"
#define TAILER	"] } }"

int main(int argc UNUSED, char *argv[])
{
	setup_locale();

	char *fake_argv[] = { argv[0], "--lightning-dir=/tmp/", "test", NULL };

	/* sizeof() is an overestimate, but we don't care. */
	response = tal_arr(NULL, char,
			   sizeof(HEADER)
			   + sizeof(LOG_ENTRY) * NUM_ENTRIES
			   + sizeof(TAILER));

	strcpy(response, HEADER);
	response_off = strlen(HEADER);

	/* Append a huge log */
	for (size_t i = 0; i < NUM_ENTRIES; i++) {
		memcpy(response + response_off, LOG_ENTRY, sizeof(LOG_ENTRY)-1);
		response_off += sizeof(LOG_ENTRY)-1;
	}

	memcpy(response + response_off, TAILER, sizeof(TAILER)-1);
	response_off += sizeof(TAILER)-1;
	response[response_off++] = '\0';
	assert(strlen(response) == response_off - 1);
	assert(response_off < tal_count(response));

	response_off = 0;
	max_read_return = -1;
	assert(test_main(3, fake_argv) == 0);
	tal_free(response);
	assert(!taken_any());
	take_cleanup();
	return 0;
}
