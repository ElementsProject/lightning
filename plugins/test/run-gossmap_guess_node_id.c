/* Test conversion assumptions used by gossmap_guess_node_id */
#include "config.h"

#include <assert.h>
#include <bitcoin/privkey.h>
#include <common/amount.h>
#include <common/bigsize.h>
#include <common/channel_id.h>
#include <common/setup.h>
#include <stdio.h>
#include <wire/wire.h>
  #include "../pay_point32.c"

/* AUTOGENERATED MOCKS START */
/* Generated stub for fromwire_bigsize */
bigsize_t fromwire_bigsize(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_bigsize called!\n"); abort(); }
/* Generated stub for fromwire_channel_id */
bool fromwire_channel_id(const u8 **cursor UNNEEDED, size_t *max UNNEEDED,
			 struct channel_id *channel_id UNNEEDED)
{ fprintf(stderr, "fromwire_channel_id called!\n"); abort(); }
/* Generated stub for fromwire_node_id */
void fromwire_node_id(const u8 **cursor UNNEEDED, size_t *max UNNEEDED, struct node_id *id UNNEEDED)
{ fprintf(stderr, "fromwire_node_id called!\n"); abort(); }
/* Generated stub for gossmap_find_node */
struct gossmap_node *gossmap_find_node(const struct gossmap *map UNNEEDED,
				       const struct node_id *id UNNEEDED)
{ fprintf(stderr, "gossmap_find_node called!\n"); abort(); }
/* Generated stub for node_id_from_pubkey */
void node_id_from_pubkey(struct node_id *id UNNEEDED, const struct pubkey *key UNNEEDED)
{ fprintf(stderr, "node_id_from_pubkey called!\n"); abort(); }
/* Generated stub for towire_bigsize */
void towire_bigsize(u8 **pptr UNNEEDED, const bigsize_t val UNNEEDED)
{ fprintf(stderr, "towire_bigsize called!\n"); abort(); }
/* Generated stub for towire_channel_id */
void towire_channel_id(u8 **pptr UNNEEDED, const struct channel_id *channel_id UNNEEDED)
{ fprintf(stderr, "towire_channel_id called!\n"); abort(); }
/* Generated stub for towire_node_id */
void towire_node_id(u8 **pptr UNNEEDED, const struct node_id *id UNNEEDED)
{ fprintf(stderr, "towire_node_id called!\n"); abort(); }
/* AUTOGENERATED MOCKS END */

int main(int argc, char *argv[])
{
	common_setup(argv[0]);

	for (size_t i = 1; i < 255; i++) {
		struct privkey priv;
		secp256k1_keypair keypair;
		secp256k1_pubkey pubkey;
		secp256k1_xonly_pubkey xpubkey;
		u8 output32[32];
		u8 output33[33];
		size_t len = sizeof(output33);

		memset(&priv, i, sizeof(priv));
		assert(secp256k1_keypair_create(secp256k1_ctx, &keypair, priv.secret.data) == 1);
		assert(secp256k1_keypair_pub(secp256k1_ctx, &pubkey, &keypair) == 1);
		assert(secp256k1_keypair_xonly_pub(secp256k1_ctx, &xpubkey, NULL, &keypair) == 1);

		assert(secp256k1_xonly_pubkey_serialize(secp256k1_ctx, output32, &xpubkey) == 1);
		assert(secp256k1_ec_pubkey_serialize(secp256k1_ctx, output33, &len, &pubkey, SECP256K1_EC_COMPRESSED) == 1);
		assert(memcmp(output32, output33 + 1, sizeof(output32)) == 0);
		assert(output33[0] == SECP256K1_TAG_PUBKEY_EVEN
		       || output33[0] == SECP256K1_TAG_PUBKEY_ODD);
	}
	common_shutdown();
}
