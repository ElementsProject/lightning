#include "config.h"
#include <stdio.h>
#include <assert.h>
#include <common/wireaddr.h>
#include <common/bigsize.h>
#include <common/channel_id.h>
#include <common/setup.h>
#include <common/utils.h>
#include <common/node_id.h>
#include <ccan/read_write_all/read_write_all.h>

#include "../mcf.c"

/* AUTOGENERATED MOCKS START */
/* Generated stub for flow_complete */
bool flow_complete(const tal_t *ctx UNNEEDED, struct flow *flow UNNEEDED,
		   const struct gossmap *gossmap UNNEEDED,
		   struct chan_extra_map *chan_extra_map UNNEEDED,
		   struct amount_msat delivered UNNEEDED, char **fail UNNEEDED)
{ fprintf(stderr, "flow_complete called!\n"); abort(); }
/* Generated stub for flowset_fee */
bool flowset_fee(struct amount_msat *fee UNNEEDED, struct flow **flows UNNEEDED)
{ fprintf(stderr, "flowset_fee called!\n"); abort(); }
/* Generated stub for flowset_probability */
double flowset_probability(const tal_t *ctx UNNEEDED, struct flow **flows UNNEEDED,
			   const struct gossmap *const gossmap UNNEEDED,
			   struct chan_extra_map *chan_extra_map UNNEEDED, char **fail UNNEEDED)
{ fprintf(stderr, "flowset_probability called!\n"); abort(); }
/* Generated stub for get_chan_extra_half_by_chan */
struct chan_extra_half *get_chan_extra_half_by_chan(const struct gossmap *gossmap UNNEEDED,
						    struct chan_extra_map *chan_extra_map UNNEEDED,
						    const struct gossmap_chan *chan UNNEEDED,
						    int dir UNNEEDED)
{ fprintf(stderr, "get_chan_extra_half_by_chan called!\n"); abort(); }
/* Generated stub for linear_fee_cost */
s64 linear_fee_cost(
		const struct gossmap_chan *c UNNEEDED,
		const int dir UNNEEDED,
		double base_fee_penalty UNNEEDED,
		double delay_feefactor UNNEEDED)
{ fprintf(stderr, "linear_fee_cost called!\n"); abort(); }
/* Generated stub for pay_plugin */
struct pay_plugin *pay_plugin;
/* AUTOGENERATED MOCKS END */

int main(int argc, char *argv[])
{
	bool dual;
	u32 part;
	int chandir;
	u32 chanidx;

	common_setup(argv[0]);

	for (int i = 0; i < 32; i++) {
		for (int j = 0; j < 32; j++) {
			for (int k = 0; k < 32; k++) {
				struct arc a, a2;

				a.idx = (1U << i) | (1U << j) | (1U << k);
				arc_to_parts(a, &chanidx, &chandir, &part, &dual);
				a2 = arc_from_parts(chanidx, chandir, part, dual);
				assert(a.idx == a2.idx);
			}
		}
	}

	/* Test all chanidx */
	for (int i = 0; i < (1U << ARC_CHANIDX_BITS); i++) {
		struct arc a = arc_from_parts(i, chandir, part, dual);

		arc_to_parts(a, &chanidx, NULL, NULL, NULL);
		assert(chanidx == i);
	}

	/* Test both chandir */
	for (int i = 0; i < 2; i++) {
		struct arc a = arc_from_parts(chanidx, i, part, dual);

		arc_to_parts(a, NULL, &chandir, NULL, NULL);
		assert(chandir == i);
	}

	/* Test all parts */
	for (int i = 0; i < CHANNEL_PARTS; i++) {
		struct arc a = arc_from_parts(chanidx, chandir, i, dual);

		arc_to_parts(a, NULL, NULL, &part, NULL);
		assert(part == i);
	}

	/* Test both dual */
	for (int i = 0; i < 2; i++) {
		struct arc a = arc_from_parts(chanidx, chandir, part, i);

		arc_to_parts(a, NULL, NULL, NULL, &dual);
		assert(dual == i);

		assert(arc_is_dual(a) == dual);

		a = arc_dual(a);
		arc_to_parts(a, NULL, NULL, NULL, &dual);
		assert(dual == !i);
		assert(arc_is_dual(a) == dual);
	}

	common_shutdown();
}

