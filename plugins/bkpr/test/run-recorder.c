#include "config.h"
#include "common/json_filter.c"
#include "test_utils.h"

#include <bitcoin/tx.h>
#include <ccan/tal/str/str.h>
#include <common/coin_mvt.h>
#include <common/daemon.h>
#include <common/deprecation.h>
#include <common/fee_states.h>
#include <common/htlc.h>
#include <common/json_param.h>
#include <common/json_parse_simple.h>
#include <common/json_stream.h>
#include <common/plugin.h>
#include <common/setup.h>
#include <common/trace.h>
#include <common/utils.h>
#include <db/common.h>
#include <plugins/bkpr/account.h>
#include <plugins/bkpr/account_entry.h>
#include <plugins/bkpr/bookkeeper.h>
#include <plugins/bkpr/chain_event.h>
#include <plugins/bkpr/channel_event.h>
#include <plugins/bkpr/onchain_fee.h>
#include <plugins/bkpr/recorder.h>
#include <plugins/libplugin.h>
#include <stdio.h>
#include <unistd.h>
#include <wire/wire.h>

#include "plugins/bkpr/db.c"
#include "plugins/bkpr/account.c"
#include "plugins/bkpr/recorder.c"
#include "plugins/bkpr/onchain_fee.c"
#include "plugins/bkpr/rebalances.c"

/* AUTOGENERATED MOCKS START */
/* Generated stub for command_fail_badparam */
struct command_result *command_fail_badparam(struct command *cmd UNNEEDED,
					     const char *paramname UNNEEDED,
					     const char *buffer UNNEEDED,
					     const jsmntok_t *tok UNNEEDED,
					     const char *msg UNNEEDED)
{ fprintf(stderr, "command_fail_badparam called!\n"); abort(); }
/* Generated stub for command_filter_ptr */
struct json_filter **command_filter_ptr(struct command *cmd UNNEEDED)
{ fprintf(stderr, "command_filter_ptr called!\n"); abort(); }
/* Generated stub for first_fee_state */
enum htlc_state first_fee_state(enum side opener UNNEEDED)
{ fprintf(stderr, "first_fee_state called!\n"); abort(); }
/* Generated stub for fmt_wireaddr_without_port */
char *fmt_wireaddr_without_port(const tal_t *ctx UNNEEDED, const struct wireaddr *a UNNEEDED)
{ fprintf(stderr, "fmt_wireaddr_without_port called!\n"); abort(); }
/* Generated stub for fromwire_wireaddr */
bool fromwire_wireaddr(const u8 **cursor UNNEEDED, size_t *max UNNEEDED, struct wireaddr *addr UNNEEDED)
{ fprintf(stderr, "fromwire_wireaddr called!\n"); abort(); }
/* Generated stub for htlc_state_flags */
int htlc_state_flags(enum htlc_state state UNNEEDED)
{ fprintf(stderr, "htlc_state_flags called!\n"); abort(); }
/* Generated stub for htlc_state_name */
const char *htlc_state_name(enum htlc_state s UNNEEDED)
{ fprintf(stderr, "htlc_state_name called!\n"); abort(); }
/* Generated stub for ignore_datastore_reply */
struct command_result *ignore_datastore_reply(struct command *cmd UNNEEDED,
					      const char *method UNNEEDED,
					      const char *buf UNNEEDED,
					      const jsmntok_t *result UNNEEDED,
					      void *arg UNNEEDED)
{ fprintf(stderr, "ignore_datastore_reply called!\n"); abort(); }
/* Generated stub for json_tok_bin_from_hex */
u8 *json_tok_bin_from_hex(const tal_t *ctx UNNEEDED, const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED)
{ fprintf(stderr, "json_tok_bin_from_hex called!\n"); abort(); }
/* Generated stub for jsonrpc_request_sync */
const jsmntok_t *jsonrpc_request_sync(const tal_t *ctx UNNEEDED,
				      struct command *init_cmd UNNEEDED,
				      const char *method UNNEEDED,
				      const struct json_out *params TAKES UNNEEDED,
				      const char **resp UNNEEDED)
{ fprintf(stderr, "jsonrpc_request_sync called!\n"); abort(); }
/* Generated stub for jsonrpc_set_datastore_ */
struct command_result *jsonrpc_set_datastore_(struct command *cmd UNNEEDED,
					      const char *path UNNEEDED,
					      const void *value UNNEEDED,
					      int len_or_str UNNEEDED,
					      const char *mode UNNEEDED,
					      struct command_result *(*cb)(struct command *command UNNEEDED,
									   const char *method UNNEEDED,
									   const char *buf UNNEEDED,
									   const jsmntok_t *result UNNEEDED,
									   void *arg) UNNEEDED,
					      struct command_result *(*errcb)(struct command *command UNNEEDED,
									      const char *method UNNEEDED,
									      const char *buf UNNEEDED,
									      const jsmntok_t *result UNNEEDED,
									      void *arg) UNNEEDED,
					      void *arg)

{ fprintf(stderr, "jsonrpc_set_datastore_ called!\n"); abort(); }
/* Generated stub for last_fee_state */
enum htlc_state last_fee_state(enum side opener UNNEEDED)
{ fprintf(stderr, "last_fee_state called!\n"); abort(); }
/* Generated stub for plugin_developer_mode */
bool plugin_developer_mode(const struct plugin *plugin UNNEEDED)
{ fprintf(stderr, "plugin_developer_mode called!\n"); abort(); }
/* Generated stub for plugin_err */
void   plugin_err(struct plugin *p UNNEEDED, const char *fmt UNNEEDED, ...)
{ fprintf(stderr, "plugin_err called!\n"); abort(); }
/* Generated stub for plugin_log */
void plugin_log(struct plugin *p UNNEEDED, enum log_level l UNNEEDED, const char *fmt UNNEEDED, ...)
{ fprintf(stderr, "plugin_log called!\n"); abort(); }
/* Generated stub for plugin_logv */
void plugin_logv(struct plugin *p UNNEEDED, enum log_level l UNNEEDED, const char *fmt UNNEEDED, va_list ap UNNEEDED)
{ fprintf(stderr, "plugin_logv called!\n"); abort(); }
/* Generated stub for send_backtrace */
void send_backtrace(const char *why UNNEEDED)
{ fprintf(stderr, "send_backtrace called!\n"); abort(); }
/* Generated stub for split_tok */
bool split_tok(const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED,
				char split UNNEEDED,
				jsmntok_t *a UNNEEDED,
				jsmntok_t *b UNNEEDED)
{ fprintf(stderr, "split_tok called!\n"); abort(); }
/* AUTOGENERATED MOCKS END */

static char *tmp_dsn(const tal_t *ctx)
{
	char *dsn, *filename;
	int fd = tmpdir_mkstemp(ctx, "lacct-db-XXXXXX", &filename);
	if (fd == -1)
		return NULL;
	close(fd);

	dsn = tal_fmt(ctx, "sqlite3://%s", filename);
	tal_free(filename);

	return dsn;
}

static struct bkpr *bkpr_setup(const tal_t *ctx)
{
	struct bkpr *bkpr = tal(ctx, struct bkpr);

	bkpr->db = db_setup(bkpr, NULL, tmp_dsn(ctx));
	bkpr->accounts = init_accounts(ctx, NULL);
	bkpr->onchain_fees = init_onchain_fees(bkpr, NULL);
	bkpr->rebalances = init_rebalances(bkpr, NULL);
	return bkpr;
}

static bool accountseq(struct account *a1, struct account *a2)
{
	CHECK(streq(a1->name, a2->name));
	CHECK((a1->peer_id != NULL) == (a2->peer_id != NULL));
	if (a1->peer_id)
		CHECK(node_id_eq(a1->peer_id, a2->peer_id));
	CHECK(a1->is_wallet == a2->is_wallet);
	CHECK(a1->we_opened == a2->we_opened);
	CHECK(a1->leased == a2->leased);
	CHECK(a1->onchain_resolved_block == a2->onchain_resolved_block);

	CHECK((a1->open_event_db_id != NULL) == (a2->open_event_db_id != NULL));
	if (a1->open_event_db_id)
		CHECK(*a1->open_event_db_id == *a2->open_event_db_id);

	CHECK((a1->closed_event_db_id != NULL) == (a2->closed_event_db_id != NULL));
	if (a1->closed_event_db_id)
		CHECK(*a1->closed_event_db_id == *a2->closed_event_db_id);

	CHECK(a1->closed_count == a2->closed_count);

	return true;
}

static bool channel_events_eq(struct channel_event *e1, struct channel_event *e2)
{
	CHECK(e1->db_id == e2->db_id);
	CHECK(streq(e1->acct_name, e2->acct_name));
	CHECK(streq(e1->tag, e2->tag));
	CHECK(amount_msat_eq(e1->credit, e2->credit));
	CHECK(amount_msat_eq(e1->debit, e2->debit));
	CHECK(amount_msat_eq(e1->fees, e2->fees));
	CHECK((e1->payment_id != NULL) == (e2->payment_id != NULL));
	if (e1->payment_id)
		CHECK(sha256_eq(e1->payment_id, e2->payment_id));
	CHECK(e1->part_id == e2->part_id);
	CHECK(e1->timestamp == e2->timestamp);

	return true;
}

static bool chain_events_eq(struct chain_event *e1, struct chain_event *e2)
{
	CHECK(e1->db_id == e2->db_id);
	CHECK(streq(e1->acct_name, e2->acct_name));
	CHECK((e1->origin_acct != NULL) == (e2->origin_acct != NULL));
	if (e1->origin_acct)
		CHECK(streq(e1->origin_acct, e2->origin_acct));
	CHECK(streq(e1->tag, e2->tag));
	CHECK(amount_msat_eq(e1->credit, e2->credit));
	CHECK(amount_msat_eq(e1->debit, e2->debit));
	CHECK(amount_msat_eq(e1->output_value, e2->output_value));
	CHECK(e1->timestamp == e2->timestamp);
	CHECK(e1->blockheight == e2->blockheight);
	CHECK(e1->stealable == e2->stealable);
	CHECK(bitcoin_outpoint_eq(&e1->outpoint, &e2->outpoint));

	CHECK((e1->spending_txid != NULL) == (e2->spending_txid != NULL));
	if (e1->spending_txid)
		CHECK(bitcoin_txid_eq(e1->spending_txid, e2->spending_txid));

	CHECK((e1->payment_id != NULL) == (e2->payment_id != NULL));
	if (e1->payment_id)
		CHECK(sha256_eq(e1->payment_id, e2->payment_id));

	CHECK(e1->splice_close == e2->splice_close);

	return true;
}

static struct channel_event *make_channel_event(const tal_t *ctx,
						char *tag,
						struct amount_msat credit,
						struct amount_msat debit,
						char payment_char)
{
	struct channel_event *ev = tal(ctx, struct channel_event);

	ev->payment_id = tal(ev, struct sha256);
	memset(ev->payment_id, payment_char, sizeof(struct sha256));
	ev->credit = credit;
	ev->debit = debit;
	ev->fees = AMOUNT_MSAT(104);
	ev->timestamp = 1919191;
	ev->part_id = 19;
	ev->tag = tag;
	return ev;
}

static struct chain_event *make_chain_event(const tal_t *ctx,
					    char *tag,
					    struct amount_msat credit,
					    struct amount_msat debit,
					    struct amount_msat output_val,
					    u32 blockheight,
					    char outpoint_char,
					    u32 outnum,
					    /* Note that '*' is magic */
					    char spend_char)


{
	struct chain_event *ev = tal(ctx, struct chain_event);

	/* This event spends the second inserted event */
	ev->tag = tal_fmt(ctx, "%s", tag);
	ev->origin_acct = NULL;
	ev->credit = credit;
	ev->debit = debit;
	ev->output_value = output_val;
	ev->timestamp = 1919191;
	ev->blockheight = blockheight;
	ev->stealable = false;
	ev->splice_close = false;
	memset(&ev->outpoint.txid, outpoint_char, sizeof(struct bitcoin_txid));
	ev->outpoint.n = outnum;

	if (spend_char != '*') {
		ev->spending_txid = tal(ctx, struct bitcoin_txid);
		memset(ev->spending_txid, spend_char,
		       sizeof(struct bitcoin_txid));
	} else
		ev->spending_txid = NULL;

	ev->payment_id = NULL;

	return ev;
}

static bool test_onchain_fee_wallet_spend(const tal_t *ctx)
{
	struct bkpr *bkpr = bkpr_setup(ctx);
	struct db *db = bkpr->db;
	struct node_id node_id, peer_id;
	struct account *wal_acct, *ext_acct;
	struct bitcoin_txid txid;
	struct onchain_fee **ofs;
	u32 blockheight = 100000;

	memset(&node_id, 2, sizeof(struct node_id));
	memset(&peer_id, 3, sizeof(struct node_id));

	wal_acct = new_account(bkpr->accounts, tal_fmt(ctx, ACCOUNT_NAME_WALLET));
	wal_acct->peer_id = &node_id;
	ext_acct = new_account(bkpr->accounts, tal_fmt(ctx, ACCOUNT_NAME_EXTERNAL));
	ext_acct->peer_id = &peer_id;
	memset(&txid, '1', sizeof(struct bitcoin_txid));

	db_begin_transaction(db);
	account_datastore_set(NULL, wal_acct, "must-create");
	account_datastore_set(NULL, ext_acct, "must-create");
	db_commit_transaction(db);


	/* Send funds to an external address
	 * tag     utxo_id vout    txid    debits  credits acct_id
	 * withdr  XXXX    0       1111    1000            wallet
	 * deposit 1111    1                        200    wallet
	 * deposit 1111    0                        700    external
	 */
	db_begin_transaction(db);
	log_chain_event(db, wal_acct,
		make_chain_event(ctx, "withdrawal",
				 AMOUNT_MSAT(0),
				 AMOUNT_MSAT(1000),
				 AMOUNT_MSAT(1000),
				 blockheight,
				 'X', 0, '1'));
	maybe_update_onchain_fees(ctx, NULL, bkpr, &txid);

	log_chain_event(db, wal_acct,
		make_chain_event(ctx, "deposit",
				 AMOUNT_MSAT(200),
				 AMOUNT_MSAT(0),
				 AMOUNT_MSAT(200),
				 blockheight,
				 '1', 1, '*'));
	maybe_update_onchain_fees(ctx, NULL, bkpr, &txid);

	log_chain_event(db, ext_acct,
		make_chain_event(ctx, "deposit",
				 AMOUNT_MSAT(700),
				 AMOUNT_MSAT(0),
				 AMOUNT_MSAT(700),
				 blockheight,
				 '1', 0, '*'));
	maybe_update_onchain_fees(ctx, NULL, bkpr, &txid);
	db_commit_transaction(db);

	ofs = list_chain_fees(ctx, bkpr);
	CHECK(tal_count(ofs) == 2);

	/* we expect 800, then -700 */
	CHECK(amount_msat_eq(ofs[0]->credit, AMOUNT_MSAT(800)));
	CHECK(amount_msat_is_zero(ofs[0]->debit));
	CHECK(ofs[0]->update_count == 1);

	CHECK(amount_msat_is_zero(ofs[1]->credit));
	CHECK(amount_msat_eq(ofs[1]->debit, AMOUNT_MSAT(700)));
	CHECK(ofs[1]->update_count == 2);

	return true;
}

static bool test_onchain_fee_chan_close(const tal_t *ctx)
{
	struct bkpr *bkpr = bkpr_setup(ctx);
	struct db *db = bkpr->db;
	struct node_id node_id, peer_id;
	struct account *acct, *wal_acct, *ext_acct;
	struct onchain_fee **ofs, **ofs1;
	struct bitcoin_txid txid;
	struct chain_event *ev;
	enum mvt_tag *tags;
	u32 close_output_count;
	u32 blockheight = 100000;
	char *err;

	memset(&node_id, 2, sizeof(struct node_id));
	memset(&peer_id, 3, sizeof(struct node_id));
	/* to_us, to_them, 1 htlc, 2 anchors */
	close_output_count = 5;

	wal_acct = new_account(bkpr->accounts, tal_fmt(ctx, ACCOUNT_NAME_WALLET));
	wal_acct->peer_id = &node_id;
	ext_acct = new_account(bkpr->accounts, tal_fmt(ctx, ACCOUNT_NAME_EXTERNAL));
	ext_acct->peer_id = &peer_id;
	acct = new_account(bkpr->accounts, tal_fmt(ctx, "chan-1"));
	acct->peer_id = &peer_id;

	db_begin_transaction(db);
	account_datastore_set(NULL, wal_acct, "must-create");
	account_datastore_set(NULL, ext_acct, "must-create");
	account_datastore_set(NULL, acct, "must-create");
	db_commit_transaction(db);

	/* Close a channel */
	/* tag     utxo_id vout    txid    debits  credits acct_id
	 * close   XXXX    0       1111    1000            wallet
	 * delay   1111    1                        200    chan-1
	 * anchor  1111    0                         30    chan-1
	 * anchor  1111    4                         30    external
	 * to_wall 1111    1       2222     200            chan-1
	 * htlc_tim1111    2                        600    chan-1
	 * htlc_tim1111    2       3333     600            chan-1
	 * to_them 1111    3                        300    external
	 * deposit 2222    0                        150    chan-1
	 * htlc_tx 3333    0                        450    chan-1
	 * to_wall 3333    0       4444     450            chan-1
	 * deposit 4444    0                        350    wallet
	 */
	tags = tal_arr(ctx, enum mvt_tag, 1);
	db_begin_transaction(db);
	ev = make_chain_event(ctx, "channel_open",
				    AMOUNT_MSAT(1000),
				    AMOUNT_MSAT(0),
				    AMOUNT_MSAT(1660),
				    blockheight,
				    'X', 0, '*');
	log_chain_event(db, acct, ev);
	tags[0] = MVT_CHANNEL_OPEN;
	maybe_update_account(NULL, acct, ev, tags, 0, NULL);

	ev = make_chain_event(ctx, "channel_close",
				    AMOUNT_MSAT(0),
				    AMOUNT_MSAT(1000),
				    AMOUNT_MSAT(1660),
				    blockheight,
				    'X', 0, '1');
	log_chain_event(db, acct, ev);

	/* Update the account to have the right info! */
	tags[0] = MVT_CHANNEL_CLOSE;
	maybe_update_account(NULL, acct, ev, tags, close_output_count, NULL);

	log_chain_event(db, acct,
		make_chain_event(ctx, "delayed_to_us",
				 AMOUNT_MSAT(200),
				 AMOUNT_MSAT(0),
				 AMOUNT_MSAT(200),
				 blockheight,
				 '1', 1, '*'));
	memset(&txid, '1', sizeof(struct bitcoin_txid));
	maybe_update_onchain_fees(ctx, NULL, bkpr, &txid);

	log_chain_event(db, wal_acct,
		make_chain_event(ctx, "anchor",
				 AMOUNT_MSAT(30),
				 AMOUNT_MSAT(0),
				 AMOUNT_MSAT(30),
				 blockheight,
				 '1', 0, '*'));
	log_chain_event(db, ext_acct,
		make_chain_event(ctx, "anchor",
				 AMOUNT_MSAT(30),
				 AMOUNT_MSAT(0),
				 AMOUNT_MSAT(30),
				 blockheight,
				 '1', 4, '*'));
	memset(&txid, '1', sizeof(struct bitcoin_txid));
	maybe_update_onchain_fees(ctx, NULL, bkpr, &txid);

	/* Should be no fees yet */
	ofs = list_chain_fees(ctx, bkpr);
	CHECK(tal_count(ofs) == 0);

	log_chain_event(db, acct,
		make_chain_event(ctx, "htlc_timeout",
				 AMOUNT_MSAT(600),
				 AMOUNT_MSAT(0),
				 AMOUNT_MSAT(600),
				 blockheight,
				 '1', 2, '*'));

	log_chain_event(db, ext_acct,
		make_chain_event(ctx, "to_them",
				 AMOUNT_MSAT(300),
				 AMOUNT_MSAT(0),
				 AMOUNT_MSAT(300),
				 blockheight,
				 '1', 3, '*'));

	memset(&txid, '1', sizeof(struct bitcoin_txid));
	maybe_update_onchain_fees(ctx, NULL, bkpr, &txid);
	db_commit_transaction(db);

	/* txid 2222 */
	db_begin_transaction(db);
	log_chain_event(db, acct,
		make_chain_event(ctx, "to_wallet",
				 AMOUNT_MSAT(0),
				 AMOUNT_MSAT(200),
				 AMOUNT_MSAT(200),
				 blockheight + 1,
				 '1', 1, '2'));

	log_chain_event(db, wal_acct,
		make_chain_event(ctx, "deposit",
				 AMOUNT_MSAT(150),
				 AMOUNT_MSAT(0),
				 AMOUNT_MSAT(150),
				 blockheight + 1,
				 '2', 0, '*'));
	memset(&txid, '2', sizeof(struct bitcoin_txid));
	maybe_update_onchain_fees(ctx, NULL, bkpr, &txid);
	CHECK(acct->onchain_resolved_block == 0);

	assert(account_onchain_closeheight(db, acct) == 0);
	CHECK(acct->onchain_resolved_block == 0);
	db_commit_transaction(db);

	/* Expect: 1 onchain fee records, all for chan-1 */
	ofs = list_chain_fees(ctx, bkpr);
	ofs1 = account_get_chain_fees(tmpctx, bkpr, acct->name);

	CHECK(tal_count(ofs) == tal_count(ofs1));
	CHECK(tal_count(ofs) == 1);

	/* txid 4444 */
	db_begin_transaction(db);
	log_chain_event(db, wal_acct,
		make_chain_event(ctx, "deposit",
				 AMOUNT_MSAT(350),
				 AMOUNT_MSAT(0),
				 AMOUNT_MSAT(350),
				 blockheight + 2,
				 '4', 0, '*'));

	memset(&txid, '4', sizeof(struct bitcoin_txid));
	maybe_update_onchain_fees(ctx, NULL, bkpr, &txid);

	/* txid 3333 */
	log_chain_event(db, acct,
		make_chain_event(ctx, "htlc_timeout",
				 AMOUNT_MSAT(0),
				 AMOUNT_MSAT(600),
				 AMOUNT_MSAT(600),
				 blockheight + 2,
				 '1', 2, '3'));

	assert(account_onchain_closeheight(db, acct) == 0);
	CHECK(acct->onchain_resolved_block == 0);

	log_chain_event(db, acct,
		make_chain_event(ctx, "htlc_tx",
				 AMOUNT_MSAT(450),
				 AMOUNT_MSAT(0),
				 AMOUNT_MSAT(450),
				 blockheight + 2,
				 '3', 0, '*'));

	memset(&txid, '3', sizeof(struct bitcoin_txid));
	maybe_update_onchain_fees(ctx, NULL, bkpr, &txid);

	log_chain_event(db, acct,
		make_chain_event(ctx, "to_wallet",
				 AMOUNT_MSAT(0),
				 AMOUNT_MSAT(450),
				 AMOUNT_MSAT(450),
				 blockheight + 2,
				 '3', 0, '4'));

	memset(&txid, '4', sizeof(struct bitcoin_txid));
	maybe_update_onchain_fees(ctx, NULL, bkpr, &txid);

	db_commit_transaction(db);

	/* Expect: onchain fee records for tx except channel close */
	ofs = list_chain_fees(ctx, bkpr);
	ofs1 = account_get_chain_fees(tmpctx, bkpr, acct->name);

	CHECK(tal_count(ofs) == tal_count(ofs1));
	CHECK(tal_count(ofs) == 3);

	/* Now we update the channel's onchain fees */
	CHECK(acct->onchain_resolved_block == 0);
	db_begin_transaction(db);
	account_update_closeheight(NULL, acct, account_onchain_closeheight(db, acct));
	CHECK(acct->onchain_resolved_block == blockheight + 2);
	err = update_channel_onchain_fees(ctx, NULL, bkpr, acct);
	CHECK_MSG(!err, err);
	db_commit_transaction(db);
	ofs = account_get_chain_fees(tmpctx, bkpr, acct->name);

	/* Expect: fees as follows
	 *
	 * chan-1, 1111, 200 (anchor outs ignored)
	 * chan-1, 2222,  50
	 * chan-1, 3333, 150
	 * chan-1, 4444, 100
	 */
	CHECK(tal_count(ofs) == 4);
	for (size_t i = 0; i < tal_count(ofs); i++) {
		CHECK(streq(ofs[i]->acct_name, acct->name));

		memset(&txid, '1', sizeof(struct bitcoin_txid));
		if (bitcoin_txid_eq(&txid, &ofs[i]->txid)) {
			CHECK(ofs[i]->update_count == 1);
			CHECK(amount_msat_eq(ofs[i]->credit, AMOUNT_MSAT(200)));
			CHECK(amount_msat_is_zero(ofs[i]->debit));
			continue;
		}
		memset(&txid, '2', sizeof(struct bitcoin_txid));
		if (bitcoin_txid_eq(&txid, &ofs[i]->txid)) {
			CHECK(ofs[i]->update_count == 1);
			CHECK(amount_msat_eq(ofs[i]->credit, AMOUNT_MSAT(50)));
			CHECK(amount_msat_is_zero(ofs[i]->debit));
			continue;
		}
		memset(&txid, '3', sizeof(struct bitcoin_txid));
		if (bitcoin_txid_eq(&txid, &ofs[i]->txid)) {
			CHECK(ofs[i]->update_count == 1);
			CHECK(amount_msat_eq(ofs[i]->credit, AMOUNT_MSAT(150)));
			CHECK(amount_msat_is_zero(ofs[i]->debit));
			continue;
		}
		memset(&txid, '4', sizeof(struct bitcoin_txid));
		if (bitcoin_txid_eq(&txid, &ofs[i]->txid)) {
			CHECK(ofs[i]->update_count == 1);
			CHECK(amount_msat_eq(ofs[i]->credit, AMOUNT_MSAT(100)));
			CHECK(amount_msat_is_zero(ofs[i]->debit));
			continue;
		}

		CHECK_MSG(false, "txid didn't match");
	}

	return true;
}

static bool test_onchain_fee_chan_open(const tal_t *ctx)
{
	struct bkpr *bkpr = bkpr_setup(ctx);
	struct db *db = bkpr->db;
	struct node_id node_id, peer_id;
	struct account *acct, *acct2, *wal_acct, *ext_acct;
	struct bitcoin_txid txid;
	struct onchain_fee **ofs;
	u32 blockheight = 100000;

	memset(&node_id, 2, sizeof(struct node_id));
	memset(&peer_id, 3, sizeof(struct node_id));

	wal_acct = new_account(bkpr->accounts, tal_fmt(ctx, ACCOUNT_NAME_WALLET));
	wal_acct->peer_id = &peer_id;
	ext_acct = new_account(bkpr->accounts, tal_fmt(ctx, ACCOUNT_NAME_EXTERNAL));
	ext_acct->peer_id = &peer_id;
	acct = new_account(bkpr->accounts, tal_fmt(ctx, "chan-1"));
	acct->peer_id = &peer_id;
	acct2 = new_account(bkpr->accounts, tal_fmt(ctx, "chan-2"));
	acct2->peer_id = &peer_id;

	db_begin_transaction(db);
	account_datastore_set(NULL, wal_acct, "must-create");
	account_datastore_set(NULL, ext_acct, "must-create");
	account_datastore_set(NULL, acct, "must-create");
	account_datastore_set(NULL, acct2, "must-create");
	db_commit_transaction(db);

	/* Assumption that we rely on later */
	CHECK(strcmp(acct->name, acct2->name) < 0);

	/* Open two channels from wallet */
	/* tag     utxo_id vout    txid    debits  credits acct_id
	 * withd   XXXX    0       AAAA    1000            wallet
	 * withd   YYYY    0       AAAA    3001            wallet
	 * open    AAAA    0                        500    chan-1
	 * open    AAAA    1                       1000    chan-2
	 * depo    AAAA    2                       2200    wallet
	 */
	memset(&txid, 'A', sizeof(struct bitcoin_txid));
	db_begin_transaction(db);
	log_chain_event(db, wal_acct,
		make_chain_event(ctx, "withdrawal",
				 AMOUNT_MSAT(0),
				 AMOUNT_MSAT(1000),
				 AMOUNT_MSAT(1000),
				 blockheight,
				 'X', 0, 'A'));
	log_chain_event(db, wal_acct,
		make_chain_event(ctx, "withdrawal",
				 AMOUNT_MSAT(0),
				 AMOUNT_MSAT(3001),
				 AMOUNT_MSAT(3001),
				 blockheight,
				 'Y', 0, 'A'));

	log_chain_event(db, acct,
		make_chain_event(ctx, "deposit",
				 AMOUNT_MSAT(500),
				 AMOUNT_MSAT(0),
				 AMOUNT_MSAT(500),
				 blockheight,
				 'A', 0, '*'));
	maybe_update_onchain_fees(ctx, NULL, bkpr, &txid);

	log_chain_event(db, acct2,
		make_chain_event(ctx, "deposit",
				 AMOUNT_MSAT(1000),
				 AMOUNT_MSAT(0),
				 AMOUNT_MSAT(1000),
				 blockheight,
				 'A', 1, '*'));
	maybe_update_onchain_fees(ctx, NULL, bkpr, &txid);

	log_chain_event(db, wal_acct,
		make_chain_event(ctx, "deposit",
				 AMOUNT_MSAT(2200),
				 AMOUNT_MSAT(0),
				 AMOUNT_MSAT(2200),
				 blockheight,
				 'A', 2, '*'));
	maybe_update_onchain_fees(ctx, NULL, bkpr, &txid);

	maybe_update_onchain_fees(ctx, NULL, bkpr, &txid);
	db_commit_transaction(db);

	/* Expect: 5 onchain fee records, totaling to 151/150msat ea,
	 * none for wallet */
	ofs = list_chain_fees(ctx, bkpr);

	CHECK(tal_count(ofs) == 5);

	struct exp_result {
		u32 credit;
		u32 debit;
		u32 update_count;
	};

	struct exp_result exp_results[] = {
		{ .credit = 3501, .debit = 0, .update_count = 1 },
		{ .credit = 0, .debit = 2250, .update_count = 2 },
		{ .credit = 0, .debit = 1100, .update_count = 3 },
		{ .credit = 1250, .debit = 0, .update_count = 1 },
		{ .credit = 0, .debit = 1100, .update_count = 2 },
	};

	/* Since these are sorted on fetch,
	 * this *should* be stable */
	for (size_t i = 0; i < tal_count(ofs); i++) {
		CHECK(i < ARRAY_SIZE(exp_results));
		CHECK(amount_msat_eq(ofs[i]->credit,
				     amount_msat(exp_results[i].credit)));
		CHECK(amount_msat_eq(ofs[i]->debit,
				     amount_msat(exp_results[i].debit)));
		CHECK(ofs[i]->update_count == exp_results[i].update_count);

		CHECK(bitcoin_txid_eq(&ofs[i]->txid, &txid));
	}

	return true;
}

static bool test_channel_rebalances(const tal_t *ctx)
{
	struct bkpr *bkpr = bkpr_setup(ctx);
	struct db *db = bkpr->db;
	struct channel_event *ev1, *ev2, *ev3, **chan_evs;
	struct rebalance_pair *rebals;
	struct rebalance_htable_iter it;
	struct account *acct1, *acct2, *acct3;
	struct node_id peer_id;

	memset(&peer_id, 3, sizeof(struct node_id));
	acct1 = new_account(bkpr->accounts, tal_fmt(ctx, "one"));
	acct1->peer_id = &peer_id;
	acct2 = new_account(bkpr->accounts, tal_fmt(ctx, "two"));
	acct2->peer_id = &peer_id;
	acct3 = new_account(bkpr->accounts, tal_fmt(ctx, "three"));
	acct3->peer_id = &peer_id;

	db_begin_transaction(db);

	account_datastore_set(NULL, acct1, "must-create");
	account_datastore_set(NULL, acct2, "must-create");
	account_datastore_set(NULL, acct3, "must-create");

	/* Simulate a rebalance of 100msats, w/ a 12msat fee */
	ev1 = make_channel_event(ctx, "invoice",
		           AMOUNT_MSAT(100),
			   AMOUNT_MSAT(0),
			   'A');
	ev1->fees = AMOUNT_MSAT(0);
	log_channel_event(db, acct1, ev1);

	ev2 = make_channel_event(ctx, "invoice",
				 AMOUNT_MSAT(0),
				 AMOUNT_MSAT(112),
				 'A');
	ev2->fees = AMOUNT_MSAT(12);
	log_channel_event(db, acct2, ev2);

	/* Third event w/ same preimage but diff amounts */
	ev3 = make_channel_event(ctx, "invoice",
				 AMOUNT_MSAT(105),
				 AMOUNT_MSAT(0),
				 'A');
	log_channel_event(db, acct3, ev3);
	db_commit_transaction(db);

	db_begin_transaction(db);
	chan_evs = account_get_channel_events(ctx, db, acct1);
	CHECK(tal_count(chan_evs) == 1 && !find_rebalance(bkpr, chan_evs[0]->db_id));

	chan_evs = account_get_channel_events(ctx, db, acct2);
	CHECK(tal_count(chan_evs) == 1 && !find_rebalance(bkpr, chan_evs[0]->db_id));

	chan_evs = account_get_channel_events(ctx, db, acct3);
	CHECK(tal_count(chan_evs) == 1 && !find_rebalance(bkpr, chan_evs[0]->db_id));

	maybe_record_rebalance(NULL, bkpr, ev2);
	CHECK(find_rebalance(bkpr, ev2->db_id) != NULL);

	/* Both events should be marked as rebalance */
	chan_evs = account_get_channel_events(ctx, db, acct1);
	CHECK(tal_count(chan_evs) == 1 && find_rebalance(bkpr, chan_evs[0]->db_id));
	ev1 = chan_evs[0];
	chan_evs = account_get_channel_events(ctx, db, acct2);
	CHECK(tal_count(chan_evs) == 1 && find_rebalance(bkpr, chan_evs[0]->db_id));
	CHECK(*find_rebalance(bkpr, chan_evs[0]->db_id) == ev1->db_id);
	CHECK(*find_rebalance(bkpr, ev1->db_id) == chan_evs[0]->db_id);

	/* Third event is not a rebalance though */
	chan_evs = account_get_channel_events(ctx, db, acct3);
	CHECK(tal_count(chan_evs) == 1 && !find_rebalance(bkpr, chan_evs[0]->db_id));

	/* Did we get an accurate rebalances entry? */
	assert(rebalance_htable_count(bkpr->rebalances->pairs) == 2);
	rebals = rebalance_htable_first(bkpr->rebalances->pairs, &it);

	if (rebals->pair[0] == ev1->db_id) {
		CHECK(rebals->pair[1] == ev2->db_id);
	} else {
		CHECK(rebals->pair[1] == ev1->db_id);
		CHECK(rebals->pair[0] == ev2->db_id);
	}
	db_commit_transaction(db);

	return true;
}

static bool test_channel_event_crud(const tal_t *ctx)
{
	struct bkpr *bkpr = bkpr_setup(ctx);
	struct db *db = bkpr->db;
	struct node_id peer_id;
	struct account *acct, *acct2;
	struct channel_event *ev1, *ev2, *ev3, **chan_evs;

	memset(&peer_id, 3, sizeof(struct node_id));

	acct = new_account(bkpr->accounts, tal_fmt(ctx, "example"));
	acct->peer_id = &peer_id;
	acct2 = new_account(bkpr->accounts, tal_fmt(ctx, ACCOUNT_NAME_WALLET));
	acct2->peer_id = &peer_id;
	db_begin_transaction(db);
	account_datastore_set(NULL, acct, "must-create");
	account_datastore_set(NULL, acct2, "must-create");
	db_commit_transaction(db);

	ev1 = tal(ctx, struct channel_event);
	ev1->payment_id = tal(ev1, struct sha256);
	memset(ev1->payment_id, 'B', sizeof(struct sha256));
	ev1->credit = AMOUNT_MSAT(100);
	ev1->debit = AMOUNT_MSAT(102);
	ev1->fees = AMOUNT_MSAT(104);
	ev1->timestamp = 11111;
	ev1->part_id = 19;

	/* Passing unknown tags in should be ok */
	ev1->tag = "hello";

	ev2 = tal(ctx, struct channel_event);
	ev2->payment_id = tal(ev2, struct sha256);
	memset(ev2->payment_id, 'C', sizeof(struct sha256));
	ev2->credit = AMOUNT_MSAT(200);
	ev2->debit = AMOUNT_MSAT(202);
	ev2->fees = AMOUNT_MSAT(204);
	ev2->timestamp = 22222;
	ev2->part_id = 0;
	ev2->tag = tal_fmt(ev2, "deposit");

	ev3 = tal(ctx, struct channel_event);
	ev3->payment_id = tal(ev3, struct sha256);
	memset(ev3->payment_id, 'D', sizeof(struct sha256));
	ev3->credit = AMOUNT_MSAT(300);
	ev3->debit = AMOUNT_MSAT(302);
	ev3->fees = AMOUNT_MSAT(304);
	ev3->timestamp = 33333;
	ev3->part_id = 5;
	ev3->tag = tal_fmt(ev3, "routed");

	db_begin_transaction(db);
	log_channel_event(db, acct, ev1);
	log_channel_event(db, acct, ev2);

	/* log a channel event to a different acct */
	log_channel_event(db, acct2, ev3);

	/* log a channel event without a payment id */
	ev3->payment_id = NULL;
	log_channel_event(db, acct2, ev3);

	db_commit_transaction(db);

	db_begin_transaction(db);
	chan_evs = account_get_channel_events(ctx, db, acct);
	db_commit_transaction(db);

	CHECK(streq(acct->name, chan_evs[0]->acct_name));
	CHECK(streq(acct->name, chan_evs[1]->acct_name));

	CHECK(tal_count(chan_evs) == 2);
	channel_events_eq(ev1, chan_evs[0]);
	channel_events_eq(ev2, chan_evs[1]);

	return true;
}

static bool test_chain_event_crud(const tal_t *ctx)
{
	struct bkpr *bkpr = bkpr_setup(ctx);
	struct db *db = bkpr->db;
	struct node_id peer_id;
	struct account *acct, *acct2;
	struct chain_event *ev1, *ev2, *ev3, **chain_evs;
	char *name = tal_fmt(ctx, "example");

	ev2 = tal(ctx, struct chain_event);
	memset(&peer_id, 3, sizeof(struct node_id));

	acct = new_account(bkpr->accounts, name);
	acct->peer_id = &peer_id;
	acct2 = new_account(bkpr->accounts, tal_fmt(ctx, ACCOUNT_NAME_WALLET));
	acct2->peer_id = &peer_id;
	db_begin_transaction(db);
	account_datastore_set(NULL, acct, "must-create");
	account_datastore_set(NULL, acct2, "must-create");
	db_commit_transaction(db);

	/* This event spends the second inserted event */
	ev1 = tal(ctx, struct chain_event);
	ev1->tag = tal_fmt(ev1, "withdrawal");
	ev1->origin_acct = NULL;
	ev1->credit = AMOUNT_MSAT(100);
	ev1->debit = AMOUNT_MSAT(102);
	ev1->output_value = AMOUNT_MSAT(104);
	ev1->timestamp = 1919191;
	ev1->blockheight = 1919191;
	ev1->stealable  = false;
	ev1->splice_close = false;
	memset(&ev1->outpoint.txid, 'D', sizeof(struct bitcoin_txid));
	ev1->outpoint.n = 1;
	ev1->spending_txid = tal(ctx, struct bitcoin_txid);
	memset(ev1->spending_txid, 'C', sizeof(struct bitcoin_txid));
	ev1->payment_id = NULL;

	db_begin_transaction(db);
	log_chain_event(db, acct, ev1);
	db_commit_transaction(db);

	ev2->tag = tal_fmt(ctx, "deposit");
	ev2->origin_acct = tal_fmt(ctx, ACCOUNT_NAME_WALLET);
	ev2->credit = AMOUNT_MSAT(200);
	ev2->debit = AMOUNT_MSAT(202);
	ev2->output_value = AMOUNT_MSAT(104);
	ev2->timestamp = 1919191;
	ev2->blockheight = 1919191;
	ev2->stealable = false;
	ev2->splice_close = false;
	memset(&ev2->outpoint.txid, 'D', sizeof(struct bitcoin_txid));
	ev2->outpoint.n = 1;
	ev2->spending_txid = NULL;
	ev2->payment_id = tal(ctx, struct sha256);
	memset(ev2->payment_id, 'B', sizeof(struct sha256));

	/* Dummy event, logged to separate account */
	ev3 = tal(ctx, struct chain_event);
	ev3->tag = tal_fmt(ev3, "deposit");
	ev3->origin_acct = NULL;
	ev3->credit = AMOUNT_MSAT(300);
	ev3->debit = AMOUNT_MSAT(302);
	ev3->output_value = AMOUNT_MSAT(304);
	ev3->timestamp = 3939393;
	ev3->blockheight = 3939393;
	ev3->stealable = false;
	ev3->splice_close = false;
	memset(&ev3->outpoint.txid, 'E', sizeof(struct bitcoin_txid));
	ev3->outpoint.n = 1;
	ev3->spending_txid = tal(ctx, struct bitcoin_txid);
	memset(ev3->spending_txid, 'D', sizeof(struct bitcoin_txid));
	ev3->payment_id = NULL;

	db_begin_transaction(db);
	log_chain_event(db, acct, ev2);

	/* log new event to a different account.. */
	log_chain_event(db, acct2, ev3);
	db_commit_transaction(db);

	/* Try to add an already exiting event */
	db_begin_transaction(db);
	log_chain_event(db, acct, ev2);
	db_commit_transaction(db);

	/* Ok now we ge the list, there should only be two */
	db_begin_transaction(db);
	chain_evs = account_get_chain_events(ctx, db, acct);
	db_commit_transaction(db);
	CHECK(tal_count(chain_evs) == 2);

	CHECK(streq(acct->name, chain_evs[0]->acct_name));
	CHECK(streq(acct->name, chain_evs[1]->acct_name));
	chain_events_eq(ev1, chain_evs[0]);
	chain_events_eq(ev2, chain_evs[1]);

	/* Now insert a utxo create and spend, in that order */
	ev1->db_id = 0;
	memset(&ev1->outpoint.txid, 'A', sizeof(struct bitcoin_txid));
	ev1->outpoint.n = 10;
	ev1->spending_txid = tal_free(ev1->spending_txid);

	ev2->db_id = 0;
	memset(&ev2->outpoint.txid, 'A', sizeof(struct bitcoin_txid));
	ev2->outpoint.n = 10;
	ev2->spending_txid = tal(ctx, struct bitcoin_txid);
	memset(ev2->spending_txid, 'B', sizeof(struct bitcoin_txid));


	db_begin_transaction(db);
	log_chain_event(db, acct, ev1);
	log_chain_event(db, acct, ev2);
	chain_evs = account_get_chain_events(ctx, db, acct);
	db_commit_transaction(db);

	/* There should be four now */
	CHECK(tal_count(chain_evs) == 4);

	chain_events_eq(ev1, chain_evs[2]);
	chain_events_eq(ev2, chain_evs[3]);

	return true;
}

struct acct_balance {
	struct amount_msat credit;
	struct amount_msat debit;
	struct amount_msat balance;
};

static bool account_get_balance(struct plugin *plugin,
				struct db *db,
				const char *acct_name,
				struct acct_balance *bal)
{
	account_get_credit_debit(plugin, db, acct_name,
				 &bal->credit, &bal->debit);

	return amount_msat_sub(&bal->balance, bal->credit, bal->debit);
}

static bool test_account_balances(const tal_t *ctx)
{
	struct bkpr *bkpr = bkpr_setup(ctx);
	struct db *db = bkpr->db;
	struct node_id peer_id;
	struct account *acct, *acct2;
	struct chain_event *ev1;
	struct acct_balance balance;
	bool ok;

	memset(&peer_id, 3, sizeof(struct node_id));

	acct = new_account(bkpr->accounts, tal_fmt(ctx, "example"));
	acct->peer_id = &peer_id;
	acct2 = new_account(bkpr->accounts, tal_fmt(ctx, ACCOUNT_NAME_WALLET));
	acct2->peer_id = &peer_id;

	db_begin_transaction(db);
	/* Check that account does not exist yet */
	ok = account_get_balance(NULL, db, acct->name, &balance);
	CHECK(ok);

	account_datastore_set(NULL, acct, "must-create");
	account_datastore_set(NULL, acct2, "must-create");

	/* +1000btc */
	log_chain_event(db, acct,
			make_chain_event(ctx, "one",
					 AMOUNT_MSAT(1000),
					 AMOUNT_MSAT(0),
					 AMOUNT_MSAT(1000),
					 1019,
					 'A', 1, '*'));
	ev1 = make_chain_event(ctx, "two",
			       AMOUNT_MSAT(0), AMOUNT_MSAT(999),
			       AMOUNT_MSAT(999),
			       1020, 'A', 2, '*');

	/* -999btc */
	log_chain_event(db, acct, ev1);

	/* -440btc */
	log_channel_event(db, acct,
			  make_channel_event(ctx, "chan",
					     AMOUNT_MSAT(0),
					     AMOUNT_MSAT(440),
					     'C'));

	/* 500btc */
	log_channel_event(db, acct,
			  make_channel_event(ctx, "chan",
					     AMOUNT_MSAT(500),
					     AMOUNT_MSAT(0),
					     'D'));

	ok = account_get_balance(NULL, db, acct->name, &balance);
	CHECK(ok);
	db_commit_transaction(db);

	CHECK(amount_msat_eq(balance.balance, AMOUNT_MSAT(500 - 440 + 1)));

	/* Should error if account balance is negative */
	db_begin_transaction(db);
	/* -5001btc */
	ev1 = make_chain_event(ctx, "two",
			       AMOUNT_MSAT(0), AMOUNT_MSAT(5001),
			       AMOUNT_MSAT(5001), 2020,
			       'A', 4, '*');
	log_chain_event(db, acct, ev1);

	ok = account_get_balance(NULL, db, acct->name, &balance);
	CHECK(!ok);
	db_commit_transaction(db);

	return true;
}

static bool test_account_crud(const tal_t *ctx)
{
	struct bkpr *bkpr = bkpr_setup(ctx);
	struct db *db = bkpr->db;
	struct node_id *peer_id;
	struct account *acct, *acct2, **acct_list;
	struct chain_event *ev1;
	enum mvt_tag *tags;
	char *name = tal_fmt(ctx, "example");

	peer_id = tal(ctx, struct node_id);
	memset(peer_id, 3, sizeof(struct node_id));

	acct = new_account(bkpr->accounts, name);
	CHECK(!acct->is_wallet);

	db_begin_transaction(db);
	account_datastore_set(NULL, acct, "must-create");
	db_commit_transaction(db);

	acct_list = list_accounts(ctx, bkpr);
	CHECK(tal_count(acct_list) == 1);
	accountseq(acct_list[0], acct);

	acct = new_account(bkpr->accounts, tal_fmt(ctx, ACCOUNT_NAME_WALLET));
	CHECK(acct->is_wallet);

	db_begin_transaction(db);
	account_datastore_set(NULL, acct, "must-create");
	db_commit_transaction(db);

	acct_list = list_accounts(ctx, bkpr);
	CHECK(tal_count(acct_list) == 2);

	/* Can we find an account ok? */
	acct2 = find_account(bkpr, ACCOUNT_NAME_WALLET);
	accountseq(acct, acct2);

	/* Will we update an account's properties
	 * correctly, given an event and tag list? */
	ev1 = tal(ctx, struct chain_event);
	ev1->tag = tal_fmt(ctx, "withdrawal");
	ev1->origin_acct = NULL;
	ev1->credit = AMOUNT_MSAT(100);
	ev1->debit = AMOUNT_MSAT(102);
	ev1->output_value = AMOUNT_MSAT(104);
	ev1->timestamp = 1919191;
	ev1->blockheight = 1919191;
	ev1->stealable = false;
	ev1->splice_close = false;
	memset(&ev1->outpoint.txid, 'D', sizeof(struct bitcoin_txid));
	ev1->outpoint.n = 1;
	ev1->spending_txid = tal(ctx, struct bitcoin_txid);
	memset(ev1->spending_txid, 'C', sizeof(struct bitcoin_txid));
	ev1->payment_id = NULL;

	db_begin_transaction(db);
	log_chain_event(db, acct, ev1);

	tags = tal_arr(ctx, enum mvt_tag, 2);

	/* should not update the account info */
	tags[0] = MVT_PUSHED;
	tags[1] = MVT_PENALTY;
	maybe_update_account(NULL, acct, ev1, tags, 0, peer_id);
	acct2 = find_account(bkpr, ACCOUNT_NAME_WALLET);
	accountseq(acct, acct2);

	/* channel_open -> open event db updated */
	CHECK(!acct->leased);
	CHECK(acct->open_event_db_id == NULL);
	tags[0] = MVT_CHANNEL_OPEN;
	tags[1] = MVT_LEASED;
	maybe_update_account(NULL, acct, ev1, tags, 2, peer_id);
	acct2 = find_account(bkpr, ACCOUNT_NAME_WALLET);
	accountseq(acct, acct2);
	CHECK(acct->leased);
	CHECK(acct->open_event_db_id != NULL);
	CHECK(acct->closed_count == 2);

	tags[0] = MVT_CHANNEL_CLOSE;
	tags[1] = MVT_OPENER;
	CHECK(acct->closed_event_db_id == NULL);
	CHECK(!acct->we_opened);
	maybe_update_account(NULL, acct, ev1, tags, 0, NULL);
	acct2 = find_account(bkpr, ACCOUNT_NAME_WALLET);
	accountseq(acct, acct2);
	CHECK(acct->closed_event_db_id != NULL);
	CHECK(acct->we_opened);

	db_commit_transaction(db);

	return true;
}

int main(int argc, char *argv[])
{
	bool ok = true;

	common_setup(argv[0]);

	if (HAVE_SQLITE3) {
		ok &= test_account_crud(tmpctx);
		ok &= test_channel_event_crud(tmpctx);
		ok &= test_chain_event_crud(tmpctx);
		ok &= test_account_balances(tmpctx);
		ok &= test_onchain_fee_chan_close(tmpctx);
		ok &= test_onchain_fee_chan_open(tmpctx);
		ok &= test_channel_rebalances(tmpctx);
		ok &= test_onchain_fee_wallet_spend(tmpctx);
	}

	common_shutdown();
	trace_cleanup();
	return !ok;
}
