#include "config.h"

#include "plugins/bkpr/sql.c"
#include "plugins/libplugin.c"

#include <common/json_filter.h>
#include <common/json_stream.h>
#include <common/fee_states.h>
#include <common/setup.h>
#include <common/utils.h>
#include <stdio.h>
#include <wire/wire.h>

/* AUTOGENERATED MOCKS START */
/* Generated stub for daemon_developer_mode */
bool daemon_developer_mode(char *argv[])
{ fprintf(stderr, "daemon_developer_mode called!\n"); abort(); }
/* Generated stub for daemon_setup */
void daemon_setup(const char *argv0 UNNEEDED,
		  void (*backtrace_print)(const char *fmt UNNEEDED, ...) UNNEEDED,
		  void (*backtrace_exit)(void))
{ fprintf(stderr, "daemon_setup called!\n"); abort(); }
/* Generated stub for deprecated_ok_ */
bool  deprecated_ok_(bool deprecated_apis UNNEEDED,
		    const char *feature UNNEEDED,
		    const char *start UNNEEDED,
		    const char *end UNNEEDED,
		    const char **begs UNNEEDED,
		    void (*complain)(const char *feat UNNEEDED, bool allowing UNNEEDED, void *) UNNEEDED,
		    void *cbarg UNNEEDED)
{ fprintf(stderr, "deprecated_ok_ called!\n"); abort(); }
/* Generated stub for find_blockheight */
u32 find_blockheight(const struct bkpr *bkpr UNNEEDED, const struct bitcoin_txid *txid UNNEEDED)
{ fprintf(stderr, "find_blockheight called!\n"); abort(); }
/* Generated stub for first_fee_state */
enum htlc_state first_fee_state(enum side opener UNNEEDED)
{ fprintf(stderr, "first_fee_state called!\n"); abort(); }
/* Generated stub for fmt_channel_id */
char *fmt_channel_id(const tal_t *ctx UNNEEDED, const struct channel_id *channel_id UNNEEDED)
{ fprintf(stderr, "fmt_channel_id called!\n"); abort(); }
/* Generated stub for fmt_wireaddr_without_port */
char *fmt_wireaddr_without_port(const tal_t *ctx UNNEEDED, const struct wireaddr *a UNNEEDED)
{ fprintf(stderr, "fmt_wireaddr_without_port called!\n"); abort(); }
/* Generated stub for fromwire_wireaddr */
bool fromwire_wireaddr(const u8 **cursor UNNEEDED, size_t *max UNNEEDED, struct wireaddr *addr UNNEEDED)
{ fprintf(stderr, "fromwire_wireaddr called!\n"); abort(); }
/* Generated stub for htlc_state_flags */
int htlc_state_flags(enum htlc_state state UNNEEDED)
{ fprintf(stderr, "htlc_state_flags called!\n"); abort(); }
/* Generated stub for htlc_state_name */
const char *htlc_state_name(enum htlc_state s UNNEEDED)
{ fprintf(stderr, "htlc_state_name called!\n"); abort(); }
/* Generated stub for is_asterix_notification */
bool is_asterix_notification(const char *notification_name UNNEEDED,
			     const char *subscriptions UNNEEDED)
{ fprintf(stderr, "is_asterix_notification called!\n"); abort(); }
/* Generated stub for json_filter_down */
bool json_filter_down(struct json_filter **filter UNNEEDED, const char *member UNNEEDED)
{ fprintf(stderr, "json_filter_down called!\n"); abort(); }
/* Generated stub for json_filter_finished */
bool json_filter_finished(const struct json_filter *filter UNNEEDED)
{ fprintf(stderr, "json_filter_finished called!\n"); abort(); }
/* Generated stub for json_filter_misused */
const char *json_filter_misused(const tal_t *ctx UNNEEDED, const struct json_filter *f UNNEEDED)
{ fprintf(stderr, "json_filter_misused called!\n"); abort(); }
/* Generated stub for json_filter_ok */
bool json_filter_ok(const struct json_filter *filter UNNEEDED, const char *member UNNEEDED)
{ fprintf(stderr, "json_filter_ok called!\n"); abort(); }
/* Generated stub for json_filter_up */
bool json_filter_up(struct json_filter **filter UNNEEDED)
{ fprintf(stderr, "json_filter_up called!\n"); abort(); }
/* Generated stub for last_fee_state */
enum htlc_state last_fee_state(enum side opener UNNEEDED)
{ fprintf(stderr, "last_fee_state called!\n"); abort(); }
/* Generated stub for log_level_name */
const char *log_level_name(enum log_level level UNNEEDED)
{ fprintf(stderr, "log_level_name called!\n"); abort(); }
/* Generated stub for new_channel_event */
struct channel_event *new_channel_event(const tal_t *ctx UNNEEDED,
					const char *tag UNNEEDED,
					struct amount_msat credit UNNEEDED,
					struct amount_msat debit UNNEEDED,
					struct amount_msat fees UNNEEDED,
					const struct sha256 *payment_id TAKES UNNEEDED,
					u32 part_id UNNEEDED,
					u64 timestamp UNNEEDED)
{ fprintf(stderr, "new_channel_event called!\n"); abort(); }
/* Generated stub for param_check */
bool param_check(struct command *cmd UNNEEDED,
		 const char *buffer UNNEEDED,
		 const jsmntok_t tokens[] UNNEEDED, ...)
{ fprintf(stderr, "param_check called!\n"); abort(); }
/* Generated stub for parse_filter */
struct command_result *parse_filter(struct command *cmd UNNEEDED,
				    const char *name UNNEEDED,
				    const char *buffer UNNEEDED,
				    const jsmntok_t *tok UNNEEDED)
{ fprintf(stderr, "parse_filter called!\n"); abort(); }
/* AUTOGENERATED MOCKS END */

int main(int argc, char *argv[])
{
	common_setup(argv[0]);
	/* No quote: should return same pointer */
	const char *s1 = "simple";
	const char *r1 = sql_string(tmpctx, s1);
	assert(r1 == s1);

	/* One quote: should return new string with doubled quote */
	const char *s2 = "O'Reilly";
	const char *r2 = sql_string(tmpctx, s2);
	assert(strcmp(r2, "O''Reilly") == 0);
	assert(r2 != s2); // New allocation

	/* Multiple quotes */
	const char *s3 = "'a'b'c'";
	const char *r3 = sql_string(tmpctx, s3);
	assert(strcmp(r3, "''a''b''c''") == 0);

	/* All quotes */
	const char *s4 = "''''";
	const char *r4 = sql_string(tmpctx, s4);
	assert(strcmp(r4, "''''''''") == 0);

	/* Empty string: should return same pointer */
	const char *s5 = "";
	const char *r5 = sql_string(tmpctx, s5);
	assert(r5 == s5);
	common_shutdown();
}
