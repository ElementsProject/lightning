#include "config.h"

#include <ccan/tal/str/str.h>
#include <db/common.h>

#include "common/json_filter.c"
#include "plugins/bkpr/db.c"
#include "plugins/libplugin.c"

#include "test_utils.h"

#include <common/fee_states.h>
#include <common/htlc.h>
#include <common/json_stream.h>
#include <common/setup.h>
#include <common/utils.h>
#include <plugins/bkpr/account_entry.h>
#include <plugins/bkpr/channel_event.h>
#include <stdio.h>
#include <unistd.h>
#include <wire/wire.h>

/* AUTOGENERATED MOCKS START */
/* Generated stub for command_fail_badparam */
struct command_result *command_fail_badparam(struct command *cmd UNNEEDED,
					     const char *paramname UNNEEDED,
					     const char *buffer UNNEEDED,
					     const jsmntok_t *tok UNNEEDED,
					     const char *msg UNNEEDED)
{ fprintf(stderr, "command_fail_badparam called!\n"); abort(); }
/* Generated stub for daemon_developer_mode */
bool daemon_developer_mode(char *argv[])
{ fprintf(stderr, "daemon_developer_mode called!\n"); abort(); }
/* Generated stub for daemon_setup */
void daemon_setup(const char *argv0 UNNEEDED,
		  void (*backtrace_print)(const char *fmt UNNEEDED, ...) UNNEEDED,
		  void (*backtrace_exit)(void))
{ fprintf(stderr, "daemon_setup called!\n"); abort(); }
/* Generated stub for deprecated_ok_ */
bool  deprecated_ok_(bool deprecated_apis UNNEEDED,
		    const char *feature UNNEEDED,
		    const char *start UNNEEDED,
		    const char *end UNNEEDED,
		    const char **begs UNNEEDED,
		    void (*complain)(const char *feat UNNEEDED, bool allowing UNNEEDED, void *) UNNEEDED,
		    void *cbarg UNNEEDED)
{ fprintf(stderr, "deprecated_ok_ called!\n"); abort(); }
/* Generated stub for first_fee_state */
enum htlc_state first_fee_state(enum side opener UNNEEDED)
{ fprintf(stderr, "first_fee_state called!\n"); abort(); }
/* Generated stub for fmt_wireaddr_without_port */
char *fmt_wireaddr_without_port(const tal_t *ctx UNNEEDED, const struct wireaddr *a UNNEEDED)
{ fprintf(stderr, "fmt_wireaddr_without_port called!\n"); abort(); }
/* Generated stub for fromwire_wireaddr */
bool fromwire_wireaddr(const u8 **cursor UNNEEDED, size_t *max UNNEEDED, struct wireaddr *addr UNNEEDED)
{ fprintf(stderr, "fromwire_wireaddr called!\n"); abort(); }
/* Generated stub for htlc_state_flags */
int htlc_state_flags(enum htlc_state state UNNEEDED)
{ fprintf(stderr, "htlc_state_flags called!\n"); abort(); }
/* Generated stub for htlc_state_name */
const char *htlc_state_name(enum htlc_state s UNNEEDED)
{ fprintf(stderr, "htlc_state_name called!\n"); abort(); }
/* Generated stub for is_asterix_notification */
bool is_asterix_notification(const char *notification_name UNNEEDED,
			     const char *subscriptions UNNEEDED)
{ fprintf(stderr, "is_asterix_notification called!\n"); abort(); }
/* Generated stub for json_scan */
const char *json_scan(const tal_t *ctx UNNEEDED,
		      const char *buffer UNNEEDED,
		      const jsmntok_t *tok UNNEEDED,
		      const char *guide UNNEEDED,
		      ...)
{ fprintf(stderr, "json_scan called!\n"); abort(); }
/* Generated stub for json_scanv */
const char *json_scanv(const tal_t *ctx UNNEEDED,
		       const char *buffer UNNEEDED,
		       const jsmntok_t *tok UNNEEDED,
		       const char *guide UNNEEDED,
		       va_list ap UNNEEDED)
{ fprintf(stderr, "json_scanv called!\n"); abort(); }
/* Generated stub for json_to_int */
bool json_to_int(const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED, int *num UNNEEDED)
{ fprintf(stderr, "json_to_int called!\n"); abort(); }
/* Generated stub for json_to_msat */
bool json_to_msat(const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED,
		  struct amount_msat *msat UNNEEDED)
{ fprintf(stderr, "json_to_msat called!\n"); abort(); }
/* Generated stub for json_to_node_id */
bool json_to_node_id(const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED,
			       struct node_id *id UNNEEDED)
{ fprintf(stderr, "json_to_node_id called!\n"); abort(); }
/* Generated stub for json_to_number */
bool json_to_number(const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED,
		    unsigned int *num UNNEEDED)
{ fprintf(stderr, "json_to_number called!\n"); abort(); }
/* Generated stub for json_to_secret */
bool json_to_secret(const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED, struct secret *dest UNNEEDED)
{ fprintf(stderr, "json_to_secret called!\n"); abort(); }
/* Generated stub for json_to_short_channel_id */
bool json_to_short_channel_id(const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED,
			      struct short_channel_id *scid UNNEEDED)
{ fprintf(stderr, "json_to_short_channel_id called!\n"); abort(); }
/* Generated stub for json_to_txid */
bool json_to_txid(const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED,
		  struct bitcoin_txid *txid UNNEEDED)
{ fprintf(stderr, "json_to_txid called!\n"); abort(); }
/* Generated stub for json_to_u16 */
bool json_to_u16(const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED,
                 uint16_t *num UNNEEDED)
{ fprintf(stderr, "json_to_u16 called!\n"); abort(); }
/* Generated stub for json_tok_bin_from_hex */
u8 *json_tok_bin_from_hex(const tal_t *ctx UNNEEDED, const char *buffer UNNEEDED, const jsmntok_t *tok UNNEEDED)
{ fprintf(stderr, "json_tok_bin_from_hex called!\n"); abort(); }
/* Generated stub for last_fee_state */
enum htlc_state last_fee_state(enum side opener UNNEEDED)
{ fprintf(stderr, "last_fee_state called!\n"); abort(); }
/* Generated stub for log_level_name */
const char *log_level_name(enum log_level level UNNEEDED)
{ fprintf(stderr, "log_level_name called!\n"); abort(); }
/* Generated stub for param_check */
bool param_check(struct command *cmd UNNEEDED,
		 const char *buffer UNNEEDED,
		 const jsmntok_t tokens[] UNNEEDED, ...)
{ fprintf(stderr, "param_check called!\n"); abort(); }
/* Generated stub for send_backtrace */
void send_backtrace(const char *why UNNEEDED)
{ fprintf(stderr, "send_backtrace called!\n"); abort(); }
/* AUTOGENERATED MOCKS END */

static char *tmp_dsn(const tal_t *ctx)
{
	char *dsn, *filename;
	int fd = tmpdir_mkstemp(ctx, "lacct-db-XXXXXX", &filename);
	if (fd == -1)
		return NULL;
	close(fd);

	dsn = tal_fmt(NULL, "sqlite3://%s", filename);
	tal_free(filename);

	return dsn;
}

static struct db *create_test_db(void)
{
	struct db *db;
	char *dsn;

	dsn = tmp_dsn(NULL);
	db = db_open(NULL, dsn, true, db_error, (struct plugin *)NULL);
	db->data_version = 0;
	db->report_changes_fn = NULL;

	tal_free(dsn);
	return db;
}

static bool test_db_migrate(struct plugin *plugin)
{
	struct db *db = create_test_db();

	CHECK(db);
	db_begin_transaction(db);
	CHECK(db_get_version(db) == -1);
	CHECK(db_migrate(plugin, db) == true);
	db_commit_transaction(db);

	db_begin_transaction(db);
	CHECK(db_get_version(db) == ARRAY_SIZE(db_migrations) - 1);
	db_commit_transaction(db);

	db_begin_transaction(db);
	CHECK(db_migrate(plugin, db) == false);
	db_commit_transaction(db);

	tal_free(db);
	return true;
}

int main(int argc, char *argv[])
{
	bool ok = true;
	/* Dummy for migration hooks */
	struct plugin *plugin = tal(NULL, struct plugin);
	list_head_init(&plugin->js_list);

	common_setup(argv[0]);

	if (HAVE_SQLITE3) {
		ok &= test_db_migrate(plugin);
	}

	tal_free(plugin);
	common_shutdown();
	trace_cleanup();
	return !ok;
}
