#include <wire/fromwire.c>

#include <ccan/array_size/array_size.h>
#include <stdio.h>

/* AUTOGENERATED MOCKS START */
/* Generated stub for amount_asset_is_main */
bool amount_asset_is_main(struct amount_asset *asset UNNEEDED)
{ fprintf(stderr, "amount_asset_is_main called!\n"); abort(); }
/* Generated stub for amount_asset_to_sat */
struct amount_sat amount_asset_to_sat(struct amount_asset *asset UNNEEDED)
{ fprintf(stderr, "amount_asset_to_sat called!\n"); abort(); }
/* Generated stub for amount_sat_add */
 bool amount_sat_add(struct amount_sat *val UNNEEDED,
				       struct amount_sat a UNNEEDED,
				       struct amount_sat b UNNEEDED)
{ fprintf(stderr, "amount_sat_add called!\n"); abort(); }
/* Generated stub for amount_sat_eq */
bool amount_sat_eq(struct amount_sat a UNNEEDED, struct amount_sat b UNNEEDED)
{ fprintf(stderr, "amount_sat_eq called!\n"); abort(); }
/* Generated stub for amount_sat_sub */
 bool amount_sat_sub(struct amount_sat *val UNNEEDED,
				       struct amount_sat a UNNEEDED,
				       struct amount_sat b UNNEEDED)
{ fprintf(stderr, "amount_sat_sub called!\n"); abort(); }
/* Generated stub for bigsize_get */
size_t bigsize_get(const u8 *p UNNEEDED, size_t max UNNEEDED, bigsize_t *val UNNEEDED)
{ fprintf(stderr, "bigsize_get called!\n"); abort(); }
/* AUTOGENERATED MOCKS END */

struct channel_id_case {
	const char *node_id_1;
	const char *node_id_2;
	const char *basepoint_1;
	const char *basepoint_2;
	const char *expected_channel_id;
	bool succeeds;
};

const struct channel_id_case CASES[3] = {
	{
		.node_id_1 = "0281843858cc0db1fb200d039959d37d73506c930defefbce500735657ab5e8028",
		.node_id_2 = "0266d801ddc5ab61892a55fbad0f5f997b798f9f967ba16a442d3b59802b22a4ef",
		.basepoint_1 = "03e963488c5b152dc11a81c9314c1cb4b079111e18447a3be43c54a18c01fd2e9c",
		.basepoint_2 = "02b5da66d2410c36a7fc705e9310eaa3cec6d7734e34d08cca73f172e26a5209b8",
		.expected_channel_id = "30c551f400a3655146579a31b0602ed4d900ee52d7db209a3114eed690258ee0",
		.succeeds = true,
	},
	{
		.node_id_1 = "029d2a3d899632b4ec1c8269d1e96dd92739b87d9d5a63cdd016c06648a99d3f82",
		.node_id_2 = "02ffe66ef77ca3b6a459c3c1a19878cbe935088bd9dd7d7da0448b46a2e5daf00f",
		.basepoint_1 = "0283bb6d3c637e73e80505661b2c22966706993f4899444889573c8f116731a965",
		.basepoint_2 = "03512fa110c4b3a54069685107c7107a6abf1fc50d974a4e1feb80681b6da6b5a3",
		.expected_channel_id = "a1caa6ca96fa9a53e12b908bf10099e49f42ee067f673837588b37463832cecb",
		.succeeds = true,
	},
	{
		.node_id_1 = "02ffe66ef77ca3b6a459c3c1a19878cbe935088bd9dd7d7da0448b46a2e5daf00f",
		.node_id_2 = "029d2a3d899632b4ec1c8269d1e96dd92739b87d9d5a63cdd016c06648a99d3f82",
		.basepoint_1 = "0283bb6d3c637e73e80505661b2c22966706993f4899444889573c8f116731a965",
		.basepoint_2 = "03512fa110c4b3a54069685107c7107a6abf1fc50d974a4e1feb80681b6da6b5a3",
		.expected_channel_id = "82ab63012bc09293516e424d146442d7d1c7458a256467e2ccb9fe93c90c7379",
		.succeeds = false,
	},
};

static void test_channel_id2(const tal_t *ctx)
{
	size_t i, len = ARRAY_SIZE(CASES);
	struct channel_id_case c;
	struct node_id n1, n2;
	struct pubkey bp1, bp2;
	struct channel_id a, b;
	u8 *hex;

	for (i = 0; i < len; i++) {
		c = CASES[i];

		if (!node_id_from_hexstr(c.node_id_1, strlen(c.node_id_1), &n1))
			abort();
		if (!node_id_from_hexstr(c.node_id_2, strlen(c.node_id_2), &n2))
			abort();
		if (!pubkey_from_hexstr(c.basepoint_1, strlen(c.basepoint_1), &bp1))
			abort();
		if (!pubkey_from_hexstr(c.basepoint_2, strlen(c.basepoint_2), &bp2))
			abort();

		hex = tal_hexdata(ctx, c.expected_channel_id,
				  strlen(c.expected_channel_id));
		assert(sizeof(a.id) == tal_bytelen(hex));
		memcpy(a.id, hex, sizeof(a.id));

		derive_channel_id2(&b, &bp1, &bp2, node_id_cmp(&n1, &n2));
		assert(channel_id_eq(&a, &b) == c.succeeds);
	}
}

int main(void)
{
	const tal_t *ctx = tal(NULL, u8);
	setup_locale();

	test_channel_id2(ctx);

	tal_free(ctx);
}
