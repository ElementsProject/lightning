/* This file was generated by generate-wire.py */
/* Do not modify this file! Modify the .csv file it was generated from. */
/* Original template can be found at tools/gen/impl_template */

#include <wire/bolt12_wiregen.h>
#include <assert.h>
#include <ccan/array_size/array_size.h>
#include <ccan/mem/mem.h>
#include <ccan/tal/str/str.h>
#include <common/utils.h>
#include <stdio.h>

#ifndef SUPERVERBOSE
#define SUPERVERBOSE(...)
#endif




/* SUBTYPE: BLINDED_PATH */
void towire_blinded_path(u8 **p, const struct blinded_path *blinded_path)
{
	u16 num_hops = tal_count(blinded_path->path);

	towire_pubkey(p, &blinded_path->blinding);
	towire_u16(p, num_hops);
		for (size_t i = 0; i < num_hops; i++)
		towire_onionmsg_path(p, blinded_path->path[i]);
}
struct blinded_path *
fromwire_blinded_path(const tal_t *ctx, const u8 **cursor, size_t *plen)
{
	struct blinded_path *blinded_path = tal(ctx, struct blinded_path);
	u16 num_hops;

 	fromwire_pubkey(cursor, plen, &blinded_path->blinding);
 	num_hops = fromwire_u16(cursor, plen);
 	blinded_path->path = num_hops ? tal_arr(blinded_path, struct onionmsg_path *, 0) : NULL;
	for (size_t i = 0; i < num_hops; i++) {
		struct onionmsg_path * tmp;
		tmp = fromwire_onionmsg_path(blinded_path, cursor, plen);
		tal_arr_expand(&blinded_path->path, tmp);
	}

	return blinded_path;
}

/* SUBTYPE: BLINDED_PAYINFO */
void towire_blinded_payinfo(u8 **p, const struct blinded_payinfo *blinded_payinfo)
{
	u16 flen = tal_count(blinded_payinfo->features);

	towire_u32(p, blinded_payinfo->fee_base_msat);
	towire_u32(p, blinded_payinfo->fee_proportional_millionths);
	towire_u16(p, blinded_payinfo->cltv_expiry_delta);
	towire_u16(p, flen);
	towire_u8_array(p, blinded_payinfo->features, flen);
}
struct blinded_payinfo *
fromwire_blinded_payinfo(const tal_t *ctx, const u8 **cursor, size_t *plen)
{
	struct blinded_payinfo *blinded_payinfo = tal(ctx, struct blinded_payinfo);
	u16 flen;

 	blinded_payinfo->fee_base_msat = fromwire_u32(cursor, plen);
 	blinded_payinfo->fee_proportional_millionths = fromwire_u32(cursor, plen);
 	blinded_payinfo->cltv_expiry_delta = fromwire_u16(cursor, plen);
 	flen = fromwire_u16(cursor, plen);
 	blinded_payinfo->features = flen ? tal_arr(blinded_payinfo, u8, flen) : NULL;
fromwire_u8_array(cursor, plen, blinded_payinfo->features, flen);

	return blinded_payinfo;
}

/* SUBTYPE: FALLBACK_ADDRESS */
void towire_fallback_address(u8 **p, const struct fallback_address *fallback_address)
{
	u16 len = tal_count(fallback_address->address);

	towire_u8(p, fallback_address->version);
	towire_u16(p, len);
	towire_u8_array(p, fallback_address->address, len);
}
struct fallback_address *
fromwire_fallback_address(const tal_t *ctx, const u8 **cursor, size_t *plen)
{
	struct fallback_address *fallback_address = tal(ctx, struct fallback_address);
	u16 len;

 	fallback_address->version = fromwire_u8(cursor, plen);
 	len = fromwire_u16(cursor, plen);
 	fallback_address->address = len ? tal_arr(fallback_address, u8, len) : NULL;
fromwire_u8_array(cursor, plen, fallback_address->address, len);

	return fallback_address;
}


struct tlv_offer *tlv_offer_new(const tal_t *ctx)
{
	/* Initialize everything to NULL. (Quiet, C pedants!) */
	struct tlv_offer *inst = talz(ctx, struct tlv_offer);

	/* Initialized the fields to an empty array. */
	inst->fields = tal_arr(inst, struct tlv_field, 0);
	return inst;
}

/* OFFER MSG: chains */
static u8 *towire_tlv_offer_chains(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_offer *r = vrecord;
	u8 *ptr;

	if (!r->chains)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

		for (size_t i = 0; i < tal_count(r->chains); i++)
		towire_bitcoin_blkid(&ptr, r->chains + i);
	return ptr;
}
static void fromwire_tlv_offer_chains(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_offer *r = vrecord;

	r->chains = *plen ? tal_arr(r, struct bitcoin_blkid, 0) : NULL;
	for (size_t i = 0; *plen != 0; i++) {
		struct bitcoin_blkid tmp;
		fromwire_bitcoin_blkid(cursor, plen, &tmp);
		tal_arr_expand(&r->chains, tmp);
	}
}
/* OFFER MSG: currency */
static u8 *towire_tlv_offer_currency(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_offer *r = vrecord;
	u8 *ptr;

	if (!r->currency)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_utf8_array(&ptr, r->currency, tal_count(r->currency));
	return ptr;
}
static void fromwire_tlv_offer_currency(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_offer *r = vrecord;

	r->currency = *plen ? tal_arr(r, utf8, *plen) : NULL;
fromwire_utf8_array(cursor, plen, r->currency, *plen);
}
/* OFFER MSG: amount */
static u8 *towire_tlv_offer_amount(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_offer *r = vrecord;
	u8 *ptr;

	if (!r->amount)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_tu64(&ptr, *r->amount);
	return ptr;
}
static void fromwire_tlv_offer_amount(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_offer *r = vrecord;

	    r->amount = tal(r, u64);

*r->amount = fromwire_tu64(cursor, plen);
}
/* OFFER MSG: description */
static u8 *towire_tlv_offer_description(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_offer *r = vrecord;
	u8 *ptr;

	if (!r->description)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_utf8_array(&ptr, r->description, tal_count(r->description));
	return ptr;
}
static void fromwire_tlv_offer_description(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_offer *r = vrecord;

	r->description = *plen ? tal_arr(r, utf8, *plen) : NULL;
fromwire_utf8_array(cursor, plen, r->description, *plen);
}
/* OFFER MSG: features */
static u8 *towire_tlv_offer_features(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_offer *r = vrecord;
	u8 *ptr;

	if (!r->features)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_u8_array(&ptr, r->features, tal_count(r->features));
	return ptr;
}
static void fromwire_tlv_offer_features(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_offer *r = vrecord;

	r->features = *plen ? tal_arr(r, u8, *plen) : NULL;
fromwire_u8_array(cursor, plen, r->features, *plen);
}
/* OFFER MSG: absolute_expiry */
static u8 *towire_tlv_offer_absolute_expiry(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_offer *r = vrecord;
	u8 *ptr;

	if (!r->absolute_expiry)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_tu64(&ptr, *r->absolute_expiry);
	return ptr;
}
static void fromwire_tlv_offer_absolute_expiry(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_offer *r = vrecord;

	    r->absolute_expiry = tal(r, u64);

*r->absolute_expiry = fromwire_tu64(cursor, plen);
}
/* OFFER MSG: paths */
static u8 *towire_tlv_offer_paths(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_offer *r = vrecord;
	u8 *ptr;

	if (!r->paths)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

		for (size_t i = 0; i < tal_count(r->paths); i++)
		towire_blinded_path(&ptr, r->paths[i]);
	return ptr;
}
static void fromwire_tlv_offer_paths(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_offer *r = vrecord;

	r->paths = *plen ? tal_arr(r, struct blinded_path *, 0) : NULL;
	for (size_t i = 0; *plen != 0; i++) {
		struct blinded_path * tmp;
		tmp = fromwire_blinded_path(r, cursor, plen);
		tal_arr_expand(&r->paths, tmp);
	}
}
/* OFFER MSG: vendor */
static u8 *towire_tlv_offer_vendor(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_offer *r = vrecord;
	u8 *ptr;

	if (!r->vendor)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_utf8_array(&ptr, r->vendor, tal_count(r->vendor));
	return ptr;
}
static void fromwire_tlv_offer_vendor(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_offer *r = vrecord;

	r->vendor = *plen ? tal_arr(r, utf8, *plen) : NULL;
fromwire_utf8_array(cursor, plen, r->vendor, *plen);
}
/* OFFER MSG: quantity_min */
static u8 *towire_tlv_offer_quantity_min(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_offer *r = vrecord;
	u8 *ptr;

	if (!r->quantity_min)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_tu64(&ptr, *r->quantity_min);
	return ptr;
}
static void fromwire_tlv_offer_quantity_min(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_offer *r = vrecord;

	    r->quantity_min = tal(r, u64);

*r->quantity_min = fromwire_tu64(cursor, plen);
}
/* OFFER MSG: quantity_max */
static u8 *towire_tlv_offer_quantity_max(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_offer *r = vrecord;
	u8 *ptr;

	if (!r->quantity_max)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_tu64(&ptr, *r->quantity_max);
	return ptr;
}
static void fromwire_tlv_offer_quantity_max(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_offer *r = vrecord;

	    r->quantity_max = tal(r, u64);

*r->quantity_max = fromwire_tu64(cursor, plen);
}
/* OFFER MSG: recurrence */
static u8 *towire_tlv_offer_recurrence(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_offer *r = vrecord;
	u8 *ptr;

	if (!r->recurrence)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_u8(&ptr, r->recurrence->time_unit);

	towire_tu32(&ptr, r->recurrence->period);
	return ptr;
}
static void fromwire_tlv_offer_recurrence(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_offer *r = vrecord;

	r->recurrence = tal(r, struct tlv_offer_recurrence);
	r->recurrence->time_unit = fromwire_u8(cursor, plen);
	r->recurrence->period = fromwire_tu32(cursor, plen);
}
/* OFFER MSG: recurrence_paywindow */
static u8 *towire_tlv_offer_recurrence_paywindow(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_offer *r = vrecord;
	u8 *ptr;

	if (!r->recurrence_paywindow)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_u32(&ptr, r->recurrence_paywindow->seconds_before);

	towire_u8(&ptr, r->recurrence_paywindow->proportional_amount);

	towire_tu32(&ptr, r->recurrence_paywindow->seconds_after);
	return ptr;
}
static void fromwire_tlv_offer_recurrence_paywindow(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_offer *r = vrecord;

	r->recurrence_paywindow = tal(r, struct tlv_offer_recurrence_paywindow);
	r->recurrence_paywindow->seconds_before = fromwire_u32(cursor, plen);
	r->recurrence_paywindow->proportional_amount = fromwire_u8(cursor, plen);
	r->recurrence_paywindow->seconds_after = fromwire_tu32(cursor, plen);
}
/* OFFER MSG: recurrence_limit */
static u8 *towire_tlv_offer_recurrence_limit(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_offer *r = vrecord;
	u8 *ptr;

	if (!r->recurrence_limit)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_tu32(&ptr, *r->recurrence_limit);
	return ptr;
}
static void fromwire_tlv_offer_recurrence_limit(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_offer *r = vrecord;

	    r->recurrence_limit = tal(r, u32);

*r->recurrence_limit = fromwire_tu32(cursor, plen);
}
/* OFFER MSG: recurrence_base */
static u8 *towire_tlv_offer_recurrence_base(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_offer *r = vrecord;
	u8 *ptr;

	if (!r->recurrence_base)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_u8(&ptr, r->recurrence_base->start_any_period);

	towire_tu64(&ptr, r->recurrence_base->basetime);
	return ptr;
}
static void fromwire_tlv_offer_recurrence_base(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_offer *r = vrecord;

	r->recurrence_base = tal(r, struct tlv_offer_recurrence_base);
	r->recurrence_base->start_any_period = fromwire_u8(cursor, plen);
	r->recurrence_base->basetime = fromwire_tu64(cursor, plen);
}
/* OFFER MSG: node_id */
static u8 *towire_tlv_offer_node_id(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_offer *r = vrecord;
	u8 *ptr;

	if (!r->node_id)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_pubkey32(&ptr, r->node_id);
	return ptr;
}
static void fromwire_tlv_offer_node_id(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_offer *r = vrecord;

	    r->node_id = tal(r, struct pubkey32);

fromwire_pubkey32(cursor, plen, &*r->node_id);
}
/* OFFER MSG: send_invoice */
static u8 *towire_tlv_offer_send_invoice(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_offer *r = vrecord;
	u8 *ptr;

	if (!r->send_invoice)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);
	return ptr;
}
static void fromwire_tlv_offer_send_invoice(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_offer *r = vrecord;

	r->send_invoice = tal(r, struct tlv_offer_send_invoice);
}
/* OFFER MSG: refund_for */
static u8 *towire_tlv_offer_refund_for(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_offer *r = vrecord;
	u8 *ptr;

	if (!r->refund_for)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_sha256(&ptr, r->refund_for);
	return ptr;
}
static void fromwire_tlv_offer_refund_for(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_offer *r = vrecord;

	    r->refund_for = tal(r, struct sha256);

fromwire_sha256(cursor, plen, &*r->refund_for);
}
/* OFFER MSG: signature */
static u8 *towire_tlv_offer_signature(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_offer *r = vrecord;
	u8 *ptr;

	if (!r->signature)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_bip340sig(&ptr, r->signature);
	return ptr;
}
static void fromwire_tlv_offer_signature(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_offer *r = vrecord;

	    r->signature = tal(r, struct bip340sig);

fromwire_bip340sig(cursor, plen, &*r->signature);
}

static const struct tlv_record_type tlvs_offer[] = {
	{ 2, towire_tlv_offer_chains, fromwire_tlv_offer_chains },
	{ 6, towire_tlv_offer_currency, fromwire_tlv_offer_currency },
	{ 8, towire_tlv_offer_amount, fromwire_tlv_offer_amount },
	{ 10, towire_tlv_offer_description, fromwire_tlv_offer_description },
	{ 12, towire_tlv_offer_features, fromwire_tlv_offer_features },
	{ 14, towire_tlv_offer_absolute_expiry, fromwire_tlv_offer_absolute_expiry },
	{ 16, towire_tlv_offer_paths, fromwire_tlv_offer_paths },
	{ 20, towire_tlv_offer_vendor, fromwire_tlv_offer_vendor },
	{ 22, towire_tlv_offer_quantity_min, fromwire_tlv_offer_quantity_min },
	{ 24, towire_tlv_offer_quantity_max, fromwire_tlv_offer_quantity_max },
	{ 26, towire_tlv_offer_recurrence, fromwire_tlv_offer_recurrence },
	{ 28, towire_tlv_offer_recurrence_base, fromwire_tlv_offer_recurrence_base },
	{ 30, towire_tlv_offer_node_id, fromwire_tlv_offer_node_id },
	{ 34, towire_tlv_offer_refund_for, fromwire_tlv_offer_refund_for },
	{ 54, towire_tlv_offer_send_invoice, fromwire_tlv_offer_send_invoice },
	{ 64, towire_tlv_offer_recurrence_paywindow, fromwire_tlv_offer_recurrence_paywindow },
	{ 66, towire_tlv_offer_recurrence_limit, fromwire_tlv_offer_recurrence_limit },
	{ 240, towire_tlv_offer_signature, fromwire_tlv_offer_signature },
};

void towire_offer(u8 **pptr, const struct tlv_offer *record)
{
	towire_tlv(pptr, tlvs_offer, 18, record);
}


bool fromwire_offer(const u8 **cursor, size_t *max, struct tlv_offer *record)
{
	return fromwire_tlv(cursor, max, tlvs_offer, 18, record, &record->fields);
}

bool offer_is_valid(const struct tlv_offer *record, size_t *err_index)
{
	return tlv_fields_valid(record->fields, err_index);
}


struct tlv_invoice_request *tlv_invoice_request_new(const tal_t *ctx)
{
	/* Initialize everything to NULL. (Quiet, C pedants!) */
	struct tlv_invoice_request *inst = talz(ctx, struct tlv_invoice_request);

	/* Initialized the fields to an empty array. */
	inst->fields = tal_arr(inst, struct tlv_field, 0);
	return inst;
}

/* INVOICE_REQUEST MSG: chains */
static u8 *towire_tlv_invoice_request_chains(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice_request *r = vrecord;
	u8 *ptr;

	if (!r->chains)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

		for (size_t i = 0; i < tal_count(r->chains); i++)
		towire_bitcoin_blkid(&ptr, r->chains + i);
	return ptr;
}
static void fromwire_tlv_invoice_request_chains(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice_request *r = vrecord;

	r->chains = *plen ? tal_arr(r, struct bitcoin_blkid, 0) : NULL;
	for (size_t i = 0; *plen != 0; i++) {
		struct bitcoin_blkid tmp;
		fromwire_bitcoin_blkid(cursor, plen, &tmp);
		tal_arr_expand(&r->chains, tmp);
	}
}
/* INVOICE_REQUEST MSG: offer_id */
static u8 *towire_tlv_invoice_request_offer_id(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice_request *r = vrecord;
	u8 *ptr;

	if (!r->offer_id)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_sha256(&ptr, r->offer_id);
	return ptr;
}
static void fromwire_tlv_invoice_request_offer_id(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice_request *r = vrecord;

	    r->offer_id = tal(r, struct sha256);

fromwire_sha256(cursor, plen, &*r->offer_id);
}
/* INVOICE_REQUEST MSG: amount */
static u8 *towire_tlv_invoice_request_amount(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice_request *r = vrecord;
	u8 *ptr;

	if (!r->amount)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_tu64(&ptr, *r->amount);
	return ptr;
}
static void fromwire_tlv_invoice_request_amount(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice_request *r = vrecord;

	    r->amount = tal(r, u64);

*r->amount = fromwire_tu64(cursor, plen);
}
/* INVOICE_REQUEST MSG: features */
static u8 *towire_tlv_invoice_request_features(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice_request *r = vrecord;
	u8 *ptr;

	if (!r->features)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_u8_array(&ptr, r->features, tal_count(r->features));
	return ptr;
}
static void fromwire_tlv_invoice_request_features(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice_request *r = vrecord;

	r->features = *plen ? tal_arr(r, u8, *plen) : NULL;
fromwire_u8_array(cursor, plen, r->features, *plen);
}
/* INVOICE_REQUEST MSG: quantity */
static u8 *towire_tlv_invoice_request_quantity(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice_request *r = vrecord;
	u8 *ptr;

	if (!r->quantity)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_tu64(&ptr, *r->quantity);
	return ptr;
}
static void fromwire_tlv_invoice_request_quantity(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice_request *r = vrecord;

	    r->quantity = tal(r, u64);

*r->quantity = fromwire_tu64(cursor, plen);
}
/* INVOICE_REQUEST MSG: recurrence_counter */
static u8 *towire_tlv_invoice_request_recurrence_counter(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice_request *r = vrecord;
	u8 *ptr;

	if (!r->recurrence_counter)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_tu32(&ptr, *r->recurrence_counter);
	return ptr;
}
static void fromwire_tlv_invoice_request_recurrence_counter(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice_request *r = vrecord;

	    r->recurrence_counter = tal(r, u32);

*r->recurrence_counter = fromwire_tu32(cursor, plen);
}
/* INVOICE_REQUEST MSG: recurrence_start */
static u8 *towire_tlv_invoice_request_recurrence_start(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice_request *r = vrecord;
	u8 *ptr;

	if (!r->recurrence_start)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_tu32(&ptr, *r->recurrence_start);
	return ptr;
}
static void fromwire_tlv_invoice_request_recurrence_start(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice_request *r = vrecord;

	    r->recurrence_start = tal(r, u32);

*r->recurrence_start = fromwire_tu32(cursor, plen);
}
/* INVOICE_REQUEST MSG: payer_key */
static u8 *towire_tlv_invoice_request_payer_key(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice_request *r = vrecord;
	u8 *ptr;

	if (!r->payer_key)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_pubkey32(&ptr, r->payer_key);
	return ptr;
}
static void fromwire_tlv_invoice_request_payer_key(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice_request *r = vrecord;

	    r->payer_key = tal(r, struct pubkey32);

fromwire_pubkey32(cursor, plen, &*r->payer_key);
}
/* INVOICE_REQUEST MSG: payer_info */
static u8 *towire_tlv_invoice_request_payer_info(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice_request *r = vrecord;
	u8 *ptr;

	if (!r->payer_info)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_u8_array(&ptr, r->payer_info, tal_count(r->payer_info));
	return ptr;
}
static void fromwire_tlv_invoice_request_payer_info(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice_request *r = vrecord;

	r->payer_info = *plen ? tal_arr(r, u8, *plen) : NULL;
fromwire_u8_array(cursor, plen, r->payer_info, *plen);
}
/* INVOICE_REQUEST MSG: recurrence_signature */
static u8 *towire_tlv_invoice_request_recurrence_signature(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice_request *r = vrecord;
	u8 *ptr;

	if (!r->recurrence_signature)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_bip340sig(&ptr, r->recurrence_signature);
	return ptr;
}
static void fromwire_tlv_invoice_request_recurrence_signature(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice_request *r = vrecord;

	    r->recurrence_signature = tal(r, struct bip340sig);

fromwire_bip340sig(cursor, plen, &*r->recurrence_signature);
}

const struct tlv_record_type tlvs_invoice_request[] = {
	{ 2, towire_tlv_invoice_request_chains, fromwire_tlv_invoice_request_chains },
	{ 4, towire_tlv_invoice_request_offer_id, fromwire_tlv_invoice_request_offer_id },
	{ 8, towire_tlv_invoice_request_amount, fromwire_tlv_invoice_request_amount },
	{ 12, towire_tlv_invoice_request_features, fromwire_tlv_invoice_request_features },
	{ 32, towire_tlv_invoice_request_quantity, fromwire_tlv_invoice_request_quantity },
	{ 36, towire_tlv_invoice_request_recurrence_counter, fromwire_tlv_invoice_request_recurrence_counter },
	{ 38, towire_tlv_invoice_request_payer_key, fromwire_tlv_invoice_request_payer_key },
	{ 50, towire_tlv_invoice_request_payer_info, fromwire_tlv_invoice_request_payer_info },
	{ 68, towire_tlv_invoice_request_recurrence_start, fromwire_tlv_invoice_request_recurrence_start },
	{ 242, towire_tlv_invoice_request_recurrence_signature, fromwire_tlv_invoice_request_recurrence_signature },
};

void towire_invoice_request(u8 **pptr, const struct tlv_invoice_request *record)
{
	towire_tlv(pptr, tlvs_invoice_request, 10, record);
}


bool fromwire_invoice_request(const u8 **cursor, size_t *max, struct tlv_invoice_request *record)
{
	return fromwire_tlv(cursor, max, tlvs_invoice_request, 10, record, &record->fields);
}

bool invoice_request_is_valid(const struct tlv_invoice_request *record, size_t *err_index)
{
	return tlv_fields_valid(record->fields, err_index);
}


struct tlv_invoice *tlv_invoice_new(const tal_t *ctx)
{
	/* Initialize everything to NULL. (Quiet, C pedants!) */
	struct tlv_invoice *inst = talz(ctx, struct tlv_invoice);

	/* Initialized the fields to an empty array. */
	inst->fields = tal_arr(inst, struct tlv_field, 0);
	return inst;
}

/* INVOICE MSG: chains */
static u8 *towire_tlv_invoice_chains(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice *r = vrecord;
	u8 *ptr;

	if (!r->chains)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

		for (size_t i = 0; i < tal_count(r->chains); i++)
		towire_bitcoin_blkid(&ptr, r->chains + i);
	return ptr;
}
static void fromwire_tlv_invoice_chains(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice *r = vrecord;

	r->chains = *plen ? tal_arr(r, struct bitcoin_blkid, 0) : NULL;
	for (size_t i = 0; *plen != 0; i++) {
		struct bitcoin_blkid tmp;
		fromwire_bitcoin_blkid(cursor, plen, &tmp);
		tal_arr_expand(&r->chains, tmp);
	}
}
/* INVOICE MSG: offer_id */
static u8 *towire_tlv_invoice_offer_id(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice *r = vrecord;
	u8 *ptr;

	if (!r->offer_id)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_sha256(&ptr, r->offer_id);
	return ptr;
}
static void fromwire_tlv_invoice_offer_id(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice *r = vrecord;

	    r->offer_id = tal(r, struct sha256);

fromwire_sha256(cursor, plen, &*r->offer_id);
}
/* INVOICE MSG: amount */
static u8 *towire_tlv_invoice_amount(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice *r = vrecord;
	u8 *ptr;

	if (!r->amount)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_tu64(&ptr, *r->amount);
	return ptr;
}
static void fromwire_tlv_invoice_amount(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice *r = vrecord;

	    r->amount = tal(r, u64);

*r->amount = fromwire_tu64(cursor, plen);
}
/* INVOICE MSG: description */
static u8 *towire_tlv_invoice_description(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice *r = vrecord;
	u8 *ptr;

	if (!r->description)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_utf8_array(&ptr, r->description, tal_count(r->description));
	return ptr;
}
static void fromwire_tlv_invoice_description(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice *r = vrecord;

	r->description = *plen ? tal_arr(r, utf8, *plen) : NULL;
fromwire_utf8_array(cursor, plen, r->description, *plen);
}
/* INVOICE MSG: features */
static u8 *towire_tlv_invoice_features(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice *r = vrecord;
	u8 *ptr;

	if (!r->features)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_u8_array(&ptr, r->features, tal_count(r->features));
	return ptr;
}
static void fromwire_tlv_invoice_features(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice *r = vrecord;

	r->features = *plen ? tal_arr(r, u8, *plen) : NULL;
fromwire_u8_array(cursor, plen, r->features, *plen);
}
/* INVOICE MSG: paths */
static u8 *towire_tlv_invoice_paths(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice *r = vrecord;
	u8 *ptr;

	if (!r->paths)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

		for (size_t i = 0; i < tal_count(r->paths); i++)
		towire_blinded_path(&ptr, r->paths[i]);
	return ptr;
}
static void fromwire_tlv_invoice_paths(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice *r = vrecord;

	r->paths = *plen ? tal_arr(r, struct blinded_path *, 0) : NULL;
	for (size_t i = 0; *plen != 0; i++) {
		struct blinded_path * tmp;
		tmp = fromwire_blinded_path(r, cursor, plen);
		tal_arr_expand(&r->paths, tmp);
	}
}
/* INVOICE MSG: blindedpay */
static u8 *towire_tlv_invoice_blindedpay(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice *r = vrecord;
	u8 *ptr;

	if (!r->blindedpay)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

		for (size_t i = 0; i < tal_count(r->blindedpay); i++)
		towire_blinded_payinfo(&ptr, r->blindedpay[i]);
	return ptr;
}
static void fromwire_tlv_invoice_blindedpay(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice *r = vrecord;

	r->blindedpay = *plen ? tal_arr(r, struct blinded_payinfo *, 0) : NULL;
	for (size_t i = 0; *plen != 0; i++) {
		struct blinded_payinfo * tmp;
		tmp = fromwire_blinded_payinfo(r, cursor, plen);
		tal_arr_expand(&r->blindedpay, tmp);
	}
}
/* INVOICE MSG: vendor */
static u8 *towire_tlv_invoice_vendor(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice *r = vrecord;
	u8 *ptr;

	if (!r->vendor)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_utf8_array(&ptr, r->vendor, tal_count(r->vendor));
	return ptr;
}
static void fromwire_tlv_invoice_vendor(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice *r = vrecord;

	r->vendor = *plen ? tal_arr(r, utf8, *plen) : NULL;
fromwire_utf8_array(cursor, plen, r->vendor, *plen);
}
/* INVOICE MSG: node_id */
static u8 *towire_tlv_invoice_node_id(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice *r = vrecord;
	u8 *ptr;

	if (!r->node_id)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_pubkey32(&ptr, r->node_id);
	return ptr;
}
static void fromwire_tlv_invoice_node_id(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice *r = vrecord;

	    r->node_id = tal(r, struct pubkey32);

fromwire_pubkey32(cursor, plen, &*r->node_id);
}
/* INVOICE MSG: quantity */
static u8 *towire_tlv_invoice_quantity(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice *r = vrecord;
	u8 *ptr;

	if (!r->quantity)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_tu64(&ptr, *r->quantity);
	return ptr;
}
static void fromwire_tlv_invoice_quantity(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice *r = vrecord;

	    r->quantity = tal(r, u64);

*r->quantity = fromwire_tu64(cursor, plen);
}
/* INVOICE MSG: refund_for */
static u8 *towire_tlv_invoice_refund_for(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice *r = vrecord;
	u8 *ptr;

	if (!r->refund_for)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_sha256(&ptr, r->refund_for);
	return ptr;
}
static void fromwire_tlv_invoice_refund_for(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice *r = vrecord;

	    r->refund_for = tal(r, struct sha256);

fromwire_sha256(cursor, plen, &*r->refund_for);
}
/* INVOICE MSG: recurrence_counter */
static u8 *towire_tlv_invoice_recurrence_counter(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice *r = vrecord;
	u8 *ptr;

	if (!r->recurrence_counter)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_tu32(&ptr, *r->recurrence_counter);
	return ptr;
}
static void fromwire_tlv_invoice_recurrence_counter(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice *r = vrecord;

	    r->recurrence_counter = tal(r, u32);

*r->recurrence_counter = fromwire_tu32(cursor, plen);
}
/* INVOICE MSG: send_invoice */
static u8 *towire_tlv_invoice_send_invoice(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice *r = vrecord;
	u8 *ptr;

	if (!r->send_invoice)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);
	return ptr;
}
static void fromwire_tlv_invoice_send_invoice(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice *r = vrecord;

	r->send_invoice = tal(r, struct tlv_invoice_send_invoice);
}
/* INVOICE MSG: recurrence_start */
static u8 *towire_tlv_invoice_recurrence_start(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice *r = vrecord;
	u8 *ptr;

	if (!r->recurrence_start)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_tu32(&ptr, *r->recurrence_start);
	return ptr;
}
static void fromwire_tlv_invoice_recurrence_start(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice *r = vrecord;

	    r->recurrence_start = tal(r, u32);

*r->recurrence_start = fromwire_tu32(cursor, plen);
}
/* INVOICE MSG: recurrence_basetime */
static u8 *towire_tlv_invoice_recurrence_basetime(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice *r = vrecord;
	u8 *ptr;

	if (!r->recurrence_basetime)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_tu64(&ptr, *r->recurrence_basetime);
	return ptr;
}
static void fromwire_tlv_invoice_recurrence_basetime(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice *r = vrecord;

	    r->recurrence_basetime = tal(r, u64);

*r->recurrence_basetime = fromwire_tu64(cursor, plen);
}
/* INVOICE MSG: payer_key */
static u8 *towire_tlv_invoice_payer_key(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice *r = vrecord;
	u8 *ptr;

	if (!r->payer_key)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_pubkey32(&ptr, r->payer_key);
	return ptr;
}
static void fromwire_tlv_invoice_payer_key(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice *r = vrecord;

	    r->payer_key = tal(r, struct pubkey32);

fromwire_pubkey32(cursor, plen, &*r->payer_key);
}
/* INVOICE MSG: payer_info */
static u8 *towire_tlv_invoice_payer_info(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice *r = vrecord;
	u8 *ptr;

	if (!r->payer_info)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_u8_array(&ptr, r->payer_info, tal_count(r->payer_info));
	return ptr;
}
static void fromwire_tlv_invoice_payer_info(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice *r = vrecord;

	r->payer_info = *plen ? tal_arr(r, u8, *plen) : NULL;
fromwire_u8_array(cursor, plen, r->payer_info, *plen);
}
/* INVOICE MSG: timestamp */
static u8 *towire_tlv_invoice_timestamp(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice *r = vrecord;
	u8 *ptr;

	if (!r->timestamp)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_tu64(&ptr, *r->timestamp);
	return ptr;
}
static void fromwire_tlv_invoice_timestamp(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice *r = vrecord;

	    r->timestamp = tal(r, u64);

*r->timestamp = fromwire_tu64(cursor, plen);
}
/* INVOICE MSG: payment_hash */
static u8 *towire_tlv_invoice_payment_hash(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice *r = vrecord;
	u8 *ptr;

	if (!r->payment_hash)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_sha256(&ptr, r->payment_hash);
	return ptr;
}
static void fromwire_tlv_invoice_payment_hash(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice *r = vrecord;

	    r->payment_hash = tal(r, struct sha256);

fromwire_sha256(cursor, plen, &*r->payment_hash);
}
/* INVOICE MSG: relative_expiry */
static u8 *towire_tlv_invoice_relative_expiry(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice *r = vrecord;
	u8 *ptr;

	if (!r->relative_expiry)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_tu32(&ptr, *r->relative_expiry);
	return ptr;
}
static void fromwire_tlv_invoice_relative_expiry(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice *r = vrecord;

	    r->relative_expiry = tal(r, u32);

*r->relative_expiry = fromwire_tu32(cursor, plen);
}
/* INVOICE MSG: cltv */
static u8 *towire_tlv_invoice_cltv(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice *r = vrecord;
	u8 *ptr;

	if (!r->cltv)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_tu32(&ptr, *r->cltv);
	return ptr;
}
static void fromwire_tlv_invoice_cltv(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice *r = vrecord;

	    r->cltv = tal(r, u32);

*r->cltv = fromwire_tu32(cursor, plen);
}
/* INVOICE MSG: fallbacks */
static u8 *towire_tlv_invoice_fallbacks(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice *r = vrecord;
	u8 *ptr;

	if (!r->fallbacks)
		return NULL;

	u8 num = tal_count(r->fallbacks->fallbacks);

	ptr = tal_arr(ctx, u8, 0);

	towire_u8(&ptr, num);

		for (size_t i = 0; i < num; i++)
		towire_fallback_address(&ptr, r->fallbacks->fallbacks[i]);
	return ptr;
}
static void fromwire_tlv_invoice_fallbacks(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice *r = vrecord;
	u8 num;

	r->fallbacks = tal(r, struct tlv_invoice_fallbacks);
	num = fromwire_u8(cursor, plen);
	r->fallbacks->fallbacks = num ? tal_arr(r->fallbacks, struct fallback_address *, 0) : NULL;
	for (size_t i = 0; i < num; i++) {
		struct fallback_address * tmp;
		tmp = fromwire_fallback_address(r->fallbacks, cursor, plen);
		tal_arr_expand(&r->fallbacks->fallbacks, tmp);
	}
}
/* INVOICE MSG: refund_signature */
static u8 *towire_tlv_invoice_refund_signature(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice *r = vrecord;
	u8 *ptr;

	if (!r->refund_signature)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_bip340sig(&ptr, r->refund_signature);
	return ptr;
}
static void fromwire_tlv_invoice_refund_signature(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice *r = vrecord;

	    r->refund_signature = tal(r, struct bip340sig);

fromwire_bip340sig(cursor, plen, &*r->refund_signature);
}
/* INVOICE MSG: signature */
static u8 *towire_tlv_invoice_signature(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice *r = vrecord;
	u8 *ptr;

	if (!r->signature)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_bip340sig(&ptr, r->signature);
	return ptr;
}
static void fromwire_tlv_invoice_signature(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice *r = vrecord;

	    r->signature = tal(r, struct bip340sig);

fromwire_bip340sig(cursor, plen, &*r->signature);
}

static const struct tlv_record_type tlvs_invoice[] = {
	{ 2, towire_tlv_invoice_chains, fromwire_tlv_invoice_chains },
	{ 4, towire_tlv_invoice_offer_id, fromwire_tlv_invoice_offer_id },
	{ 8, towire_tlv_invoice_amount, fromwire_tlv_invoice_amount },
	{ 10, towire_tlv_invoice_description, fromwire_tlv_invoice_description },
	{ 12, towire_tlv_invoice_features, fromwire_tlv_invoice_features },
	{ 16, towire_tlv_invoice_paths, fromwire_tlv_invoice_paths },
	{ 18, towire_tlv_invoice_blindedpay, fromwire_tlv_invoice_blindedpay },
	{ 20, towire_tlv_invoice_vendor, fromwire_tlv_invoice_vendor },
	{ 30, towire_tlv_invoice_node_id, fromwire_tlv_invoice_node_id },
	{ 32, towire_tlv_invoice_quantity, fromwire_tlv_invoice_quantity },
	{ 34, towire_tlv_invoice_refund_for, fromwire_tlv_invoice_refund_for },
	{ 36, towire_tlv_invoice_recurrence_counter, fromwire_tlv_invoice_recurrence_counter },
	{ 38, towire_tlv_invoice_payer_key, fromwire_tlv_invoice_payer_key },
	{ 40, towire_tlv_invoice_timestamp, fromwire_tlv_invoice_timestamp },
	{ 42, towire_tlv_invoice_payment_hash, fromwire_tlv_invoice_payment_hash },
	{ 44, towire_tlv_invoice_relative_expiry, fromwire_tlv_invoice_relative_expiry },
	{ 46, towire_tlv_invoice_cltv, fromwire_tlv_invoice_cltv },
	{ 48, towire_tlv_invoice_fallbacks, fromwire_tlv_invoice_fallbacks },
	{ 50, towire_tlv_invoice_payer_info, fromwire_tlv_invoice_payer_info },
	{ 52, towire_tlv_invoice_refund_signature, fromwire_tlv_invoice_refund_signature },
	{ 54, towire_tlv_invoice_send_invoice, fromwire_tlv_invoice_send_invoice },
	{ 64, towire_tlv_invoice_recurrence_basetime, fromwire_tlv_invoice_recurrence_basetime },
	{ 68, towire_tlv_invoice_recurrence_start, fromwire_tlv_invoice_recurrence_start },
	{ 240, towire_tlv_invoice_signature, fromwire_tlv_invoice_signature },
};

void towire_invoice(u8 **pptr, const struct tlv_invoice *record)
{
	towire_tlv(pptr, tlvs_invoice, 24, record);
}


bool fromwire_invoice(const u8 **cursor, size_t *max, struct tlv_invoice *record)
{
	return fromwire_tlv(cursor, max, tlvs_invoice, 24, record, &record->fields);
}

bool invoice_is_valid(const struct tlv_invoice *record, size_t *err_index)
{
	return tlv_fields_valid(record->fields, err_index);
}


struct tlv_invoice_error *tlv_invoice_error_new(const tal_t *ctx)
{
	/* Initialize everything to NULL. (Quiet, C pedants!) */
	struct tlv_invoice_error *inst = talz(ctx, struct tlv_invoice_error);

	/* Initialized the fields to an empty array. */
	inst->fields = tal_arr(inst, struct tlv_field, 0);
	return inst;
}

/* INVOICE_ERROR MSG: erroneous_field */
static u8 *towire_tlv_invoice_error_erroneous_field(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice_error *r = vrecord;
	u8 *ptr;

	if (!r->erroneous_field)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_tu64(&ptr, *r->erroneous_field);
	return ptr;
}
static void fromwire_tlv_invoice_error_erroneous_field(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice_error *r = vrecord;

	    r->erroneous_field = tal(r, u64);

*r->erroneous_field = fromwire_tu64(cursor, plen);
}
/* INVOICE_ERROR MSG: suggested_value */
static u8 *towire_tlv_invoice_error_suggested_value(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice_error *r = vrecord;
	u8 *ptr;

	if (!r->suggested_value)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_u8_array(&ptr, r->suggested_value, tal_count(r->suggested_value));
	return ptr;
}
static void fromwire_tlv_invoice_error_suggested_value(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice_error *r = vrecord;

	r->suggested_value = *plen ? tal_arr(r, u8, *plen) : NULL;
fromwire_u8_array(cursor, plen, r->suggested_value, *plen);
}
/* INVOICE_ERROR MSG: error */
static u8 *towire_tlv_invoice_error_error(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_invoice_error *r = vrecord;
	u8 *ptr;

	if (!r->error)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_utf8_array(&ptr, r->error, tal_count(r->error));
	return ptr;
}
static void fromwire_tlv_invoice_error_error(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_invoice_error *r = vrecord;

	r->error = *plen ? tal_arr(r, utf8, *plen) : NULL;
fromwire_utf8_array(cursor, plen, r->error, *plen);
}

static const struct tlv_record_type tlvs_invoice_error[] = {
	{ 1, towire_tlv_invoice_error_erroneous_field, fromwire_tlv_invoice_error_erroneous_field },
	{ 3, towire_tlv_invoice_error_suggested_value, fromwire_tlv_invoice_error_suggested_value },
	{ 5, towire_tlv_invoice_error_error, fromwire_tlv_invoice_error_error },
};

void towire_invoice_error(u8 **pptr, const struct tlv_invoice_error *record)
{
	towire_tlv(pptr, tlvs_invoice_error, 3, record);
}


bool fromwire_invoice_error(const u8 **cursor, size_t *max, struct tlv_invoice_error *record)
{
	return fromwire_tlv(cursor, max, tlvs_invoice_error, 3, record, &record->fields);
}

bool invoice_error_is_valid(const struct tlv_invoice_error *record, size_t *err_index)
{
	return tlv_fields_valid(record->fields, err_index);
}

// SHA256STAMP:3c8dc54796300320573ccf24c2ec022c4f95f545576e909e55da001c1d04392d
