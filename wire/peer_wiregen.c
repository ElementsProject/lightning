/* This file was generated by generate-wire.py */
/* Do not modify this file! Modify the .csv file it was generated from. */
/* Original template can be found at tools/gen/impl_template */

#include <wire/peer_wiregen.h>
#include <assert.h>
#include <ccan/array_size/array_size.h>
#include <ccan/mem/mem.h>
#include <ccan/tal/str/str.h>
#include <common/utils.h>
#include <stdio.h>

#ifndef SUPERVERBOSE
#define SUPERVERBOSE(...)
#endif


const char *peer_wire_name(int e)
{
	static char invalidbuf[sizeof("INVALID ") + STR_MAX_CHARS(e)];

	switch ((enum peer_wire)e) {
	case WIRE_INIT: return "WIRE_INIT";
	case WIRE_ERROR: return "WIRE_ERROR";
	case WIRE_WARNING: return "WIRE_WARNING";
	case WIRE_PING: return "WIRE_PING";
	case WIRE_PONG: return "WIRE_PONG";
	case WIRE_TX_ADD_INPUT: return "WIRE_TX_ADD_INPUT";
	case WIRE_TX_ADD_OUTPUT: return "WIRE_TX_ADD_OUTPUT";
	case WIRE_TX_REMOVE_INPUT: return "WIRE_TX_REMOVE_INPUT";
	case WIRE_TX_REMOVE_OUTPUT: return "WIRE_TX_REMOVE_OUTPUT";
	case WIRE_TX_COMPLETE: return "WIRE_TX_COMPLETE";
	case WIRE_TX_SIGNATURES: return "WIRE_TX_SIGNATURES";
	case WIRE_OPEN_CHANNEL: return "WIRE_OPEN_CHANNEL";
	case WIRE_ACCEPT_CHANNEL: return "WIRE_ACCEPT_CHANNEL";
	case WIRE_FUNDING_CREATED: return "WIRE_FUNDING_CREATED";
	case WIRE_FUNDING_SIGNED: return "WIRE_FUNDING_SIGNED";
	case WIRE_FUNDING_LOCKED: return "WIRE_FUNDING_LOCKED";
	case WIRE_OPEN_CHANNEL2: return "WIRE_OPEN_CHANNEL2";
	case WIRE_ACCEPT_CHANNEL2: return "WIRE_ACCEPT_CHANNEL2";
	case WIRE_INIT_RBF: return "WIRE_INIT_RBF";
	case WIRE_ACK_RBF: return "WIRE_ACK_RBF";
	case WIRE_SHUTDOWN: return "WIRE_SHUTDOWN";
	case WIRE_CLOSING_SIGNED: return "WIRE_CLOSING_SIGNED";
	case WIRE_UPDATE_ADD_HTLC: return "WIRE_UPDATE_ADD_HTLC";
	case WIRE_UPDATE_FULFILL_HTLC: return "WIRE_UPDATE_FULFILL_HTLC";
	case WIRE_UPDATE_FAIL_HTLC: return "WIRE_UPDATE_FAIL_HTLC";
	case WIRE_UPDATE_FAIL_MALFORMED_HTLC: return "WIRE_UPDATE_FAIL_MALFORMED_HTLC";
	case WIRE_COMMITMENT_SIGNED: return "WIRE_COMMITMENT_SIGNED";
	case WIRE_REVOKE_AND_ACK: return "WIRE_REVOKE_AND_ACK";
	case WIRE_UPDATE_FEE: return "WIRE_UPDATE_FEE";
	case WIRE_CHANNEL_REESTABLISH: return "WIRE_CHANNEL_REESTABLISH";
	case WIRE_ANNOUNCEMENT_SIGNATURES: return "WIRE_ANNOUNCEMENT_SIGNATURES";
	case WIRE_CHANNEL_ANNOUNCEMENT: return "WIRE_CHANNEL_ANNOUNCEMENT";
	case WIRE_NODE_ANNOUNCEMENT: return "WIRE_NODE_ANNOUNCEMENT";
	case WIRE_CHANNEL_UPDATE: return "WIRE_CHANNEL_UPDATE";
	case WIRE_QUERY_SHORT_CHANNEL_IDS: return "WIRE_QUERY_SHORT_CHANNEL_IDS";
	case WIRE_REPLY_SHORT_CHANNEL_IDS_END: return "WIRE_REPLY_SHORT_CHANNEL_IDS_END";
	case WIRE_QUERY_CHANNEL_RANGE: return "WIRE_QUERY_CHANNEL_RANGE";
	case WIRE_REPLY_CHANNEL_RANGE: return "WIRE_REPLY_CHANNEL_RANGE";
	case WIRE_GOSSIP_TIMESTAMP_FILTER: return "WIRE_GOSSIP_TIMESTAMP_FILTER";
	case WIRE_ONION_MESSAGE: return "WIRE_ONION_MESSAGE";
	}

	snprintf(invalidbuf, sizeof(invalidbuf), "INVALID %i", e);
	return invalidbuf;
}

bool peer_wire_is_defined(u16 type)
{
	switch ((enum peer_wire)type) {
	case WIRE_INIT:;
	case WIRE_ERROR:;
	case WIRE_WARNING:;
	case WIRE_PING:;
	case WIRE_PONG:;
	case WIRE_TX_ADD_INPUT:;
	case WIRE_TX_ADD_OUTPUT:;
	case WIRE_TX_REMOVE_INPUT:;
	case WIRE_TX_REMOVE_OUTPUT:;
	case WIRE_TX_COMPLETE:;
	case WIRE_TX_SIGNATURES:;
	case WIRE_OPEN_CHANNEL:;
	case WIRE_ACCEPT_CHANNEL:;
	case WIRE_FUNDING_CREATED:;
	case WIRE_FUNDING_SIGNED:;
	case WIRE_FUNDING_LOCKED:;
	case WIRE_OPEN_CHANNEL2:;
	case WIRE_ACCEPT_CHANNEL2:;
	case WIRE_INIT_RBF:;
	case WIRE_ACK_RBF:;
	case WIRE_SHUTDOWN:;
	case WIRE_CLOSING_SIGNED:;
	case WIRE_UPDATE_ADD_HTLC:;
	case WIRE_UPDATE_FULFILL_HTLC:;
	case WIRE_UPDATE_FAIL_HTLC:;
	case WIRE_UPDATE_FAIL_MALFORMED_HTLC:;
	case WIRE_COMMITMENT_SIGNED:;
	case WIRE_REVOKE_AND_ACK:;
	case WIRE_UPDATE_FEE:;
	case WIRE_CHANNEL_REESTABLISH:;
	case WIRE_ANNOUNCEMENT_SIGNATURES:;
	case WIRE_CHANNEL_ANNOUNCEMENT:;
	case WIRE_NODE_ANNOUNCEMENT:;
	case WIRE_CHANNEL_UPDATE:;
	case WIRE_QUERY_SHORT_CHANNEL_IDS:;
	case WIRE_REPLY_SHORT_CHANNEL_IDS_END:;
	case WIRE_QUERY_CHANNEL_RANGE:;
	case WIRE_REPLY_CHANNEL_RANGE:;
	case WIRE_GOSSIP_TIMESTAMP_FILTER:;
	case WIRE_ONION_MESSAGE:;
	      return true;
	}
	return false;
}




/* SUBTYPE: WITNESS_ELEMENT */
void towire_witness_element(u8 **p, const struct witness_element *witness_element)
{
	u16 len = tal_count(witness_element->witness);

	towire_u16(p, len);
	towire_u8_array(p, witness_element->witness, len);
}
struct witness_element *
fromwire_witness_element(const tal_t *ctx, const u8 **cursor, size_t *plen)
{
	struct witness_element *witness_element = tal(ctx, struct witness_element);
	u16 len;

 	len = fromwire_u16(cursor, plen);
 	witness_element->witness = len ? tal_arr(witness_element, u8, len) : NULL;
fromwire_u8_array(cursor, plen, witness_element->witness, len);

	return witness_element;
}

/* SUBTYPE: CHANNEL_UPDATE_CHECKSUMS */
void towire_channel_update_checksums(u8 **p, const struct channel_update_checksums *channel_update_checksums)
{

	towire_u32(p, channel_update_checksums->checksum_node_id_1);
	towire_u32(p, channel_update_checksums->checksum_node_id_2);
}
void fromwire_channel_update_checksums(const u8 **cursor, size_t *plen, struct channel_update_checksums *channel_update_checksums)
{

 	channel_update_checksums->checksum_node_id_1 = fromwire_u32(cursor, plen);
 	channel_update_checksums->checksum_node_id_2 = fromwire_u32(cursor, plen);
}

/* SUBTYPE: CHANNEL_UPDATE_TIMESTAMPS */
void towire_channel_update_timestamps(u8 **p, const struct channel_update_timestamps *channel_update_timestamps)
{

	towire_u32(p, channel_update_timestamps->timestamp_node_id_1);
	towire_u32(p, channel_update_timestamps->timestamp_node_id_2);
}
void fromwire_channel_update_timestamps(const u8 **cursor, size_t *plen, struct channel_update_timestamps *channel_update_timestamps)
{

 	channel_update_timestamps->timestamp_node_id_1 = fromwire_u32(cursor, plen);
 	channel_update_timestamps->timestamp_node_id_2 = fromwire_u32(cursor, plen);
}

/* SUBTYPE: WITNESS_STACK */
void towire_witness_stack(u8 **p, const struct witness_stack *witness_stack)
{
	u16 num_input_witness = tal_count(witness_stack->witness_element);

	towire_u16(p, num_input_witness);
		for (size_t i = 0; i < num_input_witness; i++)
		towire_witness_element(p, witness_stack->witness_element[i]);
}
struct witness_stack *
fromwire_witness_stack(const tal_t *ctx, const u8 **cursor, size_t *plen)
{
	struct witness_stack *witness_stack = tal(ctx, struct witness_stack);
	u16 num_input_witness;

 	num_input_witness = fromwire_u16(cursor, plen);
 	witness_stack->witness_element = num_input_witness ? tal_arr(witness_stack, struct witness_element *, 0) : NULL;
	for (size_t i = 0; i < num_input_witness; i++) {
		struct witness_element * tmp;
		tmp = fromwire_witness_element(witness_stack, cursor, plen);
		tal_arr_expand(&witness_stack->witness_element, tmp);
	}

	return witness_stack;
}


struct tlv_init_tlvs *tlv_init_tlvs_new(const tal_t *ctx)
{
	/* Initialize everything to NULL. (Quiet, C pedants!) */
	struct tlv_init_tlvs *inst = talz(ctx, struct tlv_init_tlvs);

	/* Initialized the fields to an empty array. */
	inst->fields = tal_arr(inst, struct tlv_field, 0);
	return inst;
}

/* INIT_TLVS MSG: networks */
static u8 *towire_tlv_init_tlvs_networks(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_init_tlvs *r = vrecord;
	u8 *ptr;

	if (!r->networks)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

		for (size_t i = 0; i < tal_count(r->networks); i++)
		towire_bitcoin_blkid(&ptr, r->networks + i);
	return ptr;
}
static void fromwire_tlv_init_tlvs_networks(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_init_tlvs *r = vrecord;

	r->networks = *plen ? tal_arr(r, struct bitcoin_blkid, 0) : NULL;
	for (size_t i = 0; *plen != 0; i++) {
		struct bitcoin_blkid tmp;
		fromwire_bitcoin_blkid(cursor, plen, &tmp);
		tal_arr_expand(&r->networks, tmp);
	}
}

static const struct tlv_record_type tlvs_init_tlvs[] = {
	{ 1, towire_tlv_init_tlvs_networks, fromwire_tlv_init_tlvs_networks },
};

void towire_init_tlvs(u8 **pptr, const struct tlv_init_tlvs *record)
{
	towire_tlv(pptr, tlvs_init_tlvs, 1, record);
}


bool fromwire_init_tlvs(const u8 **cursor, size_t *max, struct tlv_init_tlvs *record)
{
	return fromwire_tlv(cursor, max, tlvs_init_tlvs, 1, record, &record->fields);
}

bool init_tlvs_is_valid(const struct tlv_init_tlvs *record, size_t *err_index)
{
	return tlv_fields_valid(record->fields, err_index);
}


struct tlv_n1 *tlv_n1_new(const tal_t *ctx)
{
	/* Initialize everything to NULL. (Quiet, C pedants!) */
	struct tlv_n1 *inst = talz(ctx, struct tlv_n1);

	/* Initialized the fields to an empty array. */
	inst->fields = tal_arr(inst, struct tlv_field, 0);
	return inst;
}

/* N1 MSG: tlv1 */
static u8 *towire_tlv_n1_tlv1(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_n1 *r = vrecord;
	u8 *ptr;

	if (!r->tlv1)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_tu64(&ptr, *r->tlv1);
	return ptr;
}
static void fromwire_tlv_n1_tlv1(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_n1 *r = vrecord;

	    r->tlv1 = tal(r, u64);

*r->tlv1 = fromwire_tu64(cursor, plen);
}
/* N1 MSG: tlv2 */
static u8 *towire_tlv_n1_tlv2(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_n1 *r = vrecord;
	u8 *ptr;

	if (!r->tlv2)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_short_channel_id(&ptr, r->tlv2);
	return ptr;
}
static void fromwire_tlv_n1_tlv2(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_n1 *r = vrecord;

	    r->tlv2 = tal(r, struct short_channel_id);

fromwire_short_channel_id(cursor, plen, &*r->tlv2);
}
/* N1 MSG: tlv3 */
static u8 *towire_tlv_n1_tlv3(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_n1 *r = vrecord;
	u8 *ptr;

	if (!r->tlv3)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_pubkey(&ptr, &r->tlv3->node_id);

	towire_amount_msat(&ptr, r->tlv3->amount_msat_1);

	towire_amount_msat(&ptr, r->tlv3->amount_msat_2);
	return ptr;
}
static void fromwire_tlv_n1_tlv3(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_n1 *r = vrecord;

	r->tlv3 = tal(r, struct tlv_n1_tlv3);
	fromwire_pubkey(cursor, plen, &r->tlv3->node_id);
	r->tlv3->amount_msat_1 = fromwire_amount_msat(cursor, plen);
	r->tlv3->amount_msat_2 = fromwire_amount_msat(cursor, plen);
}
/* N1 MSG: tlv4 */
static u8 *towire_tlv_n1_tlv4(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_n1 *r = vrecord;
	u8 *ptr;

	if (!r->tlv4)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_u16(&ptr, *r->tlv4);
	return ptr;
}
static void fromwire_tlv_n1_tlv4(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_n1 *r = vrecord;

	    r->tlv4 = tal(r, u16);

*r->tlv4 = fromwire_u16(cursor, plen);
}

const struct tlv_record_type tlvs_n1[] = {
	{ 1, towire_tlv_n1_tlv1, fromwire_tlv_n1_tlv1 },
	{ 2, towire_tlv_n1_tlv2, fromwire_tlv_n1_tlv2 },
	{ 3, towire_tlv_n1_tlv3, fromwire_tlv_n1_tlv3 },
	{ 254, towire_tlv_n1_tlv4, fromwire_tlv_n1_tlv4 },
};

void towire_n1(u8 **pptr, const struct tlv_n1 *record)
{
	towire_tlv(pptr, tlvs_n1, 4, record);
}


bool fromwire_n1(const u8 **cursor, size_t *max, struct tlv_n1 *record)
{
	return fromwire_tlv(cursor, max, tlvs_n1, 4, record, &record->fields);
}

bool n1_is_valid(const struct tlv_n1 *record, size_t *err_index)
{
	return tlv_fields_valid(record->fields, err_index);
}


struct tlv_n2 *tlv_n2_new(const tal_t *ctx)
{
	/* Initialize everything to NULL. (Quiet, C pedants!) */
	struct tlv_n2 *inst = talz(ctx, struct tlv_n2);

	/* Initialized the fields to an empty array. */
	inst->fields = tal_arr(inst, struct tlv_field, 0);
	return inst;
}

/* N2 MSG: tlv1 */
static u8 *towire_tlv_n2_tlv1(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_n2 *r = vrecord;
	u8 *ptr;

	if (!r->tlv1)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_tu64(&ptr, *r->tlv1);
	return ptr;
}
static void fromwire_tlv_n2_tlv1(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_n2 *r = vrecord;

	    r->tlv1 = tal(r, u64);

*r->tlv1 = fromwire_tu64(cursor, plen);
}
/* N2 MSG: tlv2 */
static u8 *towire_tlv_n2_tlv2(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_n2 *r = vrecord;
	u8 *ptr;

	if (!r->tlv2)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_tu32(&ptr, *r->tlv2);
	return ptr;
}
static void fromwire_tlv_n2_tlv2(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_n2 *r = vrecord;

	    r->tlv2 = tal(r, u32);

*r->tlv2 = fromwire_tu32(cursor, plen);
}

const struct tlv_record_type tlvs_n2[] = {
	{ 0, towire_tlv_n2_tlv1, fromwire_tlv_n2_tlv1 },
	{ 11, towire_tlv_n2_tlv2, fromwire_tlv_n2_tlv2 },
};

void towire_n2(u8 **pptr, const struct tlv_n2 *record)
{
	towire_tlv(pptr, tlvs_n2, 2, record);
}


bool fromwire_n2(const u8 **cursor, size_t *max, struct tlv_n2 *record)
{
	return fromwire_tlv(cursor, max, tlvs_n2, 2, record, &record->fields);
}

bool n2_is_valid(const struct tlv_n2 *record, size_t *err_index)
{
	return tlv_fields_valid(record->fields, err_index);
}


struct tlv_open_channel_tlvs *tlv_open_channel_tlvs_new(const tal_t *ctx)
{
	/* Initialize everything to NULL. (Quiet, C pedants!) */
	struct tlv_open_channel_tlvs *inst = talz(ctx, struct tlv_open_channel_tlvs);

	/* Initialized the fields to an empty array. */
	inst->fields = tal_arr(inst, struct tlv_field, 0);
	return inst;
}

/* OPEN_CHANNEL_TLVS MSG: upfront_shutdown_script */
static u8 *towire_tlv_open_channel_tlvs_upfront_shutdown_script(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_open_channel_tlvs *r = vrecord;
	u8 *ptr;

	if (!r->upfront_shutdown_script)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_u8_array(&ptr, r->upfront_shutdown_script, tal_count(r->upfront_shutdown_script));
	return ptr;
}
static void fromwire_tlv_open_channel_tlvs_upfront_shutdown_script(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_open_channel_tlvs *r = vrecord;

	r->upfront_shutdown_script = *plen ? tal_arr(r, u8, *plen) : NULL;
fromwire_u8_array(cursor, plen, r->upfront_shutdown_script, *plen);
}

static const struct tlv_record_type tlvs_open_channel_tlvs[] = {
	{ 0, towire_tlv_open_channel_tlvs_upfront_shutdown_script, fromwire_tlv_open_channel_tlvs_upfront_shutdown_script },
};

void towire_open_channel_tlvs(u8 **pptr, const struct tlv_open_channel_tlvs *record)
{
	towire_tlv(pptr, tlvs_open_channel_tlvs, 1, record);
}


bool fromwire_open_channel_tlvs(const u8 **cursor, size_t *max, struct tlv_open_channel_tlvs *record)
{
	return fromwire_tlv(cursor, max, tlvs_open_channel_tlvs, 1, record, &record->fields);
}

bool open_channel_tlvs_is_valid(const struct tlv_open_channel_tlvs *record, size_t *err_index)
{
	return tlv_fields_valid(record->fields, err_index);
}


struct tlv_accept_channel_tlvs *tlv_accept_channel_tlvs_new(const tal_t *ctx)
{
	/* Initialize everything to NULL. (Quiet, C pedants!) */
	struct tlv_accept_channel_tlvs *inst = talz(ctx, struct tlv_accept_channel_tlvs);

	/* Initialized the fields to an empty array. */
	inst->fields = tal_arr(inst, struct tlv_field, 0);
	return inst;
}

/* ACCEPT_CHANNEL_TLVS MSG: upfront_shutdown_script */
static u8 *towire_tlv_accept_channel_tlvs_upfront_shutdown_script(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_accept_channel_tlvs *r = vrecord;
	u8 *ptr;

	if (!r->upfront_shutdown_script)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_u8_array(&ptr, r->upfront_shutdown_script, tal_count(r->upfront_shutdown_script));
	return ptr;
}
static void fromwire_tlv_accept_channel_tlvs_upfront_shutdown_script(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_accept_channel_tlvs *r = vrecord;

	r->upfront_shutdown_script = *plen ? tal_arr(r, u8, *plen) : NULL;
fromwire_u8_array(cursor, plen, r->upfront_shutdown_script, *plen);
}

static const struct tlv_record_type tlvs_accept_channel_tlvs[] = {
	{ 0, towire_tlv_accept_channel_tlvs_upfront_shutdown_script, fromwire_tlv_accept_channel_tlvs_upfront_shutdown_script },
};

void towire_accept_channel_tlvs(u8 **pptr, const struct tlv_accept_channel_tlvs *record)
{
	towire_tlv(pptr, tlvs_accept_channel_tlvs, 1, record);
}


bool fromwire_accept_channel_tlvs(const u8 **cursor, size_t *max, struct tlv_accept_channel_tlvs *record)
{
	return fromwire_tlv(cursor, max, tlvs_accept_channel_tlvs, 1, record, &record->fields);
}

bool accept_channel_tlvs_is_valid(const struct tlv_accept_channel_tlvs *record, size_t *err_index)
{
	return tlv_fields_valid(record->fields, err_index);
}


struct tlv_opening_tlvs *tlv_opening_tlvs_new(const tal_t *ctx)
{
	/* Initialize everything to NULL. (Quiet, C pedants!) */
	struct tlv_opening_tlvs *inst = talz(ctx, struct tlv_opening_tlvs);

	/* Initialized the fields to an empty array. */
	inst->fields = tal_arr(inst, struct tlv_field, 0);
	return inst;
}

/* OPENING_TLVS MSG: option_upfront_shutdown_script */
static u8 *towire_tlv_opening_tlvs_option_upfront_shutdown_script(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_opening_tlvs *r = vrecord;
	u8 *ptr;

	if (!r->option_upfront_shutdown_script)
		return NULL;

	u16 shutdown_len = tal_count(r->option_upfront_shutdown_script->shutdown_scriptpubkey);

	ptr = tal_arr(ctx, u8, 0);

	towire_u16(&ptr, shutdown_len);

	towire_u8_array(&ptr, r->option_upfront_shutdown_script->shutdown_scriptpubkey, shutdown_len);
	return ptr;
}
static void fromwire_tlv_opening_tlvs_option_upfront_shutdown_script(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_opening_tlvs *r = vrecord;
	u16 shutdown_len;

	r->option_upfront_shutdown_script = tal(r, struct tlv_opening_tlvs_option_upfront_shutdown_script);
	shutdown_len = fromwire_u16(cursor, plen);
	r->option_upfront_shutdown_script->shutdown_scriptpubkey = shutdown_len ? tal_arr(r->option_upfront_shutdown_script, u8, shutdown_len) : NULL;
fromwire_u8_array(cursor, plen, r->option_upfront_shutdown_script->shutdown_scriptpubkey, shutdown_len);
}

static const struct tlv_record_type tlvs_opening_tlvs[] = {
	{ 1, towire_tlv_opening_tlvs_option_upfront_shutdown_script, fromwire_tlv_opening_tlvs_option_upfront_shutdown_script },
};

void towire_opening_tlvs(u8 **pptr, const struct tlv_opening_tlvs *record)
{
	towire_tlv(pptr, tlvs_opening_tlvs, 1, record);
}


bool fromwire_opening_tlvs(const u8 **cursor, size_t *max, struct tlv_opening_tlvs *record)
{
	return fromwire_tlv(cursor, max, tlvs_opening_tlvs, 1, record, &record->fields);
}

bool opening_tlvs_is_valid(const struct tlv_opening_tlvs *record, size_t *err_index)
{
	return tlv_fields_valid(record->fields, err_index);
}


struct tlv_accept_tlvs *tlv_accept_tlvs_new(const tal_t *ctx)
{
	/* Initialize everything to NULL. (Quiet, C pedants!) */
	struct tlv_accept_tlvs *inst = talz(ctx, struct tlv_accept_tlvs);

	/* Initialized the fields to an empty array. */
	inst->fields = tal_arr(inst, struct tlv_field, 0);
	return inst;
}

/* ACCEPT_TLVS MSG: option_upfront_shutdown_script */
static u8 *towire_tlv_accept_tlvs_option_upfront_shutdown_script(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_accept_tlvs *r = vrecord;
	u8 *ptr;

	if (!r->option_upfront_shutdown_script)
		return NULL;

	u16 shutdown_len = tal_count(r->option_upfront_shutdown_script->shutdown_scriptpubkey);

	ptr = tal_arr(ctx, u8, 0);

	towire_u16(&ptr, shutdown_len);

	towire_u8_array(&ptr, r->option_upfront_shutdown_script->shutdown_scriptpubkey, shutdown_len);
	return ptr;
}
static void fromwire_tlv_accept_tlvs_option_upfront_shutdown_script(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_accept_tlvs *r = vrecord;
	u16 shutdown_len;

	r->option_upfront_shutdown_script = tal(r, struct tlv_accept_tlvs_option_upfront_shutdown_script);
	shutdown_len = fromwire_u16(cursor, plen);
	r->option_upfront_shutdown_script->shutdown_scriptpubkey = shutdown_len ? tal_arr(r->option_upfront_shutdown_script, u8, shutdown_len) : NULL;
fromwire_u8_array(cursor, plen, r->option_upfront_shutdown_script->shutdown_scriptpubkey, shutdown_len);
}

static const struct tlv_record_type tlvs_accept_tlvs[] = {
	{ 1, towire_tlv_accept_tlvs_option_upfront_shutdown_script, fromwire_tlv_accept_tlvs_option_upfront_shutdown_script },
};

void towire_accept_tlvs(u8 **pptr, const struct tlv_accept_tlvs *record)
{
	towire_tlv(pptr, tlvs_accept_tlvs, 1, record);
}


bool fromwire_accept_tlvs(const u8 **cursor, size_t *max, struct tlv_accept_tlvs *record)
{
	return fromwire_tlv(cursor, max, tlvs_accept_tlvs, 1, record, &record->fields);
}

bool accept_tlvs_is_valid(const struct tlv_accept_tlvs *record, size_t *err_index)
{
	return tlv_fields_valid(record->fields, err_index);
}


struct tlv_shutdown_tlvs *tlv_shutdown_tlvs_new(const tal_t *ctx)
{
	/* Initialize everything to NULL. (Quiet, C pedants!) */
	struct tlv_shutdown_tlvs *inst = talz(ctx, struct tlv_shutdown_tlvs);

	/* Initialized the fields to an empty array. */
	inst->fields = tal_arr(inst, struct tlv_field, 0);
	return inst;
}

/* SHUTDOWN_TLVS MSG: wrong_funding */
static u8 *towire_tlv_shutdown_tlvs_wrong_funding(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_shutdown_tlvs *r = vrecord;
	u8 *ptr;

	if (!r->wrong_funding)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_bitcoin_txid(&ptr, &r->wrong_funding->txid);

	towire_u32(&ptr, r->wrong_funding->outnum);
	return ptr;
}
static void fromwire_tlv_shutdown_tlvs_wrong_funding(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_shutdown_tlvs *r = vrecord;

	r->wrong_funding = tal(r, struct tlv_shutdown_tlvs_wrong_funding);
	fromwire_bitcoin_txid(cursor, plen, &r->wrong_funding->txid);
	r->wrong_funding->outnum = fromwire_u32(cursor, plen);
}

static const struct tlv_record_type tlvs_shutdown_tlvs[] = {
	{ 100, towire_tlv_shutdown_tlvs_wrong_funding, fromwire_tlv_shutdown_tlvs_wrong_funding },
};

void towire_shutdown_tlvs(u8 **pptr, const struct tlv_shutdown_tlvs *record)
{
	towire_tlv(pptr, tlvs_shutdown_tlvs, 1, record);
}


bool fromwire_shutdown_tlvs(const u8 **cursor, size_t *max, struct tlv_shutdown_tlvs *record)
{
	return fromwire_tlv(cursor, max, tlvs_shutdown_tlvs, 1, record, &record->fields);
}

bool shutdown_tlvs_is_valid(const struct tlv_shutdown_tlvs *record, size_t *err_index)
{
	return tlv_fields_valid(record->fields, err_index);
}


struct tlv_query_short_channel_ids_tlvs *tlv_query_short_channel_ids_tlvs_new(const tal_t *ctx)
{
	/* Initialize everything to NULL. (Quiet, C pedants!) */
	struct tlv_query_short_channel_ids_tlvs *inst = talz(ctx, struct tlv_query_short_channel_ids_tlvs);

	/* Initialized the fields to an empty array. */
	inst->fields = tal_arr(inst, struct tlv_field, 0);
	return inst;
}

/* QUERY_SHORT_CHANNEL_IDS_TLVS MSG: query_flags */
static u8 *towire_tlv_query_short_channel_ids_tlvs_query_flags(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_query_short_channel_ids_tlvs *r = vrecord;
	u8 *ptr;

	if (!r->query_flags)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_u8(&ptr, r->query_flags->encoding_type);

	towire_u8_array(&ptr, r->query_flags->encoded_query_flags, tal_count(r->query_flags->encoded_query_flags));
	return ptr;
}
static void fromwire_tlv_query_short_channel_ids_tlvs_query_flags(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_query_short_channel_ids_tlvs *r = vrecord;

	r->query_flags = tal(r, struct tlv_query_short_channel_ids_tlvs_query_flags);
	r->query_flags->encoding_type = fromwire_u8(cursor, plen);
	r->query_flags->encoded_query_flags = *plen ? tal_arr(r->query_flags, u8, *plen) : NULL;
fromwire_u8_array(cursor, plen, r->query_flags->encoded_query_flags, *plen);
}

static const struct tlv_record_type tlvs_query_short_channel_ids_tlvs[] = {
	{ 1, towire_tlv_query_short_channel_ids_tlvs_query_flags, fromwire_tlv_query_short_channel_ids_tlvs_query_flags },
};

void towire_query_short_channel_ids_tlvs(u8 **pptr, const struct tlv_query_short_channel_ids_tlvs *record)
{
	towire_tlv(pptr, tlvs_query_short_channel_ids_tlvs, 1, record);
}


bool fromwire_query_short_channel_ids_tlvs(const u8 **cursor, size_t *max, struct tlv_query_short_channel_ids_tlvs *record)
{
	return fromwire_tlv(cursor, max, tlvs_query_short_channel_ids_tlvs, 1, record, &record->fields);
}

bool query_short_channel_ids_tlvs_is_valid(const struct tlv_query_short_channel_ids_tlvs *record, size_t *err_index)
{
	return tlv_fields_valid(record->fields, err_index);
}


struct tlv_query_channel_range_tlvs *tlv_query_channel_range_tlvs_new(const tal_t *ctx)
{
	/* Initialize everything to NULL. (Quiet, C pedants!) */
	struct tlv_query_channel_range_tlvs *inst = talz(ctx, struct tlv_query_channel_range_tlvs);

	/* Initialized the fields to an empty array. */
	inst->fields = tal_arr(inst, struct tlv_field, 0);
	return inst;
}

/* QUERY_CHANNEL_RANGE_TLVS MSG: query_option */
static u8 *towire_tlv_query_channel_range_tlvs_query_option(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_query_channel_range_tlvs *r = vrecord;
	u8 *ptr;

	if (!r->query_option)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_bigsize(&ptr, *r->query_option);
	return ptr;
}
static void fromwire_tlv_query_channel_range_tlvs_query_option(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_query_channel_range_tlvs *r = vrecord;

	    r->query_option = tal(r, bigsize);

*r->query_option = fromwire_bigsize(cursor, plen);
}

static const struct tlv_record_type tlvs_query_channel_range_tlvs[] = {
	{ 1, towire_tlv_query_channel_range_tlvs_query_option, fromwire_tlv_query_channel_range_tlvs_query_option },
};

void towire_query_channel_range_tlvs(u8 **pptr, const struct tlv_query_channel_range_tlvs *record)
{
	towire_tlv(pptr, tlvs_query_channel_range_tlvs, 1, record);
}


bool fromwire_query_channel_range_tlvs(const u8 **cursor, size_t *max, struct tlv_query_channel_range_tlvs *record)
{
	return fromwire_tlv(cursor, max, tlvs_query_channel_range_tlvs, 1, record, &record->fields);
}

bool query_channel_range_tlvs_is_valid(const struct tlv_query_channel_range_tlvs *record, size_t *err_index)
{
	return tlv_fields_valid(record->fields, err_index);
}


struct tlv_reply_channel_range_tlvs *tlv_reply_channel_range_tlvs_new(const tal_t *ctx)
{
	/* Initialize everything to NULL. (Quiet, C pedants!) */
	struct tlv_reply_channel_range_tlvs *inst = talz(ctx, struct tlv_reply_channel_range_tlvs);

	/* Initialized the fields to an empty array. */
	inst->fields = tal_arr(inst, struct tlv_field, 0);
	return inst;
}

/* REPLY_CHANNEL_RANGE_TLVS MSG: timestamps_tlv */
static u8 *towire_tlv_reply_channel_range_tlvs_timestamps_tlv(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_reply_channel_range_tlvs *r = vrecord;
	u8 *ptr;

	if (!r->timestamps_tlv)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_u8(&ptr, r->timestamps_tlv->encoding_type);

	towire_u8_array(&ptr, r->timestamps_tlv->encoded_timestamps, tal_count(r->timestamps_tlv->encoded_timestamps));
	return ptr;
}
static void fromwire_tlv_reply_channel_range_tlvs_timestamps_tlv(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_reply_channel_range_tlvs *r = vrecord;

	r->timestamps_tlv = tal(r, struct tlv_reply_channel_range_tlvs_timestamps_tlv);
	r->timestamps_tlv->encoding_type = fromwire_u8(cursor, plen);
	r->timestamps_tlv->encoded_timestamps = *plen ? tal_arr(r->timestamps_tlv, u8, *plen) : NULL;
fromwire_u8_array(cursor, plen, r->timestamps_tlv->encoded_timestamps, *plen);
}
/* REPLY_CHANNEL_RANGE_TLVS MSG: checksums_tlv */
static u8 *towire_tlv_reply_channel_range_tlvs_checksums_tlv(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_reply_channel_range_tlvs *r = vrecord;
	u8 *ptr;

	if (!r->checksums_tlv)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

		for (size_t i = 0; i < tal_count(r->checksums_tlv); i++)
		towire_channel_update_checksums(&ptr, r->checksums_tlv + i);
	return ptr;
}
static void fromwire_tlv_reply_channel_range_tlvs_checksums_tlv(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_reply_channel_range_tlvs *r = vrecord;

	r->checksums_tlv = *plen ? tal_arr(r, struct channel_update_checksums, 0) : NULL;
	for (size_t i = 0; *plen != 0; i++) {
		struct channel_update_checksums tmp;
		fromwire_channel_update_checksums(cursor, plen, &tmp);
		tal_arr_expand(&r->checksums_tlv, tmp);
	}
}

static const struct tlv_record_type tlvs_reply_channel_range_tlvs[] = {
	{ 1, towire_tlv_reply_channel_range_tlvs_timestamps_tlv, fromwire_tlv_reply_channel_range_tlvs_timestamps_tlv },
	{ 3, towire_tlv_reply_channel_range_tlvs_checksums_tlv, fromwire_tlv_reply_channel_range_tlvs_checksums_tlv },
};

void towire_reply_channel_range_tlvs(u8 **pptr, const struct tlv_reply_channel_range_tlvs *record)
{
	towire_tlv(pptr, tlvs_reply_channel_range_tlvs, 2, record);
}


bool fromwire_reply_channel_range_tlvs(const u8 **cursor, size_t *max, struct tlv_reply_channel_range_tlvs *record)
{
	return fromwire_tlv(cursor, max, tlvs_reply_channel_range_tlvs, 2, record, &record->fields);
}

bool reply_channel_range_tlvs_is_valid(const struct tlv_reply_channel_range_tlvs *record, size_t *err_index)
{
	return tlv_fields_valid(record->fields, err_index);
}


struct tlv_onion_message_tlvs *tlv_onion_message_tlvs_new(const tal_t *ctx)
{
	/* Initialize everything to NULL. (Quiet, C pedants!) */
	struct tlv_onion_message_tlvs *inst = talz(ctx, struct tlv_onion_message_tlvs);

	/* Initialized the fields to an empty array. */
	inst->fields = tal_arr(inst, struct tlv_field, 0);
	return inst;
}

/* ONION_MESSAGE_TLVS MSG: blinding */
static u8 *towire_tlv_onion_message_tlvs_blinding(const tal_t *ctx, const void *vrecord)
{
	const struct tlv_onion_message_tlvs *r = vrecord;
	u8 *ptr;

	if (!r->blinding)
		return NULL;


	ptr = tal_arr(ctx, u8, 0);

	towire_pubkey(&ptr, r->blinding);
	return ptr;
}
static void fromwire_tlv_onion_message_tlvs_blinding(const u8 **cursor, size_t *plen, void *vrecord)
{
	struct tlv_onion_message_tlvs *r = vrecord;

	    r->blinding = tal(r, struct pubkey);

fromwire_pubkey(cursor, plen, &*r->blinding);
}

static const struct tlv_record_type tlvs_onion_message_tlvs[] = {
	{ 2, towire_tlv_onion_message_tlvs_blinding, fromwire_tlv_onion_message_tlvs_blinding },
};

void towire_onion_message_tlvs(u8 **pptr, const struct tlv_onion_message_tlvs *record)
{
	towire_tlv(pptr, tlvs_onion_message_tlvs, 1, record);
}


bool fromwire_onion_message_tlvs(const u8 **cursor, size_t *max, struct tlv_onion_message_tlvs *record)
{
	return fromwire_tlv(cursor, max, tlvs_onion_message_tlvs, 1, record, &record->fields);
}

bool onion_message_tlvs_is_valid(const struct tlv_onion_message_tlvs *record, size_t *err_index)
{
	return tlv_fields_valid(record->fields, err_index);
}


/* WIRE: INIT */
u8 *towire_init(const tal_t *ctx, const u8 *globalfeatures, const u8 *features, const struct tlv_init_tlvs *tlvs)
{
	u16 gflen = tal_count(globalfeatures);
	u16 flen = tal_count(features);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_INIT);
	towire_u16(&p, gflen);
	towire_u8_array(&p, globalfeatures, gflen);
	towire_u16(&p, flen);
	towire_u8_array(&p, features, flen);
	towire_init_tlvs(&p, tlvs);

	return memcheck(p, tal_count(p));
}
bool fromwire_init(const tal_t *ctx, const void *p, u8 **globalfeatures, u8 **features, struct tlv_init_tlvs *tlvs)
{
	u16 gflen;
	u16 flen;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_INIT)
		return false;
 	gflen = fromwire_u16(&cursor, &plen);
 	// 2nd case globalfeatures
	*globalfeatures = gflen ? tal_arr(ctx, u8, gflen) : NULL;
	fromwire_u8_array(&cursor, &plen, *globalfeatures, gflen);
 	flen = fromwire_u16(&cursor, &plen);
 	// 2nd case features
	*features = flen ? tal_arr(ctx, u8, flen) : NULL;
	fromwire_u8_array(&cursor, &plen, *features, flen);
 	fromwire_init_tlvs(&cursor, &plen, tlvs);
	return cursor != NULL;
}

/* WIRE: ERROR */
u8 *towire_error(const tal_t *ctx, const struct channel_id *channel_id, const u8 *data)
{
	u16 len = tal_count(data);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_ERROR);
	towire_channel_id(&p, channel_id);
	towire_u16(&p, len);
	towire_u8_array(&p, data, len);

	return memcheck(p, tal_count(p));
}
bool fromwire_error(const tal_t *ctx, const void *p, struct channel_id *channel_id, u8 **data)
{
	u16 len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_ERROR)
		return false;
 	fromwire_channel_id(&cursor, &plen, channel_id);
 	len = fromwire_u16(&cursor, &plen);
 	// 2nd case data
	*data = len ? tal_arr(ctx, u8, len) : NULL;
	fromwire_u8_array(&cursor, &plen, *data, len);
	return cursor != NULL;
}

/* WIRE: WARNING */
u8 *towire_warning(const tal_t *ctx, const struct channel_id *channel_id, const u8 *data)
{
	u16 len = tal_count(data);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_WARNING);
	towire_channel_id(&p, channel_id);
	towire_u16(&p, len);
	towire_u8_array(&p, data, len);

	return memcheck(p, tal_count(p));
}
bool fromwire_warning(const tal_t *ctx, const void *p, struct channel_id *channel_id, u8 **data)
{
	u16 len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_WARNING)
		return false;
 	fromwire_channel_id(&cursor, &plen, channel_id);
 	len = fromwire_u16(&cursor, &plen);
 	// 2nd case data
	*data = len ? tal_arr(ctx, u8, len) : NULL;
	fromwire_u8_array(&cursor, &plen, *data, len);
	return cursor != NULL;
}

/* WIRE: PING */
u8 *towire_ping(const tal_t *ctx, u16 num_pong_bytes, const u8 *ignored)
{
	u16 byteslen = tal_count(ignored);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_PING);
	towire_u16(&p, num_pong_bytes);
	towire_u16(&p, byteslen);
	towire_u8_array(&p, ignored, byteslen);

	return memcheck(p, tal_count(p));
}
bool fromwire_ping(const tal_t *ctx, const void *p, u16 *num_pong_bytes, u8 **ignored)
{
	u16 byteslen;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_PING)
		return false;
 	*num_pong_bytes = fromwire_u16(&cursor, &plen);
 	byteslen = fromwire_u16(&cursor, &plen);
 	// 2nd case ignored
	*ignored = byteslen ? tal_arr(ctx, u8, byteslen) : NULL;
	fromwire_u8_array(&cursor, &plen, *ignored, byteslen);
	return cursor != NULL;
}

/* WIRE: PONG */
u8 *towire_pong(const tal_t *ctx, const u8 *ignored)
{
	u16 byteslen = tal_count(ignored);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_PONG);
	towire_u16(&p, byteslen);
	towire_u8_array(&p, ignored, byteslen);

	return memcheck(p, tal_count(p));
}
bool fromwire_pong(const tal_t *ctx, const void *p, u8 **ignored)
{
	u16 byteslen;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_PONG)
		return false;
 	byteslen = fromwire_u16(&cursor, &plen);
 	// 2nd case ignored
	*ignored = byteslen ? tal_arr(ctx, u8, byteslen) : NULL;
	fromwire_u8_array(&cursor, &plen, *ignored, byteslen);
	return cursor != NULL;
}

/* WIRE: TX_ADD_INPUT */
u8 *towire_tx_add_input(const tal_t *ctx, const struct channel_id *channel_id, u64 serial_id, const u8 *prevtx, u32 prevtx_vout, u32 sequence, const u8 *script_sig)
{
	u16 prevtx_len = tal_count(prevtx);
	u16 script_sig_len = tal_count(script_sig);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_TX_ADD_INPUT);
	towire_channel_id(&p, channel_id);
	towire_u64(&p, serial_id);
	towire_u16(&p, prevtx_len);
	towire_u8_array(&p, prevtx, prevtx_len);
	towire_u32(&p, prevtx_vout);
	towire_u32(&p, sequence);
	towire_u16(&p, script_sig_len);
	towire_u8_array(&p, script_sig, script_sig_len);

	return memcheck(p, tal_count(p));
}
bool fromwire_tx_add_input(const tal_t *ctx, const void *p, struct channel_id *channel_id, u64 *serial_id, u8 **prevtx, u32 *prevtx_vout, u32 *sequence, u8 **script_sig)
{
	u16 prevtx_len;
	u16 script_sig_len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_TX_ADD_INPUT)
		return false;
 	fromwire_channel_id(&cursor, &plen, channel_id);
 	*serial_id = fromwire_u64(&cursor, &plen);
 	prevtx_len = fromwire_u16(&cursor, &plen);
 	// 2nd case prevtx
	*prevtx = prevtx_len ? tal_arr(ctx, u8, prevtx_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *prevtx, prevtx_len);
 	*prevtx_vout = fromwire_u32(&cursor, &plen);
 	*sequence = fromwire_u32(&cursor, &plen);
 	script_sig_len = fromwire_u16(&cursor, &plen);
 	// 2nd case script_sig
	*script_sig = script_sig_len ? tal_arr(ctx, u8, script_sig_len) : NULL;
	fromwire_u8_array(&cursor, &plen, *script_sig, script_sig_len);
	return cursor != NULL;
}

/* WIRE: TX_ADD_OUTPUT */
u8 *towire_tx_add_output(const tal_t *ctx, const struct channel_id *channel_id, u64 serial_id, u64 sats, const u8 *script)
{
	u16 scriptlen = tal_count(script);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_TX_ADD_OUTPUT);
	towire_channel_id(&p, channel_id);
	towire_u64(&p, serial_id);
	towire_u64(&p, sats);
	towire_u16(&p, scriptlen);
	towire_u8_array(&p, script, scriptlen);

	return memcheck(p, tal_count(p));
}
bool fromwire_tx_add_output(const tal_t *ctx, const void *p, struct channel_id *channel_id, u64 *serial_id, u64 *sats, u8 **script)
{
	u16 scriptlen;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_TX_ADD_OUTPUT)
		return false;
 	fromwire_channel_id(&cursor, &plen, channel_id);
 	*serial_id = fromwire_u64(&cursor, &plen);
 	*sats = fromwire_u64(&cursor, &plen);
 	scriptlen = fromwire_u16(&cursor, &plen);
 	// 2nd case script
	*script = scriptlen ? tal_arr(ctx, u8, scriptlen) : NULL;
	fromwire_u8_array(&cursor, &plen, *script, scriptlen);
	return cursor != NULL;
}

/* WIRE: TX_REMOVE_INPUT */
u8 *towire_tx_remove_input(const tal_t *ctx, const struct channel_id *channel_id, u64 serial_id)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_TX_REMOVE_INPUT);
	towire_channel_id(&p, channel_id);
	towire_u64(&p, serial_id);

	return memcheck(p, tal_count(p));
}
bool fromwire_tx_remove_input(const void *p, struct channel_id *channel_id, u64 *serial_id)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_TX_REMOVE_INPUT)
		return false;
 	fromwire_channel_id(&cursor, &plen, channel_id);
 	*serial_id = fromwire_u64(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: TX_REMOVE_OUTPUT */
u8 *towire_tx_remove_output(const tal_t *ctx, const struct channel_id *channel_id, u64 serial_id)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_TX_REMOVE_OUTPUT);
	towire_channel_id(&p, channel_id);
	towire_u64(&p, serial_id);

	return memcheck(p, tal_count(p));
}
bool fromwire_tx_remove_output(const void *p, struct channel_id *channel_id, u64 *serial_id)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_TX_REMOVE_OUTPUT)
		return false;
 	fromwire_channel_id(&cursor, &plen, channel_id);
 	*serial_id = fromwire_u64(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: TX_COMPLETE */
u8 *towire_tx_complete(const tal_t *ctx, const struct channel_id *channel_id)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_TX_COMPLETE);
	towire_channel_id(&p, channel_id);

	return memcheck(p, tal_count(p));
}
bool fromwire_tx_complete(const void *p, struct channel_id *channel_id)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_TX_COMPLETE)
		return false;
 	fromwire_channel_id(&cursor, &plen, channel_id);
	return cursor != NULL;
}

/* WIRE: TX_SIGNATURES */
u8 *towire_tx_signatures(const tal_t *ctx, const struct channel_id *channel_id, const struct bitcoin_txid *txid, const struct witness_stack **witness_stack)
{
	u16 num_witnesses = tal_count(witness_stack);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_TX_SIGNATURES);
	towire_channel_id(&p, channel_id);
	towire_bitcoin_txid(&p, txid);
	towire_u16(&p, num_witnesses);
	for (size_t i = 0; i < num_witnesses; i++)
		towire_witness_stack(&p, witness_stack[i]);

	return memcheck(p, tal_count(p));
}
bool fromwire_tx_signatures(const tal_t *ctx, const void *p, struct channel_id *channel_id, struct bitcoin_txid *txid, struct witness_stack ***witness_stack)
{
	u16 num_witnesses;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_TX_SIGNATURES)
		return false;
 	fromwire_channel_id(&cursor, &plen, channel_id);
 	fromwire_bitcoin_txid(&cursor, &plen, txid);
 	num_witnesses = fromwire_u16(&cursor, &plen);
 	// 2nd case witness_stack
	*witness_stack = num_witnesses ? tal_arr(ctx, struct witness_stack *, num_witnesses) : NULL;
	for (size_t i = 0; i < num_witnesses; i++)
		(*witness_stack)[i] = fromwire_witness_stack(*witness_stack, &cursor, &plen);
	return cursor != NULL;
}

/* WIRE: OPEN_CHANNEL */
u8 *towire_open_channel(const tal_t *ctx, const struct bitcoin_blkid *chain_hash, const struct channel_id *temporary_channel_id, struct amount_sat funding_satoshis, struct amount_msat push_msat, struct amount_sat dust_limit_satoshis, struct amount_msat max_htlc_value_in_flight_msat, struct amount_sat channel_reserve_satoshis, struct amount_msat htlc_minimum_msat, u32 feerate_per_kw, u16 to_self_delay, u16 max_accepted_htlcs, const struct pubkey *funding_pubkey, const struct pubkey *revocation_basepoint, const struct pubkey *payment_basepoint, const struct pubkey *delayed_payment_basepoint, const struct pubkey *htlc_basepoint, const struct pubkey *first_per_commitment_point, u8 channel_flags, const struct tlv_open_channel_tlvs *tlvs)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_OPEN_CHANNEL);
	towire_bitcoin_blkid(&p, chain_hash);
	towire_channel_id(&p, temporary_channel_id);
	towire_amount_sat(&p, funding_satoshis);
	towire_amount_msat(&p, push_msat);
	towire_amount_sat(&p, dust_limit_satoshis);
	towire_amount_msat(&p, max_htlc_value_in_flight_msat);
	towire_amount_sat(&p, channel_reserve_satoshis);
	towire_amount_msat(&p, htlc_minimum_msat);
	towire_u32(&p, feerate_per_kw);
	towire_u16(&p, to_self_delay);
	towire_u16(&p, max_accepted_htlcs);
	towire_pubkey(&p, funding_pubkey);
	towire_pubkey(&p, revocation_basepoint);
	towire_pubkey(&p, payment_basepoint);
	towire_pubkey(&p, delayed_payment_basepoint);
	towire_pubkey(&p, htlc_basepoint);
	towire_pubkey(&p, first_per_commitment_point);
	towire_u8(&p, channel_flags);
	towire_open_channel_tlvs(&p, tlvs);

	return memcheck(p, tal_count(p));
}
bool fromwire_open_channel(const void *p, struct bitcoin_blkid *chain_hash, struct channel_id *temporary_channel_id, struct amount_sat *funding_satoshis, struct amount_msat *push_msat, struct amount_sat *dust_limit_satoshis, struct amount_msat *max_htlc_value_in_flight_msat, struct amount_sat *channel_reserve_satoshis, struct amount_msat *htlc_minimum_msat, u32 *feerate_per_kw, u16 *to_self_delay, u16 *max_accepted_htlcs, struct pubkey *funding_pubkey, struct pubkey *revocation_basepoint, struct pubkey *payment_basepoint, struct pubkey *delayed_payment_basepoint, struct pubkey *htlc_basepoint, struct pubkey *first_per_commitment_point, u8 *channel_flags, struct tlv_open_channel_tlvs *tlvs)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_OPEN_CHANNEL)
		return false;
 	fromwire_bitcoin_blkid(&cursor, &plen, chain_hash);
 	fromwire_channel_id(&cursor, &plen, temporary_channel_id);
 	*funding_satoshis = fromwire_amount_sat(&cursor, &plen);
 	*push_msat = fromwire_amount_msat(&cursor, &plen);
 	*dust_limit_satoshis = fromwire_amount_sat(&cursor, &plen);
 	*max_htlc_value_in_flight_msat = fromwire_amount_msat(&cursor, &plen);
 	*channel_reserve_satoshis = fromwire_amount_sat(&cursor, &plen);
 	*htlc_minimum_msat = fromwire_amount_msat(&cursor, &plen);
 	*feerate_per_kw = fromwire_u32(&cursor, &plen);
 	*to_self_delay = fromwire_u16(&cursor, &plen);
 	*max_accepted_htlcs = fromwire_u16(&cursor, &plen);
 	fromwire_pubkey(&cursor, &plen, funding_pubkey);
 	fromwire_pubkey(&cursor, &plen, revocation_basepoint);
 	fromwire_pubkey(&cursor, &plen, payment_basepoint);
 	fromwire_pubkey(&cursor, &plen, delayed_payment_basepoint);
 	fromwire_pubkey(&cursor, &plen, htlc_basepoint);
 	fromwire_pubkey(&cursor, &plen, first_per_commitment_point);
 	*channel_flags = fromwire_u8(&cursor, &plen);
 	fromwire_open_channel_tlvs(&cursor, &plen, tlvs);
	return cursor != NULL;
}

/* WIRE: ACCEPT_CHANNEL */
u8 *towire_accept_channel(const tal_t *ctx, const struct channel_id *temporary_channel_id, struct amount_sat dust_limit_satoshis, struct amount_msat max_htlc_value_in_flight_msat, struct amount_sat channel_reserve_satoshis, struct amount_msat htlc_minimum_msat, u32 minimum_depth, u16 to_self_delay, u16 max_accepted_htlcs, const struct pubkey *funding_pubkey, const struct pubkey *revocation_basepoint, const struct pubkey *payment_basepoint, const struct pubkey *delayed_payment_basepoint, const struct pubkey *htlc_basepoint, const struct pubkey *first_per_commitment_point, const struct tlv_accept_channel_tlvs *tlvs)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_ACCEPT_CHANNEL);
	towire_channel_id(&p, temporary_channel_id);
	towire_amount_sat(&p, dust_limit_satoshis);
	towire_amount_msat(&p, max_htlc_value_in_flight_msat);
	towire_amount_sat(&p, channel_reserve_satoshis);
	towire_amount_msat(&p, htlc_minimum_msat);
	towire_u32(&p, minimum_depth);
	towire_u16(&p, to_self_delay);
	towire_u16(&p, max_accepted_htlcs);
	towire_pubkey(&p, funding_pubkey);
	towire_pubkey(&p, revocation_basepoint);
	towire_pubkey(&p, payment_basepoint);
	towire_pubkey(&p, delayed_payment_basepoint);
	towire_pubkey(&p, htlc_basepoint);
	towire_pubkey(&p, first_per_commitment_point);
	towire_accept_channel_tlvs(&p, tlvs);

	return memcheck(p, tal_count(p));
}
bool fromwire_accept_channel(const void *p, struct channel_id *temporary_channel_id, struct amount_sat *dust_limit_satoshis, struct amount_msat *max_htlc_value_in_flight_msat, struct amount_sat *channel_reserve_satoshis, struct amount_msat *htlc_minimum_msat, u32 *minimum_depth, u16 *to_self_delay, u16 *max_accepted_htlcs, struct pubkey *funding_pubkey, struct pubkey *revocation_basepoint, struct pubkey *payment_basepoint, struct pubkey *delayed_payment_basepoint, struct pubkey *htlc_basepoint, struct pubkey *first_per_commitment_point, struct tlv_accept_channel_tlvs *tlvs)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_ACCEPT_CHANNEL)
		return false;
 	fromwire_channel_id(&cursor, &plen, temporary_channel_id);
 	*dust_limit_satoshis = fromwire_amount_sat(&cursor, &plen);
 	*max_htlc_value_in_flight_msat = fromwire_amount_msat(&cursor, &plen);
 	*channel_reserve_satoshis = fromwire_amount_sat(&cursor, &plen);
 	*htlc_minimum_msat = fromwire_amount_msat(&cursor, &plen);
 	*minimum_depth = fromwire_u32(&cursor, &plen);
 	*to_self_delay = fromwire_u16(&cursor, &plen);
 	*max_accepted_htlcs = fromwire_u16(&cursor, &plen);
 	fromwire_pubkey(&cursor, &plen, funding_pubkey);
 	fromwire_pubkey(&cursor, &plen, revocation_basepoint);
 	fromwire_pubkey(&cursor, &plen, payment_basepoint);
 	fromwire_pubkey(&cursor, &plen, delayed_payment_basepoint);
 	fromwire_pubkey(&cursor, &plen, htlc_basepoint);
 	fromwire_pubkey(&cursor, &plen, first_per_commitment_point);
 	fromwire_accept_channel_tlvs(&cursor, &plen, tlvs);
	return cursor != NULL;
}

/* WIRE: FUNDING_CREATED */
u8 *towire_funding_created(const tal_t *ctx, const struct channel_id *temporary_channel_id, const struct bitcoin_txid *funding_txid, u16 funding_output_index, const secp256k1_ecdsa_signature *signature)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_FUNDING_CREATED);
	towire_channel_id(&p, temporary_channel_id);
	towire_bitcoin_txid(&p, funding_txid);
	towire_u16(&p, funding_output_index);
	towire_secp256k1_ecdsa_signature(&p, signature);

	return memcheck(p, tal_count(p));
}
bool fromwire_funding_created(const void *p, struct channel_id *temporary_channel_id, struct bitcoin_txid *funding_txid, u16 *funding_output_index, secp256k1_ecdsa_signature *signature)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_FUNDING_CREATED)
		return false;
 	fromwire_channel_id(&cursor, &plen, temporary_channel_id);
 	fromwire_bitcoin_txid(&cursor, &plen, funding_txid);
 	*funding_output_index = fromwire_u16(&cursor, &plen);
 	fromwire_secp256k1_ecdsa_signature(&cursor, &plen, signature);
	return cursor != NULL;
}

/* WIRE: FUNDING_SIGNED */
u8 *towire_funding_signed(const tal_t *ctx, const struct channel_id *channel_id, const secp256k1_ecdsa_signature *signature)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_FUNDING_SIGNED);
	towire_channel_id(&p, channel_id);
	towire_secp256k1_ecdsa_signature(&p, signature);

	return memcheck(p, tal_count(p));
}
bool fromwire_funding_signed(const void *p, struct channel_id *channel_id, secp256k1_ecdsa_signature *signature)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_FUNDING_SIGNED)
		return false;
 	fromwire_channel_id(&cursor, &plen, channel_id);
 	fromwire_secp256k1_ecdsa_signature(&cursor, &plen, signature);
	return cursor != NULL;
}

/* WIRE: FUNDING_LOCKED */
u8 *towire_funding_locked(const tal_t *ctx, const struct channel_id *channel_id, const struct pubkey *next_per_commitment_point)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_FUNDING_LOCKED);
	towire_channel_id(&p, channel_id);
	towire_pubkey(&p, next_per_commitment_point);

	return memcheck(p, tal_count(p));
}
bool fromwire_funding_locked(const void *p, struct channel_id *channel_id, struct pubkey *next_per_commitment_point)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_FUNDING_LOCKED)
		return false;
 	fromwire_channel_id(&cursor, &plen, channel_id);
 	fromwire_pubkey(&cursor, &plen, next_per_commitment_point);
	return cursor != NULL;
}

/* WIRE: OPEN_CHANNEL2 */
u8 *towire_open_channel2(const tal_t *ctx, const struct bitcoin_blkid *chain_hash, const struct channel_id *channel_id, u32 funding_feerate_perkw, u32 commitment_feerate_perkw, struct amount_sat funding_satoshis, struct amount_sat dust_limit_satoshis, struct amount_msat max_htlc_value_in_flight_msat, struct amount_msat htlc_minimum_msat, u16 to_self_delay, u16 max_accepted_htlcs, u32 locktime, const struct pubkey *funding_pubkey, const struct pubkey *revocation_basepoint, const struct pubkey *payment_basepoint, const struct pubkey *delayed_payment_basepoint, const struct pubkey *htlc_basepoint, const struct pubkey *first_per_commitment_point, u8 channel_flags, const struct tlv_opening_tlvs *tlvs)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_OPEN_CHANNEL2);
	towire_bitcoin_blkid(&p, chain_hash);
	towire_channel_id(&p, channel_id);
	towire_u32(&p, funding_feerate_perkw);
	towire_u32(&p, commitment_feerate_perkw);
	towire_amount_sat(&p, funding_satoshis);
	towire_amount_sat(&p, dust_limit_satoshis);
	towire_amount_msat(&p, max_htlc_value_in_flight_msat);
	towire_amount_msat(&p, htlc_minimum_msat);
	towire_u16(&p, to_self_delay);
	towire_u16(&p, max_accepted_htlcs);
	towire_u32(&p, locktime);
	towire_pubkey(&p, funding_pubkey);
	towire_pubkey(&p, revocation_basepoint);
	towire_pubkey(&p, payment_basepoint);
	towire_pubkey(&p, delayed_payment_basepoint);
	towire_pubkey(&p, htlc_basepoint);
	towire_pubkey(&p, first_per_commitment_point);
	towire_u8(&p, channel_flags);
	towire_opening_tlvs(&p, tlvs);

	return memcheck(p, tal_count(p));
}
bool fromwire_open_channel2(const void *p, struct bitcoin_blkid *chain_hash, struct channel_id *channel_id, u32 *funding_feerate_perkw, u32 *commitment_feerate_perkw, struct amount_sat *funding_satoshis, struct amount_sat *dust_limit_satoshis, struct amount_msat *max_htlc_value_in_flight_msat, struct amount_msat *htlc_minimum_msat, u16 *to_self_delay, u16 *max_accepted_htlcs, u32 *locktime, struct pubkey *funding_pubkey, struct pubkey *revocation_basepoint, struct pubkey *payment_basepoint, struct pubkey *delayed_payment_basepoint, struct pubkey *htlc_basepoint, struct pubkey *first_per_commitment_point, u8 *channel_flags, struct tlv_opening_tlvs *tlvs)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_OPEN_CHANNEL2)
		return false;
 	fromwire_bitcoin_blkid(&cursor, &plen, chain_hash);
 	fromwire_channel_id(&cursor, &plen, channel_id);
 	*funding_feerate_perkw = fromwire_u32(&cursor, &plen);
 	*commitment_feerate_perkw = fromwire_u32(&cursor, &plen);
 	*funding_satoshis = fromwire_amount_sat(&cursor, &plen);
 	*dust_limit_satoshis = fromwire_amount_sat(&cursor, &plen);
 	*max_htlc_value_in_flight_msat = fromwire_amount_msat(&cursor, &plen);
 	*htlc_minimum_msat = fromwire_amount_msat(&cursor, &plen);
 	*to_self_delay = fromwire_u16(&cursor, &plen);
 	*max_accepted_htlcs = fromwire_u16(&cursor, &plen);
 	*locktime = fromwire_u32(&cursor, &plen);
 	fromwire_pubkey(&cursor, &plen, funding_pubkey);
 	fromwire_pubkey(&cursor, &plen, revocation_basepoint);
 	fromwire_pubkey(&cursor, &plen, payment_basepoint);
 	fromwire_pubkey(&cursor, &plen, delayed_payment_basepoint);
 	fromwire_pubkey(&cursor, &plen, htlc_basepoint);
 	fromwire_pubkey(&cursor, &plen, first_per_commitment_point);
 	*channel_flags = fromwire_u8(&cursor, &plen);
 	fromwire_opening_tlvs(&cursor, &plen, tlvs);
	return cursor != NULL;
}

/* WIRE: ACCEPT_CHANNEL2 */
u8 *towire_accept_channel2(const tal_t *ctx, const struct channel_id *channel_id, struct amount_sat funding_satoshis, struct amount_sat dust_limit_satoshis, struct amount_msat max_htlc_value_in_flight_msat, struct amount_msat htlc_minimum_msat, u32 minimum_depth, u16 to_self_delay, u16 max_accepted_htlcs, const struct pubkey *funding_pubkey, const struct pubkey *revocation_basepoint, const struct pubkey *payment_basepoint, const struct pubkey *delayed_payment_basepoint, const struct pubkey *htlc_basepoint, const struct pubkey *first_per_commitment_point, const struct tlv_accept_tlvs *tlvs)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_ACCEPT_CHANNEL2);
	towire_channel_id(&p, channel_id);
	towire_amount_sat(&p, funding_satoshis);
	towire_amount_sat(&p, dust_limit_satoshis);
	towire_amount_msat(&p, max_htlc_value_in_flight_msat);
	towire_amount_msat(&p, htlc_minimum_msat);
	towire_u32(&p, minimum_depth);
	towire_u16(&p, to_self_delay);
	towire_u16(&p, max_accepted_htlcs);
	towire_pubkey(&p, funding_pubkey);
	towire_pubkey(&p, revocation_basepoint);
	towire_pubkey(&p, payment_basepoint);
	towire_pubkey(&p, delayed_payment_basepoint);
	towire_pubkey(&p, htlc_basepoint);
	towire_pubkey(&p, first_per_commitment_point);
	towire_accept_tlvs(&p, tlvs);

	return memcheck(p, tal_count(p));
}
bool fromwire_accept_channel2(const void *p, struct channel_id *channel_id, struct amount_sat *funding_satoshis, struct amount_sat *dust_limit_satoshis, struct amount_msat *max_htlc_value_in_flight_msat, struct amount_msat *htlc_minimum_msat, u32 *minimum_depth, u16 *to_self_delay, u16 *max_accepted_htlcs, struct pubkey *funding_pubkey, struct pubkey *revocation_basepoint, struct pubkey *payment_basepoint, struct pubkey *delayed_payment_basepoint, struct pubkey *htlc_basepoint, struct pubkey *first_per_commitment_point, struct tlv_accept_tlvs *tlvs)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_ACCEPT_CHANNEL2)
		return false;
 	fromwire_channel_id(&cursor, &plen, channel_id);
 	*funding_satoshis = fromwire_amount_sat(&cursor, &plen);
 	*dust_limit_satoshis = fromwire_amount_sat(&cursor, &plen);
 	*max_htlc_value_in_flight_msat = fromwire_amount_msat(&cursor, &plen);
 	*htlc_minimum_msat = fromwire_amount_msat(&cursor, &plen);
 	*minimum_depth = fromwire_u32(&cursor, &plen);
 	*to_self_delay = fromwire_u16(&cursor, &plen);
 	*max_accepted_htlcs = fromwire_u16(&cursor, &plen);
 	fromwire_pubkey(&cursor, &plen, funding_pubkey);
 	fromwire_pubkey(&cursor, &plen, revocation_basepoint);
 	fromwire_pubkey(&cursor, &plen, payment_basepoint);
 	fromwire_pubkey(&cursor, &plen, delayed_payment_basepoint);
 	fromwire_pubkey(&cursor, &plen, htlc_basepoint);
 	fromwire_pubkey(&cursor, &plen, first_per_commitment_point);
 	fromwire_accept_tlvs(&cursor, &plen, tlvs);
	return cursor != NULL;
}

/* WIRE: INIT_RBF */
u8 *towire_init_rbf(const tal_t *ctx, const struct channel_id *channel_id, struct amount_sat funding_satoshis, u32 locktime, u8 fee_step)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_INIT_RBF);
	towire_channel_id(&p, channel_id);
	towire_amount_sat(&p, funding_satoshis);
	towire_u32(&p, locktime);
	towire_u8(&p, fee_step);

	return memcheck(p, tal_count(p));
}
bool fromwire_init_rbf(const void *p, struct channel_id *channel_id, struct amount_sat *funding_satoshis, u32 *locktime, u8 *fee_step)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_INIT_RBF)
		return false;
 	fromwire_channel_id(&cursor, &plen, channel_id);
 	*funding_satoshis = fromwire_amount_sat(&cursor, &plen);
 	*locktime = fromwire_u32(&cursor, &plen);
 	*fee_step = fromwire_u8(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: ACK_RBF */
u8 *towire_ack_rbf(const tal_t *ctx, const struct channel_id *channel_id, struct amount_sat funding_satoshis)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_ACK_RBF);
	towire_channel_id(&p, channel_id);
	towire_amount_sat(&p, funding_satoshis);

	return memcheck(p, tal_count(p));
}
bool fromwire_ack_rbf(const void *p, struct channel_id *channel_id, struct amount_sat *funding_satoshis)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_ACK_RBF)
		return false;
 	fromwire_channel_id(&cursor, &plen, channel_id);
 	*funding_satoshis = fromwire_amount_sat(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: SHUTDOWN */
u8 *towire_shutdown(const tal_t *ctx, const struct channel_id *channel_id, const u8 *scriptpubkey, const struct tlv_shutdown_tlvs *tlvs)
{
	u16 len = tal_count(scriptpubkey);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_SHUTDOWN);
	towire_channel_id(&p, channel_id);
	towire_u16(&p, len);
	towire_u8_array(&p, scriptpubkey, len);
	towire_shutdown_tlvs(&p, tlvs);

	return memcheck(p, tal_count(p));
}
bool fromwire_shutdown(const tal_t *ctx, const void *p, struct channel_id *channel_id, u8 **scriptpubkey, struct tlv_shutdown_tlvs *tlvs)
{
	u16 len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_SHUTDOWN)
		return false;
 	fromwire_channel_id(&cursor, &plen, channel_id);
 	len = fromwire_u16(&cursor, &plen);
 	// 2nd case scriptpubkey
	*scriptpubkey = len ? tal_arr(ctx, u8, len) : NULL;
	fromwire_u8_array(&cursor, &plen, *scriptpubkey, len);
 	fromwire_shutdown_tlvs(&cursor, &plen, tlvs);
	return cursor != NULL;
}

/* WIRE: CLOSING_SIGNED */
u8 *towire_closing_signed(const tal_t *ctx, const struct channel_id *channel_id, struct amount_sat fee_satoshis, const secp256k1_ecdsa_signature *signature)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CLOSING_SIGNED);
	towire_channel_id(&p, channel_id);
	towire_amount_sat(&p, fee_satoshis);
	towire_secp256k1_ecdsa_signature(&p, signature);

	return memcheck(p, tal_count(p));
}
bool fromwire_closing_signed(const void *p, struct channel_id *channel_id, struct amount_sat *fee_satoshis, secp256k1_ecdsa_signature *signature)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CLOSING_SIGNED)
		return false;
 	fromwire_channel_id(&cursor, &plen, channel_id);
 	*fee_satoshis = fromwire_amount_sat(&cursor, &plen);
 	fromwire_secp256k1_ecdsa_signature(&cursor, &plen, signature);
	return cursor != NULL;
}

/* WIRE: UPDATE_ADD_HTLC */
u8 *towire_update_add_htlc(const tal_t *ctx, const struct channel_id *channel_id, u64 id, struct amount_msat amount_msat, const struct sha256 *payment_hash, u32 cltv_expiry, const u8 onion_routing_packet[1366])
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_UPDATE_ADD_HTLC);
	towire_channel_id(&p, channel_id);
	towire_u64(&p, id);
	towire_amount_msat(&p, amount_msat);
	towire_sha256(&p, payment_hash);
	towire_u32(&p, cltv_expiry);
	towire_u8_array(&p, onion_routing_packet, 1366);

	return memcheck(p, tal_count(p));
}
bool fromwire_update_add_htlc(const void *p, struct channel_id *channel_id, u64 *id, struct amount_msat *amount_msat, struct sha256 *payment_hash, u32 *cltv_expiry, u8 onion_routing_packet[1366])
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_UPDATE_ADD_HTLC)
		return false;
 	fromwire_channel_id(&cursor, &plen, channel_id);
 	*id = fromwire_u64(&cursor, &plen);
 	*amount_msat = fromwire_amount_msat(&cursor, &plen);
 	fromwire_sha256(&cursor, &plen, payment_hash);
 	*cltv_expiry = fromwire_u32(&cursor, &plen);
 	fromwire_u8_array(&cursor, &plen, onion_routing_packet, 1366);
	return cursor != NULL;
}

/* WIRE: UPDATE_FULFILL_HTLC */
u8 *towire_update_fulfill_htlc(const tal_t *ctx, const struct channel_id *channel_id, u64 id, const struct preimage *payment_preimage)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_UPDATE_FULFILL_HTLC);
	towire_channel_id(&p, channel_id);
	towire_u64(&p, id);
	towire_preimage(&p, payment_preimage);

	return memcheck(p, tal_count(p));
}
bool fromwire_update_fulfill_htlc(const void *p, struct channel_id *channel_id, u64 *id, struct preimage *payment_preimage)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_UPDATE_FULFILL_HTLC)
		return false;
 	fromwire_channel_id(&cursor, &plen, channel_id);
 	*id = fromwire_u64(&cursor, &plen);
 	fromwire_preimage(&cursor, &plen, payment_preimage);
	return cursor != NULL;
}

/* WIRE: UPDATE_FAIL_HTLC */
u8 *towire_update_fail_htlc(const tal_t *ctx, const struct channel_id *channel_id, u64 id, const u8 *reason)
{
	u16 len = tal_count(reason);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_UPDATE_FAIL_HTLC);
	towire_channel_id(&p, channel_id);
	towire_u64(&p, id);
	towire_u16(&p, len);
	towire_u8_array(&p, reason, len);

	return memcheck(p, tal_count(p));
}
bool fromwire_update_fail_htlc(const tal_t *ctx, const void *p, struct channel_id *channel_id, u64 *id, u8 **reason)
{
	u16 len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_UPDATE_FAIL_HTLC)
		return false;
 	fromwire_channel_id(&cursor, &plen, channel_id);
 	*id = fromwire_u64(&cursor, &plen);
 	len = fromwire_u16(&cursor, &plen);
 	// 2nd case reason
	*reason = len ? tal_arr(ctx, u8, len) : NULL;
	fromwire_u8_array(&cursor, &plen, *reason, len);
	return cursor != NULL;
}

/* WIRE: UPDATE_FAIL_MALFORMED_HTLC */
u8 *towire_update_fail_malformed_htlc(const tal_t *ctx, const struct channel_id *channel_id, u64 id, const struct sha256 *sha256_of_onion, u16 failure_code)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_UPDATE_FAIL_MALFORMED_HTLC);
	towire_channel_id(&p, channel_id);
	towire_u64(&p, id);
	towire_sha256(&p, sha256_of_onion);
	towire_u16(&p, failure_code);

	return memcheck(p, tal_count(p));
}
bool fromwire_update_fail_malformed_htlc(const void *p, struct channel_id *channel_id, u64 *id, struct sha256 *sha256_of_onion, u16 *failure_code)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_UPDATE_FAIL_MALFORMED_HTLC)
		return false;
 	fromwire_channel_id(&cursor, &plen, channel_id);
 	*id = fromwire_u64(&cursor, &plen);
 	fromwire_sha256(&cursor, &plen, sha256_of_onion);
 	*failure_code = fromwire_u16(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: COMMITMENT_SIGNED */
u8 *towire_commitment_signed(const tal_t *ctx, const struct channel_id *channel_id, const secp256k1_ecdsa_signature *signature, const secp256k1_ecdsa_signature *htlc_signature)
{
	u16 num_htlcs = tal_count(htlc_signature);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_COMMITMENT_SIGNED);
	towire_channel_id(&p, channel_id);
	towire_secp256k1_ecdsa_signature(&p, signature);
	towire_u16(&p, num_htlcs);
	for (size_t i = 0; i < num_htlcs; i++)
		towire_secp256k1_ecdsa_signature(&p, htlc_signature + i);

	return memcheck(p, tal_count(p));
}
bool fromwire_commitment_signed(const tal_t *ctx, const void *p, struct channel_id *channel_id, secp256k1_ecdsa_signature *signature, secp256k1_ecdsa_signature **htlc_signature)
{
	u16 num_htlcs;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_COMMITMENT_SIGNED)
		return false;
 	fromwire_channel_id(&cursor, &plen, channel_id);
 	fromwire_secp256k1_ecdsa_signature(&cursor, &plen, signature);
 	num_htlcs = fromwire_u16(&cursor, &plen);
 	// 2nd case htlc_signature
	*htlc_signature = num_htlcs ? tal_arr(ctx, secp256k1_ecdsa_signature, num_htlcs) : NULL;
	for (size_t i = 0; i < num_htlcs; i++)
		fromwire_secp256k1_ecdsa_signature(&cursor, &plen, *htlc_signature + i);
	return cursor != NULL;
}

/* WIRE: REVOKE_AND_ACK */
u8 *towire_revoke_and_ack(const tal_t *ctx, const struct channel_id *channel_id, const struct secret *per_commitment_secret, const struct pubkey *next_per_commitment_point)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_REVOKE_AND_ACK);
	towire_channel_id(&p, channel_id);
	towire_secret(&p, per_commitment_secret);
	towire_pubkey(&p, next_per_commitment_point);

	return memcheck(p, tal_count(p));
}
bool fromwire_revoke_and_ack(const void *p, struct channel_id *channel_id, struct secret *per_commitment_secret, struct pubkey *next_per_commitment_point)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_REVOKE_AND_ACK)
		return false;
 	fromwire_channel_id(&cursor, &plen, channel_id);
 	fromwire_secret(&cursor, &plen, per_commitment_secret);
 	fromwire_pubkey(&cursor, &plen, next_per_commitment_point);
	return cursor != NULL;
}

/* WIRE: UPDATE_FEE */
u8 *towire_update_fee(const tal_t *ctx, const struct channel_id *channel_id, u32 feerate_per_kw)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_UPDATE_FEE);
	towire_channel_id(&p, channel_id);
	towire_u32(&p, feerate_per_kw);

	return memcheck(p, tal_count(p));
}
bool fromwire_update_fee(const void *p, struct channel_id *channel_id, u32 *feerate_per_kw)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_UPDATE_FEE)
		return false;
 	fromwire_channel_id(&cursor, &plen, channel_id);
 	*feerate_per_kw = fromwire_u32(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: CHANNEL_REESTABLISH */
u8 *towire_channel_reestablish(const tal_t *ctx, const struct channel_id *channel_id, u64 next_commitment_number, u64 next_revocation_number, const struct secret *your_last_per_commitment_secret, const struct pubkey *my_current_per_commitment_point)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_REESTABLISH);
	towire_channel_id(&p, channel_id);
	towire_u64(&p, next_commitment_number);
	towire_u64(&p, next_revocation_number);
	towire_secret(&p, your_last_per_commitment_secret);
	towire_pubkey(&p, my_current_per_commitment_point);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_reestablish(const void *p, struct channel_id *channel_id, u64 *next_commitment_number, u64 *next_revocation_number, struct secret *your_last_per_commitment_secret, struct pubkey *my_current_per_commitment_point)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_REESTABLISH)
		return false;
 	fromwire_channel_id(&cursor, &plen, channel_id);
 	*next_commitment_number = fromwire_u64(&cursor, &plen);
 	*next_revocation_number = fromwire_u64(&cursor, &plen);
 	fromwire_secret(&cursor, &plen, your_last_per_commitment_secret);
 	fromwire_pubkey(&cursor, &plen, my_current_per_commitment_point);
	return cursor != NULL;
}

/* WIRE: ANNOUNCEMENT_SIGNATURES */
u8 *towire_announcement_signatures(const tal_t *ctx, const struct channel_id *channel_id, const struct short_channel_id *short_channel_id, const secp256k1_ecdsa_signature *node_signature, const secp256k1_ecdsa_signature *bitcoin_signature)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_ANNOUNCEMENT_SIGNATURES);
	towire_channel_id(&p, channel_id);
	towire_short_channel_id(&p, short_channel_id);
	towire_secp256k1_ecdsa_signature(&p, node_signature);
	towire_secp256k1_ecdsa_signature(&p, bitcoin_signature);

	return memcheck(p, tal_count(p));
}
bool fromwire_announcement_signatures(const void *p, struct channel_id *channel_id, struct short_channel_id *short_channel_id, secp256k1_ecdsa_signature *node_signature, secp256k1_ecdsa_signature *bitcoin_signature)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_ANNOUNCEMENT_SIGNATURES)
		return false;
 	fromwire_channel_id(&cursor, &plen, channel_id);
 	fromwire_short_channel_id(&cursor, &plen, short_channel_id);
 	fromwire_secp256k1_ecdsa_signature(&cursor, &plen, node_signature);
 	fromwire_secp256k1_ecdsa_signature(&cursor, &plen, bitcoin_signature);
	return cursor != NULL;
}

/* WIRE: CHANNEL_ANNOUNCEMENT */
u8 *towire_channel_announcement(const tal_t *ctx, const secp256k1_ecdsa_signature *node_signature_1, const secp256k1_ecdsa_signature *node_signature_2, const secp256k1_ecdsa_signature *bitcoin_signature_1, const secp256k1_ecdsa_signature *bitcoin_signature_2, const u8 *features, const struct bitcoin_blkid *chain_hash, const struct short_channel_id *short_channel_id, const struct node_id *node_id_1, const struct node_id *node_id_2, const struct pubkey *bitcoin_key_1, const struct pubkey *bitcoin_key_2)
{
	u16 len = tal_count(features);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_ANNOUNCEMENT);
	towire_secp256k1_ecdsa_signature(&p, node_signature_1);
	towire_secp256k1_ecdsa_signature(&p, node_signature_2);
	towire_secp256k1_ecdsa_signature(&p, bitcoin_signature_1);
	towire_secp256k1_ecdsa_signature(&p, bitcoin_signature_2);
	towire_u16(&p, len);
	towire_u8_array(&p, features, len);
	towire_bitcoin_blkid(&p, chain_hash);
	towire_short_channel_id(&p, short_channel_id);
	towire_node_id(&p, node_id_1);
	towire_node_id(&p, node_id_2);
	towire_pubkey(&p, bitcoin_key_1);
	towire_pubkey(&p, bitcoin_key_2);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_announcement(const tal_t *ctx, const void *p, secp256k1_ecdsa_signature *node_signature_1, secp256k1_ecdsa_signature *node_signature_2, secp256k1_ecdsa_signature *bitcoin_signature_1, secp256k1_ecdsa_signature *bitcoin_signature_2, u8 **features, struct bitcoin_blkid *chain_hash, struct short_channel_id *short_channel_id, struct node_id *node_id_1, struct node_id *node_id_2, struct pubkey *bitcoin_key_1, struct pubkey *bitcoin_key_2)
{
	u16 len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_ANNOUNCEMENT)
		return false;
 	fromwire_secp256k1_ecdsa_signature(&cursor, &plen, node_signature_1);
 	fromwire_secp256k1_ecdsa_signature(&cursor, &plen, node_signature_2);
 	fromwire_secp256k1_ecdsa_signature(&cursor, &plen, bitcoin_signature_1);
 	fromwire_secp256k1_ecdsa_signature(&cursor, &plen, bitcoin_signature_2);
 	len = fromwire_u16(&cursor, &plen);
 	// 2nd case features
	*features = len ? tal_arr(ctx, u8, len) : NULL;
	fromwire_u8_array(&cursor, &plen, *features, len);
 	fromwire_bitcoin_blkid(&cursor, &plen, chain_hash);
 	fromwire_short_channel_id(&cursor, &plen, short_channel_id);
 	fromwire_node_id(&cursor, &plen, node_id_1);
 	fromwire_node_id(&cursor, &plen, node_id_2);
 	fromwire_pubkey(&cursor, &plen, bitcoin_key_1);
 	fromwire_pubkey(&cursor, &plen, bitcoin_key_2);
	return cursor != NULL;
}

/* WIRE: NODE_ANNOUNCEMENT */
u8 *towire_node_announcement(const tal_t *ctx, const secp256k1_ecdsa_signature *signature, const u8 *features, u32 timestamp, const struct node_id *node_id, const u8 rgb_color[3], const u8 alias[32], const u8 *addresses)
{
	u16 flen = tal_count(features);
	u16 addrlen = tal_count(addresses);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_NODE_ANNOUNCEMENT);
	towire_secp256k1_ecdsa_signature(&p, signature);
	towire_u16(&p, flen);
	towire_u8_array(&p, features, flen);
	towire_u32(&p, timestamp);
	towire_node_id(&p, node_id);
	towire_u8_array(&p, rgb_color, 3);
	towire_u8_array(&p, alias, 32);
	towire_u16(&p, addrlen);
	towire_u8_array(&p, addresses, addrlen);

	return memcheck(p, tal_count(p));
}
bool fromwire_node_announcement(const tal_t *ctx, const void *p, secp256k1_ecdsa_signature *signature, u8 **features, u32 *timestamp, struct node_id *node_id, u8 rgb_color[3], u8 alias[32], u8 **addresses)
{
	u16 flen;
	u16 addrlen;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_NODE_ANNOUNCEMENT)
		return false;
 	fromwire_secp256k1_ecdsa_signature(&cursor, &plen, signature);
 	flen = fromwire_u16(&cursor, &plen);
 	// 2nd case features
	*features = flen ? tal_arr(ctx, u8, flen) : NULL;
	fromwire_u8_array(&cursor, &plen, *features, flen);
 	*timestamp = fromwire_u32(&cursor, &plen);
 	fromwire_node_id(&cursor, &plen, node_id);
 	fromwire_u8_array(&cursor, &plen, rgb_color, 3);
 	fromwire_u8_array(&cursor, &plen, alias, 32);
 	addrlen = fromwire_u16(&cursor, &plen);
 	// 2nd case addresses
	*addresses = addrlen ? tal_arr(ctx, u8, addrlen) : NULL;
	fromwire_u8_array(&cursor, &plen, *addresses, addrlen);
	return cursor != NULL;
}

/* WIRE: CHANNEL_UPDATE */
u8 *towire_channel_update(const tal_t *ctx, const secp256k1_ecdsa_signature *signature, const struct bitcoin_blkid *chain_hash, const struct short_channel_id *short_channel_id, u32 timestamp, u8 message_flags, u8 channel_flags, u16 cltv_expiry_delta, struct amount_msat htlc_minimum_msat, u32 fee_base_msat, u32 fee_proportional_millionths)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_UPDATE);
	towire_secp256k1_ecdsa_signature(&p, signature);
	towire_bitcoin_blkid(&p, chain_hash);
	towire_short_channel_id(&p, short_channel_id);
	towire_u32(&p, timestamp);
	towire_u8(&p, message_flags);
	towire_u8(&p, channel_flags);
	towire_u16(&p, cltv_expiry_delta);
	towire_amount_msat(&p, htlc_minimum_msat);
	towire_u32(&p, fee_base_msat);
	towire_u32(&p, fee_proportional_millionths);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_update(const void *p, secp256k1_ecdsa_signature *signature, struct bitcoin_blkid *chain_hash, struct short_channel_id *short_channel_id, u32 *timestamp, u8 *message_flags, u8 *channel_flags, u16 *cltv_expiry_delta, struct amount_msat *htlc_minimum_msat, u32 *fee_base_msat, u32 *fee_proportional_millionths)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_UPDATE)
		return false;
 	fromwire_secp256k1_ecdsa_signature(&cursor, &plen, signature);
 	fromwire_bitcoin_blkid(&cursor, &plen, chain_hash);
 	fromwire_short_channel_id(&cursor, &plen, short_channel_id);
 	*timestamp = fromwire_u32(&cursor, &plen);
 	*message_flags = fromwire_u8(&cursor, &plen);
 	*channel_flags = fromwire_u8(&cursor, &plen);
 	*cltv_expiry_delta = fromwire_u16(&cursor, &plen);
 	*htlc_minimum_msat = fromwire_amount_msat(&cursor, &plen);
 	*fee_base_msat = fromwire_u32(&cursor, &plen);
 	*fee_proportional_millionths = fromwire_u32(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: QUERY_SHORT_CHANNEL_IDS */
u8 *towire_query_short_channel_ids(const tal_t *ctx, const struct bitcoin_blkid *chain_hash, const u8 *encoded_short_ids, const struct tlv_query_short_channel_ids_tlvs *tlvs)
{
	u16 len = tal_count(encoded_short_ids);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_QUERY_SHORT_CHANNEL_IDS);
	towire_bitcoin_blkid(&p, chain_hash);
	towire_u16(&p, len);
	towire_u8_array(&p, encoded_short_ids, len);
	towire_query_short_channel_ids_tlvs(&p, tlvs);

	return memcheck(p, tal_count(p));
}
bool fromwire_query_short_channel_ids(const tal_t *ctx, const void *p, struct bitcoin_blkid *chain_hash, u8 **encoded_short_ids, struct tlv_query_short_channel_ids_tlvs *tlvs)
{
	u16 len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_QUERY_SHORT_CHANNEL_IDS)
		return false;
 	fromwire_bitcoin_blkid(&cursor, &plen, chain_hash);
 	len = fromwire_u16(&cursor, &plen);
 	// 2nd case encoded_short_ids
	*encoded_short_ids = len ? tal_arr(ctx, u8, len) : NULL;
	fromwire_u8_array(&cursor, &plen, *encoded_short_ids, len);
 	fromwire_query_short_channel_ids_tlvs(&cursor, &plen, tlvs);
	return cursor != NULL;
}

/* WIRE: REPLY_SHORT_CHANNEL_IDS_END */
u8 *towire_reply_short_channel_ids_end(const tal_t *ctx, const struct bitcoin_blkid *chain_hash, u8 full_information)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_REPLY_SHORT_CHANNEL_IDS_END);
	towire_bitcoin_blkid(&p, chain_hash);
	towire_u8(&p, full_information);

	return memcheck(p, tal_count(p));
}
bool fromwire_reply_short_channel_ids_end(const void *p, struct bitcoin_blkid *chain_hash, u8 *full_information)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_REPLY_SHORT_CHANNEL_IDS_END)
		return false;
 	fromwire_bitcoin_blkid(&cursor, &plen, chain_hash);
 	*full_information = fromwire_u8(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: QUERY_CHANNEL_RANGE */
u8 *towire_query_channel_range(const tal_t *ctx, const struct bitcoin_blkid *chain_hash, u32 first_blocknum, u32 number_of_blocks, const struct tlv_query_channel_range_tlvs *tlvs)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_QUERY_CHANNEL_RANGE);
	towire_bitcoin_blkid(&p, chain_hash);
	towire_u32(&p, first_blocknum);
	towire_u32(&p, number_of_blocks);
	towire_query_channel_range_tlvs(&p, tlvs);

	return memcheck(p, tal_count(p));
}
bool fromwire_query_channel_range(const void *p, struct bitcoin_blkid *chain_hash, u32 *first_blocknum, u32 *number_of_blocks, struct tlv_query_channel_range_tlvs *tlvs)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_QUERY_CHANNEL_RANGE)
		return false;
 	fromwire_bitcoin_blkid(&cursor, &plen, chain_hash);
 	*first_blocknum = fromwire_u32(&cursor, &plen);
 	*number_of_blocks = fromwire_u32(&cursor, &plen);
 	fromwire_query_channel_range_tlvs(&cursor, &plen, tlvs);
	return cursor != NULL;
}

/* WIRE: REPLY_CHANNEL_RANGE */
u8 *towire_reply_channel_range(const tal_t *ctx, const struct bitcoin_blkid *chain_hash, u32 first_blocknum, u32 number_of_blocks, u8 sync_complete, const u8 *encoded_short_ids, const struct tlv_reply_channel_range_tlvs *tlvs)
{
	u16 len = tal_count(encoded_short_ids);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_REPLY_CHANNEL_RANGE);
	towire_bitcoin_blkid(&p, chain_hash);
	towire_u32(&p, first_blocknum);
	towire_u32(&p, number_of_blocks);
	towire_u8(&p, sync_complete);
	towire_u16(&p, len);
	towire_u8_array(&p, encoded_short_ids, len);
	towire_reply_channel_range_tlvs(&p, tlvs);

	return memcheck(p, tal_count(p));
}
bool fromwire_reply_channel_range(const tal_t *ctx, const void *p, struct bitcoin_blkid *chain_hash, u32 *first_blocknum, u32 *number_of_blocks, u8 *sync_complete, u8 **encoded_short_ids, struct tlv_reply_channel_range_tlvs *tlvs)
{
	u16 len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_REPLY_CHANNEL_RANGE)
		return false;
 	fromwire_bitcoin_blkid(&cursor, &plen, chain_hash);
 	*first_blocknum = fromwire_u32(&cursor, &plen);
 	*number_of_blocks = fromwire_u32(&cursor, &plen);
 	*sync_complete = fromwire_u8(&cursor, &plen);
 	len = fromwire_u16(&cursor, &plen);
 	// 2nd case encoded_short_ids
	*encoded_short_ids = len ? tal_arr(ctx, u8, len) : NULL;
	fromwire_u8_array(&cursor, &plen, *encoded_short_ids, len);
 	fromwire_reply_channel_range_tlvs(&cursor, &plen, tlvs);
	return cursor != NULL;
}

/* WIRE: GOSSIP_TIMESTAMP_FILTER */
u8 *towire_gossip_timestamp_filter(const tal_t *ctx, const struct bitcoin_blkid *chain_hash, u32 first_timestamp, u32 timestamp_range)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_GOSSIP_TIMESTAMP_FILTER);
	towire_bitcoin_blkid(&p, chain_hash);
	towire_u32(&p, first_timestamp);
	towire_u32(&p, timestamp_range);

	return memcheck(p, tal_count(p));
}
bool fromwire_gossip_timestamp_filter(const void *p, struct bitcoin_blkid *chain_hash, u32 *first_timestamp, u32 *timestamp_range)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_GOSSIP_TIMESTAMP_FILTER)
		return false;
 	fromwire_bitcoin_blkid(&cursor, &plen, chain_hash);
 	*first_timestamp = fromwire_u32(&cursor, &plen);
 	*timestamp_range = fromwire_u32(&cursor, &plen);
	return cursor != NULL;
}

/* WIRE: ONION_MESSAGE */
u8 *towire_onion_message(const tal_t *ctx, const u8 *onionmsg, const struct tlv_onion_message_tlvs *onion_message_tlvs)
{
	u16 len = tal_count(onionmsg);
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_ONION_MESSAGE);
	towire_u16(&p, len);
	towire_u8_array(&p, onionmsg, len);
	towire_onion_message_tlvs(&p, onion_message_tlvs);

	return memcheck(p, tal_count(p));
}
bool fromwire_onion_message(const tal_t *ctx, const void *p, u8 **onionmsg, struct tlv_onion_message_tlvs *onion_message_tlvs)
{
	u16 len;

	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_ONION_MESSAGE)
		return false;
 	len = fromwire_u16(&cursor, &plen);
 	// 2nd case onionmsg
	*onionmsg = len ? tal_arr(ctx, u8, len) : NULL;
	fromwire_u8_array(&cursor, &plen, *onionmsg, len);
 	fromwire_onion_message_tlvs(&cursor, &plen, onion_message_tlvs);
	return cursor != NULL;
}

/* WIRE: CHANNEL_UPDATE_OPTION_CHANNEL_HTLC_MAX */
u8 *towire_channel_update_option_channel_htlc_max(const tal_t *ctx, const secp256k1_ecdsa_signature *signature, const struct bitcoin_blkid *chain_hash, const struct short_channel_id *short_channel_id, u32 timestamp, u8 message_flags, u8 channel_flags, u16 cltv_expiry_delta, struct amount_msat htlc_minimum_msat, u32 fee_base_msat, u32 fee_proportional_millionths, struct amount_msat htlc_maximum_msat)
{
	u8 *p = tal_arr(ctx, u8, 0);

	towire_u16(&p, WIRE_CHANNEL_UPDATE);
	towire_secp256k1_ecdsa_signature(&p, signature);
	towire_bitcoin_blkid(&p, chain_hash);
	towire_short_channel_id(&p, short_channel_id);
	towire_u32(&p, timestamp);
	towire_u8(&p, message_flags);
	towire_u8(&p, channel_flags);
	towire_u16(&p, cltv_expiry_delta);
	towire_amount_msat(&p, htlc_minimum_msat);
	towire_u32(&p, fee_base_msat);
	towire_u32(&p, fee_proportional_millionths);
	towire_amount_msat(&p, htlc_maximum_msat);

	return memcheck(p, tal_count(p));
}
bool fromwire_channel_update_option_channel_htlc_max(const void *p, secp256k1_ecdsa_signature *signature, struct bitcoin_blkid *chain_hash, struct short_channel_id *short_channel_id, u32 *timestamp, u8 *message_flags, u8 *channel_flags, u16 *cltv_expiry_delta, struct amount_msat *htlc_minimum_msat, u32 *fee_base_msat, u32 *fee_proportional_millionths, struct amount_msat *htlc_maximum_msat)
{
	const u8 *cursor = p;
	size_t plen = tal_count(p);

	if (fromwire_u16(&cursor, &plen) != WIRE_CHANNEL_UPDATE)
		return false;
 	fromwire_secp256k1_ecdsa_signature(&cursor, &plen, signature);
 	fromwire_bitcoin_blkid(&cursor, &plen, chain_hash);
 	fromwire_short_channel_id(&cursor, &plen, short_channel_id);
 	*timestamp = fromwire_u32(&cursor, &plen);
 	*message_flags = fromwire_u8(&cursor, &plen);
 	*channel_flags = fromwire_u8(&cursor, &plen);
 	*cltv_expiry_delta = fromwire_u16(&cursor, &plen);
 	*htlc_minimum_msat = fromwire_amount_msat(&cursor, &plen);
 	*fee_base_msat = fromwire_u32(&cursor, &plen);
 	*fee_proportional_millionths = fromwire_u32(&cursor, &plen);
 	*htlc_maximum_msat = fromwire_amount_msat(&cursor, &plen);
	return cursor != NULL;
}
// SHA256STAMP:13b9d519f8dde4c4d6a6995a2961d9d6ef810cc9f81d3ab1bd054da4c383ffe0
